{"ast":null,"code":"/*\n Highstock JS v9.3.2 (2021-11-29)\n\n (c) 2009-2021 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n'use strict';\n\n(function (V, N) {\n  \"object\" === typeof module && module.exports ? (N[\"default\"] = N, module.exports = V.document ? N(V) : N) : \"function\" === typeof define && define.amd ? define(\"highcharts/highstock\", function () {\n    return N(V);\n  }) : (V.Highcharts && V.Highcharts.error(16, !0), V.Highcharts = N(V));\n})(\"undefined\" !== typeof window ? window : this, function (V) {\n  function N(h, E, A, F) {\n    h.hasOwnProperty(E) || (h[E] = F.apply(null, A));\n  }\n\n  var h = {};\n  N(h, \"Core/Globals.js\", [], function () {\n    var h = \"undefined\" !== typeof V ? V : \"undefined\" !== typeof window ? window : {},\n        E;\n\n    (function (d) {\n      d.SVG_NS = \"http://www.w3.org/2000/svg\";\n      d.product = \"Highcharts\";\n      d.version = \"9.3.2\";\n      d.win = h;\n      d.doc = d.win.document;\n      d.svg = d.doc && d.doc.createElementNS && !!d.doc.createElementNS(d.SVG_NS, \"svg\").createSVGRect;\n      d.userAgent = d.win.navigator && d.win.navigator.userAgent || \"\";\n      d.isChrome = -1 !== d.userAgent.indexOf(\"Chrome\");\n      d.isFirefox = -1 !== d.userAgent.indexOf(\"Firefox\");\n      d.isMS = /(edge|msie|trident)/i.test(d.userAgent) && !d.win.opera;\n      d.isSafari = !d.isChrome && -1 !== d.userAgent.indexOf(\"Safari\");\n      d.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(d.userAgent);\n      d.isWebKit = -1 !== d.userAgent.indexOf(\"AppleWebKit\");\n      d.deg2rad = 2 * Math.PI / 360;\n      d.hasBidiBug = d.isFirefox && 4 > parseInt(d.userAgent.split(\"Firefox/\")[1], 10);\n      d.hasTouch = !!d.win.TouchEvent;\n      d.marginNames = [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"];\n\n      d.noop = function () {};\n\n      d.supportsPassiveEvents = function () {\n        var h = !1;\n\n        if (!d.isMS) {\n          var E = Object.defineProperty({}, \"passive\", {\n            get: function () {\n              h = !0;\n            }\n          });\n          d.win.addEventListener && d.win.removeEventListener && (d.win.addEventListener(\"testPassive\", d.noop, E), d.win.removeEventListener(\"testPassive\", d.noop, E));\n        }\n\n        return h;\n      }();\n\n      d.charts = [];\n      d.dateFormats = {};\n      d.seriesTypes = {};\n      d.symbolSizes = {};\n      d.chartCount = 0;\n    })(E || (E = {}));\n\n    \"\";\n    return E;\n  });\n  N(h, \"Core/Utilities.js\", [h[\"Core/Globals.js\"]], function (d) {\n    function h(e, g, b, k) {\n      var l = g ? \"Highcharts error\" : \"Highcharts warning\";\n      32 === e && (e = l + \": Deprecated member\");\n      var r = p(e),\n          B = r ? l + \" #\" + e + \": www.highcharts.com/errors/\" + e + \"/\" : e.toString();\n\n      if (\"undefined\" !== typeof k) {\n        var M = \"\";\n        r && (B += \"?\");\n        I(k, function (b, e) {\n          M += \"\\n - \" + e + \": \" + b;\n          r && (B += encodeURI(e) + \"=\" + encodeURI(b));\n        });\n        B += M;\n      }\n\n      K(d, \"displayError\", {\n        chart: b,\n        code: e,\n        message: B,\n        params: k\n      }, function () {\n        if (g) throw Error(B);\n        u.console && -1 === h.messages.indexOf(B) && console.warn(B);\n      });\n      h.messages.push(B);\n    }\n\n    function A(e, g) {\n      var b = {};\n      I(e, function (k, l) {\n        if (H(e[l], !0) && !e.nodeType && g[l]) k = A(e[l], g[l]), Object.keys(k).length && (b[l] = k);else if (H(e[l]) || e[l] !== g[l]) b[l] = e[l];\n      });\n      return b;\n    }\n\n    function F(e, g) {\n      return parseInt(e, g || 10);\n    }\n\n    function t(e) {\n      return \"string\" === typeof e;\n    }\n\n    function G(e) {\n      e = Object.prototype.toString.call(e);\n      return \"[object Array]\" === e || \"[object Array Iterator]\" === e;\n    }\n\n    function H(e, g) {\n      return !!e && \"object\" === typeof e && (!g || !G(e));\n    }\n\n    function y(e) {\n      return H(e) && \"number\" === typeof e.nodeType;\n    }\n\n    function q(e) {\n      var g = e && e.constructor;\n      return !(!H(e, !0) || y(e) || !g || !g.name || \"Object\" === g.name);\n    }\n\n    function p(e) {\n      return \"number\" === typeof e && !isNaN(e) && Infinity > e && -Infinity < e;\n    }\n\n    function f(e) {\n      return \"undefined\" !== typeof e && null !== e;\n    }\n\n    function c(e, g, b) {\n      var l;\n      t(g) ? f(b) ? e.setAttribute(g, b) : e && e.getAttribute && ((l = e.getAttribute(g)) || \"class\" !== g || (l = e.getAttribute(g + \"Name\"))) : I(g, function (b, g) {\n        f(b) ? e.setAttribute(g, b) : e.removeAttribute(g);\n      });\n      return l;\n    }\n\n    function a(e, g) {\n      var b;\n      e || (e = {});\n\n      for (b in g) e[b] = g[b];\n\n      return e;\n    }\n\n    function n() {\n      for (var e = arguments, g = e.length, b = 0; b < g; b++) {\n        var l = e[b];\n        if (\"undefined\" !== typeof l && null !== l) return l;\n      }\n    }\n\n    function m(e, g) {\n      d.isMS && !d.svg && g && \"undefined\" !== typeof g.opacity && (g.filter = \"alpha(opacity=\" + 100 * g.opacity + \")\");\n      a(e.style, g);\n    }\n\n    function D(e, g) {\n      return 1E14 < e ? e : parseFloat(e.toPrecision(g || 14));\n    }\n\n    function C(e, g, b) {\n      var l = d.getStyle || C;\n      if (\"width\" === g) return g = Math.min(e.offsetWidth, e.scrollWidth), b = e.getBoundingClientRect && e.getBoundingClientRect().width, b < g && b >= g - 1 && (g = Math.floor(b)), Math.max(0, g - (l(e, \"padding-left\", !0) || 0) - (l(e, \"padding-right\", !0) || 0));\n      if (\"height\" === g) return Math.max(0, Math.min(e.offsetHeight, e.scrollHeight) - (l(e, \"padding-top\", !0) || 0) - (l(e, \"padding-bottom\", !0) || 0));\n      u.getComputedStyle || h(27, !0);\n\n      if (e = u.getComputedStyle(e, void 0)) {\n        var k = e.getPropertyValue(g);\n        n(b, \"opacity\" !== g) && (k = F(k));\n      }\n\n      return k;\n    }\n\n    function I(e, g, b) {\n      for (var l in e) Object.hasOwnProperty.call(e, l) && g.call(b || e[l], e[l], l, e);\n    }\n\n    function L(e, g, b) {\n      function l(b, g) {\n        var l = e.removeEventListener || d.removeEventListenerPolyfill;\n        l && l.call(e, b, g, !1);\n      }\n\n      function k(b) {\n        var k;\n\n        if (e.nodeName) {\n          if (g) {\n            var P = {};\n            P[g] = !0;\n          } else P = b;\n\n          I(P, function (e, g) {\n            if (b[g]) for (k = b[g].length; k--;) l(g, b[g][k].fn);\n          });\n        }\n      }\n\n      var r = \"function\" === typeof e && e.prototype || e;\n\n      if (Object.hasOwnProperty.call(r, \"hcEvents\")) {\n        var x = r.hcEvents;\n        g ? (r = x[g] || [], b ? (x[g] = r.filter(function (e) {\n          return b !== e.fn;\n        }), l(g, b)) : (k(x), x[g] = [])) : (k(x), delete r.hcEvents);\n      }\n    }\n\n    function K(e, g, b, l) {\n      b = b || {};\n\n      if (z.createEvent && (e.dispatchEvent || e.fireEvent && e !== d)) {\n        var k = z.createEvent(\"Events\");\n        k.initEvent(g, !0, !0);\n        b = a(k, b);\n        e.dispatchEvent ? e.dispatchEvent(b) : e.fireEvent(g, b);\n      } else if (e.hcEvents) {\n        b.target || a(b, {\n          preventDefault: function () {\n            b.defaultPrevented = !0;\n          },\n          target: e,\n          type: g\n        });\n        k = [];\n\n        for (var r = e, B = !1; r.hcEvents;) Object.hasOwnProperty.call(r, \"hcEvents\") && r.hcEvents[g] && (k.length && (B = !0), k.unshift.apply(k, r.hcEvents[g])), r = Object.getPrototypeOf(r);\n\n        B && k.sort(function (b, e) {\n          return b.order - e.order;\n        });\n        k.forEach(function (g) {\n          !1 === g.fn.call(e, b) && b.preventDefault();\n        });\n      }\n\n      l && !b.defaultPrevented && l.call(e, b);\n    }\n\n    var v = d.charts,\n        z = d.doc,\n        u = d.win;\n    (h || (h = {})).messages = [];\n\n    Math.easeInOutSine = function (e) {\n      return -.5 * (Math.cos(Math.PI * e) - 1);\n    };\n\n    var k = Array.prototype.find ? function (e, g) {\n      return e.find(g);\n    } : function (e, g) {\n      var b,\n          l = e.length;\n\n      for (b = 0; b < l; b++) if (g(e[b], b)) return e[b];\n    };\n    I({\n      map: \"map\",\n      each: \"forEach\",\n      grep: \"filter\",\n      reduce: \"reduce\",\n      some: \"some\"\n    }, function (e, g) {\n      d[g] = function (b) {\n        var l;\n        h(32, !1, void 0, (l = {}, l[\"Highcharts.\" + g] = \"use Array.\" + e, l));\n        return Array.prototype[e].apply(b, [].slice.call(arguments, 1));\n      };\n    });\n\n    var w,\n        l = function () {\n      var e = Math.random().toString(36).substring(2, 9) + \"-\",\n          g = 0;\n      return function () {\n        return \"highcharts-\" + (w ? \"\" : e) + g++;\n      };\n    }();\n\n    u.jQuery && (u.jQuery.fn.highcharts = function () {\n      var e = [].slice.call(arguments);\n      if (this[0]) return e[0] ? (new d[t(e[0]) ? e.shift() : \"Chart\"](this[0], e[0], e[1]), this) : v[c(this[0], \"data-highcharts-chart\")];\n    });\n    k = {\n      addEvent: function (e, g, b, l) {\n        void 0 === l && (l = {});\n        var k = \"function\" === typeof e && e.prototype || e;\n        Object.hasOwnProperty.call(k, \"hcEvents\") || (k.hcEvents = {});\n        k = k.hcEvents;\n        d.Point && e instanceof d.Point && e.series && e.series.chart && (e.series.chart.runTrackerClick = !0);\n        var r = e.addEventListener || d.addEventListenerPolyfill;\n        r && r.call(e, g, b, d.supportsPassiveEvents ? {\n          passive: void 0 === l.passive ? -1 !== g.indexOf(\"touch\") : l.passive,\n          capture: !1\n        } : !1);\n        k[g] || (k[g] = []);\n        k[g].push({\n          fn: b,\n          order: \"number\" === typeof l.order ? l.order : Infinity\n        });\n        k[g].sort(function (b, e) {\n          return b.order - e.order;\n        });\n        return function () {\n          L(e, g, b);\n        };\n      },\n      arrayMax: function (e) {\n        for (var g = e.length, b = e[0]; g--;) e[g] > b && (b = e[g]);\n\n        return b;\n      },\n      arrayMin: function (e) {\n        for (var g = e.length, b = e[0]; g--;) e[g] < b && (b = e[g]);\n\n        return b;\n      },\n      attr: c,\n      clamp: function (e, g, b) {\n        return e > g ? e < b ? e : b : g;\n      },\n      cleanRecursively: A,\n      clearTimeout: function (e) {\n        f(e) && clearTimeout(e);\n      },\n      correctFloat: D,\n      createElement: function (e, g, b, l, k) {\n        e = z.createElement(e);\n        g && a(e, g);\n        k && m(e, {\n          padding: \"0\",\n          border: \"none\",\n          margin: \"0\"\n        });\n        b && m(e, b);\n        l && l.appendChild(e);\n        return e;\n      },\n      css: m,\n      defined: f,\n      destroyObjectProperties: function (e, g) {\n        I(e, function (b, l) {\n          b && b !== g && b.destroy && b.destroy();\n          delete e[l];\n        });\n      },\n      discardElement: function (e) {\n        e && e.parentElement && e.parentElement.removeChild(e);\n      },\n      erase: function (e, g) {\n        for (var b = e.length; b--;) if (e[b] === g) {\n          e.splice(b, 1);\n          break;\n        }\n      },\n      error: h,\n      extend: a,\n      extendClass: function (e, g) {\n        var b = function () {};\n\n        b.prototype = new e();\n        a(b.prototype, g);\n        return b;\n      },\n      find: k,\n      fireEvent: K,\n      getMagnitude: function (e) {\n        return Math.pow(10, Math.floor(Math.log(e) / Math.LN10));\n      },\n      getNestedProperty: function (e, g) {\n        for (e = e.split(\".\"); e.length && f(g);) {\n          var b = e.shift();\n          if (\"undefined\" === typeof b || \"__proto__\" === b) return;\n          g = g[b];\n          if (!f(g) || \"function\" === typeof g || \"number\" === typeof g.nodeType || g === u) return;\n        }\n\n        return g;\n      },\n      getStyle: C,\n      inArray: function (e, g, b) {\n        h(32, !1, void 0, {\n          \"Highcharts.inArray\": \"use Array.indexOf\"\n        });\n        return g.indexOf(e, b);\n      },\n      isArray: G,\n      isClass: q,\n      isDOMElement: y,\n      isFunction: function (e) {\n        return \"function\" === typeof e;\n      },\n      isNumber: p,\n      isObject: H,\n      isString: t,\n      keys: function (e) {\n        h(32, !1, void 0, {\n          \"Highcharts.keys\": \"use Object.keys\"\n        });\n        return Object.keys(e);\n      },\n      merge: function () {\n        var e,\n            g = arguments,\n            b = {},\n            l = function (b, e) {\n          \"object\" !== typeof b && (b = {});\n          I(e, function (g, k) {\n            \"__proto__\" !== k && \"constructor\" !== k && (!H(g, !0) || q(g) || y(g) ? b[k] = e[k] : b[k] = l(b[k] || {}, g));\n          });\n          return b;\n        };\n\n        !0 === g[0] && (b = g[1], g = Array.prototype.slice.call(g, 2));\n        var k = g.length;\n\n        for (e = 0; e < k; e++) b = l(b, g[e]);\n\n        return b;\n      },\n      normalizeTickInterval: function (e, g, b, l, k) {\n        var r = e;\n        b = n(b, 1);\n        var B = e / b;\n        g || (g = k ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === l && (1 === b ? g = g.filter(function (b) {\n          return 0 === b % 1;\n        }) : .1 >= b && (g = [1 / b])));\n\n        for (l = 0; l < g.length && !(r = g[l], k && r * b >= e || !k && B <= (g[l] + (g[l + 1] || g[l])) / 2); l++);\n\n        return r = D(r * b, -Math.round(Math.log(.001) / Math.LN10));\n      },\n      objectEach: I,\n      offset: function (e) {\n        var g = z.documentElement;\n        e = e.parentElement || e.parentNode ? e.getBoundingClientRect() : {\n          top: 0,\n          left: 0,\n          width: 0,\n          height: 0\n        };\n        return {\n          top: e.top + (u.pageYOffset || g.scrollTop) - (g.clientTop || 0),\n          left: e.left + (u.pageXOffset || g.scrollLeft) - (g.clientLeft || 0),\n          width: e.width,\n          height: e.height\n        };\n      },\n      pad: function (e, g, b) {\n        return Array((g || 2) + 1 - String(e).replace(\"-\", \"\").length).join(b || \"0\") + e;\n      },\n      pick: n,\n      pInt: F,\n      relativeLength: function (e, g, b) {\n        return /%$/.test(e) ? g * parseFloat(e) / 100 + (b || 0) : parseFloat(e);\n      },\n      removeEvent: L,\n      splat: function (e) {\n        return G(e) ? e : [e];\n      },\n      stableSort: function (e, g) {\n        var b = e.length,\n            l,\n            k;\n\n        for (k = 0; k < b; k++) e[k].safeI = k;\n\n        e.sort(function (b, e) {\n          l = g(b, e);\n          return 0 === l ? b.safeI - e.safeI : l;\n        });\n\n        for (k = 0; k < b; k++) delete e[k].safeI;\n      },\n      syncTimeout: function (e, g, b) {\n        if (0 < g) return setTimeout(e, g, b);\n        e.call(0, b);\n        return -1;\n      },\n      timeUnits: {\n        millisecond: 1,\n        second: 1E3,\n        minute: 6E4,\n        hour: 36E5,\n        day: 864E5,\n        week: 6048E5,\n        month: 24192E5,\n        year: 314496E5\n      },\n      uniqueKey: l,\n      useSerialIds: function (e) {\n        return w = n(e, w);\n      },\n      wrap: function (e, g, b) {\n        var l = e[g];\n\n        e[g] = function () {\n          var e = Array.prototype.slice.call(arguments),\n              g = arguments,\n              k = this;\n\n          k.proceed = function () {\n            l.apply(k, arguments.length ? arguments : g);\n          };\n\n          e.unshift(l);\n          e = b.apply(this, e);\n          k.proceed = null;\n          return e;\n        };\n      }\n    };\n    \"\";\n    return k;\n  });\n  N(h, \"Core/Chart/ChartDefaults.js\", [], function () {\n    return {\n      panning: {\n        enabled: !1,\n        type: \"x\"\n      },\n      styledMode: !1,\n      borderRadius: 0,\n      colorCount: 10,\n      defaultSeriesType: \"line\",\n      ignoreHiddenSeries: !0,\n      spacing: [10, 10, 15, 10],\n      resetZoomButton: {\n        theme: {\n          zIndex: 6\n        },\n        position: {\n          align: \"right\",\n          x: -10,\n          y: 10\n        }\n      },\n      zoomBySingleTouch: !1,\n      width: null,\n      height: null,\n      borderColor: \"#335cad\",\n      backgroundColor: \"#ffffff\",\n      plotBorderColor: \"#cccccc\"\n    };\n  });\n  N(h, \"Core/Color/Color.js\", [h[\"Core/Globals.js\"], h[\"Core/Utilities.js\"]], function (d, h) {\n    var E = h.isNumber,\n        F = h.merge,\n        t = h.pInt;\n\n    h = function () {\n      function h(E) {\n        this.rgba = [NaN, NaN, NaN, NaN];\n        this.input = E;\n        var y = d.Color;\n        if (y && y !== h) return new y(E);\n        if (!(this instanceof h)) return new h(E);\n        this.init(E);\n      }\n\n      h.parse = function (d) {\n        return d ? new h(d) : h.None;\n      };\n\n      h.prototype.init = function (d) {\n        var y;\n        if (\"object\" === typeof d && \"undefined\" !== typeof d.stops) this.stops = d.stops.map(function (c) {\n          return new h(c[1]);\n        });else if (\"string\" === typeof d) {\n          this.input = d = h.names[d.toLowerCase()] || d;\n\n          if (\"#\" === d.charAt(0)) {\n            var q = d.length;\n            var p = parseInt(d.substr(1), 16);\n            7 === q ? y = [(p & 16711680) >> 16, (p & 65280) >> 8, p & 255, 1] : 4 === q && (y = [(p & 3840) >> 4 | (p & 3840) >> 8, (p & 240) >> 4 | p & 240, (p & 15) << 4 | p & 15, 1]);\n          }\n\n          if (!y) for (p = h.parsers.length; p-- && !y;) {\n            var f = h.parsers[p];\n            (q = f.regex.exec(d)) && (y = f.parse(q));\n          }\n        }\n        y && (this.rgba = y);\n      };\n\n      h.prototype.get = function (d) {\n        var y = this.input,\n            q = this.rgba;\n\n        if (\"object\" === typeof y && \"undefined\" !== typeof this.stops) {\n          var p = F(y);\n          p.stops = [].slice.call(p.stops);\n          this.stops.forEach(function (f, c) {\n            p.stops[c] = [p.stops[c][0], f.get(d)];\n          });\n          return p;\n        }\n\n        return q && E(q[0]) ? \"rgb\" === d || !d && 1 === q[3] ? \"rgb(\" + q[0] + \",\" + q[1] + \",\" + q[2] + \")\" : \"a\" === d ? \"\" + q[3] : \"rgba(\" + q.join(\",\") + \")\" : y;\n      };\n\n      h.prototype.brighten = function (d) {\n        var y = this.rgba;\n        if (this.stops) this.stops.forEach(function (p) {\n          p.brighten(d);\n        });else if (E(d) && 0 !== d) for (var q = 0; 3 > q; q++) y[q] += t(255 * d), 0 > y[q] && (y[q] = 0), 255 < y[q] && (y[q] = 255);\n        return this;\n      };\n\n      h.prototype.setOpacity = function (d) {\n        this.rgba[3] = d;\n        return this;\n      };\n\n      h.prototype.tweenTo = function (d, y) {\n        var q = this.rgba,\n            p = d.rgba;\n        if (!E(q[0]) || !E(p[0])) return d.input || \"none\";\n        d = 1 !== p[3] || 1 !== q[3];\n        return (d ? \"rgba(\" : \"rgb(\") + Math.round(p[0] + (q[0] - p[0]) * (1 - y)) + \",\" + Math.round(p[1] + (q[1] - p[1]) * (1 - y)) + \",\" + Math.round(p[2] + (q[2] - p[2]) * (1 - y)) + (d ? \",\" + (p[3] + (q[3] - p[3]) * (1 - y)) : \"\") + \")\";\n      };\n\n      h.names = {\n        white: \"#ffffff\",\n        black: \"#000000\"\n      };\n      h.parsers = [{\n        regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n        parse: function (d) {\n          return [t(d[1]), t(d[2]), t(d[3]), parseFloat(d[4], 10)];\n        }\n      }, {\n        regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n        parse: function (d) {\n          return [t(d[1]), t(d[2]), t(d[3]), 1];\n        }\n      }];\n      h.None = new h(\"\");\n      return h;\n    }();\n\n    \"\";\n    return h;\n  });\n  N(h, \"Core/Color/Palettes.js\", [], function () {\n    return {\n      colors: \"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1\".split(\" \")\n    };\n  });\n  N(h, \"Core/Time.js\", [h[\"Core/Globals.js\"], h[\"Core/Utilities.js\"]], function (d, h) {\n    var E = d.win,\n        F = h.defined,\n        t = h.error,\n        G = h.extend,\n        H = h.isObject,\n        y = h.merge,\n        q = h.objectEach,\n        p = h.pad,\n        f = h.pick,\n        c = h.splat,\n        a = h.timeUnits,\n        n = d.isSafari && E.Intl && E.Intl.DateTimeFormat.prototype.formatRange,\n        m = d.isSafari && E.Intl && !E.Intl.DateTimeFormat.prototype.formatRange;\n\n    h = function () {\n      function D(a) {\n        this.options = {};\n        this.variableTimezone = this.useUTC = !1;\n        this.Date = E.Date;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        this.update(a);\n      }\n\n      D.prototype.get = function (a, c) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          var C = c.getTime(),\n              f = C - this.getTimezoneOffset(c);\n          c.setTime(f);\n          a = c[\"getUTC\" + a]();\n          c.setTime(C);\n          return a;\n        }\n\n        return this.useUTC ? c[\"getUTC\" + a]() : c[\"get\" + a]();\n      };\n\n      D.prototype.set = function (a, c, f) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          if (\"Milliseconds\" === a || \"Seconds\" === a || \"Minutes\" === a && 0 === this.getTimezoneOffset(c) % 36E5) return c[\"setUTC\" + a](f);\n          var C = this.getTimezoneOffset(c);\n          C = c.getTime() - C;\n          c.setTime(C);\n          c[\"setUTC\" + a](f);\n          a = this.getTimezoneOffset(c);\n          C = c.getTime() + a;\n          return c.setTime(C);\n        }\n\n        return this.useUTC || n && \"FullYear\" === a ? c[\"setUTC\" + a](f) : c[\"set\" + a](f);\n      };\n\n      D.prototype.update = function (a) {\n        var c = f(a && a.useUTC, !0);\n        this.options = a = y(!0, this.options || {}, a);\n        this.Date = a.Date || E.Date || Date;\n        this.timezoneOffset = (this.useUTC = c) && a.timezoneOffset;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        this.variableTimezone = c && !(!a.getTimezoneOffset && !a.timezone);\n      };\n\n      D.prototype.makeTime = function (a, c, n, D, v, z) {\n        if (this.useUTC) {\n          var u = this.Date.UTC.apply(0, arguments);\n          var k = this.getTimezoneOffset(u);\n          u += k;\n          var w = this.getTimezoneOffset(u);\n          k !== w ? u += w - k : k - 36E5 !== this.getTimezoneOffset(u - 36E5) || m || (u -= 36E5);\n        } else u = new this.Date(a, c, f(n, 1), f(D, 0), f(v, 0), f(z, 0)).getTime();\n\n        return u;\n      };\n\n      D.prototype.timezoneOffsetFunction = function () {\n        var a = this,\n            c = this.options,\n            f = c.getTimezoneOffset,\n            n = c.moment || E.moment;\n        if (!this.useUTC) return function (a) {\n          return 6E4 * new Date(a.toString()).getTimezoneOffset();\n        };\n\n        if (c.timezone) {\n          if (n) return function (a) {\n            return 6E4 * -n.tz(a, c.timezone).utcOffset();\n          };\n          t(25);\n        }\n\n        return this.useUTC && f ? function (a) {\n          return 6E4 * f(a.valueOf());\n        } : function () {\n          return 6E4 * (a.timezoneOffset || 0);\n        };\n      };\n\n      D.prototype.dateFormat = function (a, c, n) {\n        if (!F(c) || isNaN(c)) return d.defaultOptions.lang && d.defaultOptions.lang.invalidDate || \"\";\n        a = f(a, \"%Y-%m-%d %H:%M:%S\");\n        var C = this,\n            v = new this.Date(c),\n            z = this.get(\"Hours\", v),\n            u = this.get(\"Day\", v),\n            k = this.get(\"Date\", v),\n            w = this.get(\"Month\", v),\n            l = this.get(\"FullYear\", v),\n            e = d.defaultOptions.lang,\n            g = e && e.weekdays,\n            b = e && e.shortWeekdays;\n        v = G({\n          a: b ? b[u] : g[u].substr(0, 3),\n          A: g[u],\n          d: p(k),\n          e: p(k, 2, \" \"),\n          w: u,\n          b: e.shortMonths[w],\n          B: e.months[w],\n          m: p(w + 1),\n          o: w + 1,\n          y: l.toString().substr(2, 2),\n          Y: l,\n          H: p(z),\n          k: z,\n          I: p(z % 12 || 12),\n          l: z % 12 || 12,\n          M: p(this.get(\"Minutes\", v)),\n          p: 12 > z ? \"AM\" : \"PM\",\n          P: 12 > z ? \"am\" : \"pm\",\n          S: p(v.getSeconds()),\n          L: p(Math.floor(c % 1E3), 3)\n        }, d.dateFormats);\n        q(v, function (b, e) {\n          for (; -1 !== a.indexOf(\"%\" + e);) a = a.replace(\"%\" + e, \"function\" === typeof b ? b.call(C, c) : b);\n        });\n        return n ? a.substr(0, 1).toUpperCase() + a.substr(1) : a;\n      };\n\n      D.prototype.resolveDTLFormat = function (a) {\n        return H(a, !0) ? a : (a = c(a), {\n          main: a[0],\n          from: a[1],\n          to: a[2]\n        });\n      };\n\n      D.prototype.getTimeTicks = function (c, n, m, D) {\n        var v = this,\n            z = [],\n            u = {},\n            k = new v.Date(n),\n            w = c.unitRange,\n            l = c.count || 1,\n            e;\n        D = f(D, 1);\n\n        if (F(n)) {\n          v.set(\"Milliseconds\", k, w >= a.second ? 0 : l * Math.floor(v.get(\"Milliseconds\", k) / l));\n          w >= a.second && v.set(\"Seconds\", k, w >= a.minute ? 0 : l * Math.floor(v.get(\"Seconds\", k) / l));\n          w >= a.minute && v.set(\"Minutes\", k, w >= a.hour ? 0 : l * Math.floor(v.get(\"Minutes\", k) / l));\n          w >= a.hour && v.set(\"Hours\", k, w >= a.day ? 0 : l * Math.floor(v.get(\"Hours\", k) / l));\n          w >= a.day && v.set(\"Date\", k, w >= a.month ? 1 : Math.max(1, l * Math.floor(v.get(\"Date\", k) / l)));\n\n          if (w >= a.month) {\n            v.set(\"Month\", k, w >= a.year ? 0 : l * Math.floor(v.get(\"Month\", k) / l));\n            var g = v.get(\"FullYear\", k);\n          }\n\n          w >= a.year && v.set(\"FullYear\", k, g - g % l);\n          w === a.week && (g = v.get(\"Day\", k), v.set(\"Date\", k, v.get(\"Date\", k) - g + D + (g < D ? -7 : 0)));\n          g = v.get(\"FullYear\", k);\n          D = v.get(\"Month\", k);\n          var b = v.get(\"Date\", k),\n              B = v.get(\"Hours\", k);\n          n = k.getTime();\n          !v.variableTimezone && v.useUTC || !F(m) || (e = m - n > 4 * a.month || v.getTimezoneOffset(n) !== v.getTimezoneOffset(m));\n          n = k.getTime();\n\n          for (k = 1; n < m;) z.push(n), n = w === a.year ? v.makeTime(g + k * l, 0) : w === a.month ? v.makeTime(g, D + k * l) : !e || w !== a.day && w !== a.week ? e && w === a.hour && 1 < l ? v.makeTime(g, D, b, B + k * l) : n + w * l : v.makeTime(g, D, b + k * l * (w === a.day ? 1 : 7)), k++;\n\n          z.push(n);\n          w <= a.hour && 1E4 > z.length && z.forEach(function (b) {\n            0 === b % 18E5 && \"000000000\" === v.dateFormat(\"%H%M%S%L\", b) && (u[b] = \"day\");\n          });\n        }\n\n        z.info = G(c, {\n          higherRanks: u,\n          totalRange: w * l\n        });\n        return z;\n      };\n\n      D.prototype.getDateFormat = function (c, n, f, m) {\n        var v = this.dateFormat(\"%m-%d %H:%M:%S.%L\", n),\n            z = {\n          millisecond: 15,\n          second: 12,\n          minute: 9,\n          hour: 6,\n          day: 3\n        },\n            u = \"millisecond\";\n\n        for (k in a) {\n          if (c === a.week && +this.dateFormat(\"%w\", n) === f && \"00:00:00.000\" === v.substr(6)) {\n            var k = \"week\";\n            break;\n          }\n\n          if (a[k] > c) {\n            k = u;\n            break;\n          }\n\n          if (z[k] && v.substr(z[k]) !== \"01-01 00:00:00.000\".substr(z[k])) break;\n          \"week\" !== k && (u = k);\n        }\n\n        if (k) var w = this.resolveDTLFormat(m[k]).main;\n        return w;\n      };\n\n      return D;\n    }();\n\n    \"\";\n    return h;\n  });\n  N(h, \"Core/DefaultOptions.js\", [h[\"Core/Chart/ChartDefaults.js\"], h[\"Core/Color/Color.js\"], h[\"Core/Globals.js\"], h[\"Core/Color/Palettes.js\"], h[\"Core/Time.js\"], h[\"Core/Utilities.js\"]], function (d, h, A, F, t, G) {\n    h = h.parse;\n    var E = G.merge,\n        y = {\n      colors: F.colors,\n      symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"],\n      lang: {\n        loading: \"Loading...\",\n        months: \"January February March April May June July August September October November December\".split(\" \"),\n        shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\n        weekdays: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n        decimalPoint: \".\",\n        numericSymbols: \"kMGTPE\".split(\"\"),\n        resetZoom: \"Reset zoom\",\n        resetZoomTitle: \"Reset zoom level 1:1\",\n        thousandsSep: \" \"\n      },\n      global: {},\n      time: {\n        Date: void 0,\n        getTimezoneOffset: void 0,\n        timezone: void 0,\n        timezoneOffset: 0,\n        useUTC: !0\n      },\n      chart: d,\n      title: {\n        text: \"Chart title\",\n        align: \"center\",\n        margin: 15,\n        widthAdjust: -44\n      },\n      subtitle: {\n        text: \"\",\n        align: \"center\",\n        widthAdjust: -44\n      },\n      caption: {\n        margin: 15,\n        text: \"\",\n        align: \"left\",\n        verticalAlign: \"bottom\"\n      },\n      plotOptions: {},\n      labels: {\n        style: {\n          position: \"absolute\",\n          color: \"#333333\"\n        }\n      },\n      legend: {\n        enabled: !0,\n        align: \"center\",\n        alignColumns: !0,\n        className: \"highcharts-no-tooltip\",\n        layout: \"horizontal\",\n        labelFormatter: function () {\n          return this.name;\n        },\n        borderColor: \"#999999\",\n        borderRadius: 0,\n        navigation: {\n          activeColor: \"#003399\",\n          inactiveColor: \"#cccccc\"\n        },\n        itemStyle: {\n          color: \"#333333\",\n          cursor: \"pointer\",\n          fontSize: \"12px\",\n          fontWeight: \"bold\",\n          textOverflow: \"ellipsis\"\n        },\n        itemHoverStyle: {\n          color: \"#000000\"\n        },\n        itemHiddenStyle: {\n          color: \"#cccccc\"\n        },\n        shadow: !1,\n        itemCheckboxStyle: {\n          position: \"absolute\",\n          width: \"13px\",\n          height: \"13px\"\n        },\n        squareSymbol: !0,\n        symbolPadding: 5,\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0,\n        title: {\n          style: {\n            fontWeight: \"bold\"\n          }\n        }\n      },\n      loading: {\n        labelStyle: {\n          fontWeight: \"bold\",\n          position: \"relative\",\n          top: \"45%\"\n        },\n        style: {\n          position: \"absolute\",\n          backgroundColor: \"#ffffff\",\n          opacity: .5,\n          textAlign: \"center\"\n        }\n      },\n      tooltip: {\n        enabled: !0,\n        animation: A.svg,\n        borderRadius: 3,\n        dateTimeLabelFormats: {\n          millisecond: \"%A, %b %e, %H:%M:%S.%L\",\n          second: \"%A, %b %e, %H:%M:%S\",\n          minute: \"%A, %b %e, %H:%M\",\n          hour: \"%A, %b %e, %H:%M\",\n          day: \"%A, %b %e, %Y\",\n          week: \"Week from %A, %b %e, %Y\",\n          month: \"%B %Y\",\n          year: \"%Y\"\n        },\n        footerFormat: \"\",\n        headerShape: \"callout\",\n        hideDelay: 500,\n        padding: 8,\n        shape: \"callout\",\n        shared: !1,\n        snap: A.isTouchDevice ? 25 : 10,\n        headerFormat: '<span style=\"font-size: 10px\">{point.key}</span><br/>',\n        pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> {series.name}: <b>{point.y}</b><br/>',\n        backgroundColor: h(\"#f7f7f7\").setOpacity(.85).get(),\n        borderWidth: 1,\n        shadow: !0,\n        stickOnContact: !1,\n        style: {\n          color: \"#333333\",\n          cursor: \"default\",\n          fontSize: \"12px\",\n          whiteSpace: \"nowrap\"\n        },\n        useHTML: !1\n      },\n      credits: {\n        enabled: !0,\n        href: \"https://www.highcharts.com?credits\",\n        position: {\n          align: \"right\",\n          x: -10,\n          verticalAlign: \"bottom\",\n          y: -5\n        },\n        style: {\n          cursor: \"pointer\",\n          color: \"#999999\",\n          fontSize: \"9px\"\n        },\n        text: \"Highcharts.com\"\n      }\n    };\n    y.chart.styledMode = !1;\n    \"\";\n    var q = new t(E(y.global, y.time));\n    d = {\n      defaultOptions: y,\n      defaultTime: q,\n      getOptions: function () {\n        return y;\n      },\n      setOptions: function (p) {\n        E(!0, y, p);\n        if (p.time || p.global) A.time ? A.time.update(E(y.global, y.time, p.global, p.time)) : A.time = q;\n        return y;\n      }\n    };\n    \"\";\n    return d;\n  });\n  N(h, \"Core/Animation/Fx.js\", [h[\"Core/Color/Color.js\"], h[\"Core/Globals.js\"], h[\"Core/Utilities.js\"]], function (d, h, A) {\n    var E = d.parse,\n        t = h.win,\n        G = A.isNumber,\n        H = A.objectEach;\n    return function () {\n      function d(q, p, f) {\n        this.pos = NaN;\n        this.options = p;\n        this.elem = q;\n        this.prop = f;\n      }\n\n      d.prototype.dSetter = function () {\n        var q = this.paths,\n            p = q && q[0];\n        q = q && q[1];\n        var f = this.now || 0,\n            c = [];\n        if (1 !== f && p && q) {\n          if (p.length === q.length && 1 > f) for (var a = 0; a < q.length; a++) {\n            for (var n = p[a], m = q[a], D = [], C = 0; C < m.length; C++) {\n              var I = n[C],\n                  L = m[C];\n              G(I) && G(L) && (\"A\" !== m[0] || 4 !== C && 5 !== C) ? D[C] = I + f * (L - I) : D[C] = L;\n            }\n\n            c.push(D);\n          } else c = q;\n        } else c = this.toD || [];\n        this.elem.attr(\"d\", c, void 0, !0);\n      };\n\n      d.prototype.update = function () {\n        var q = this.elem,\n            p = this.prop,\n            f = this.now,\n            c = this.options.step;\n        if (this[p + \"Setter\"]) this[p + \"Setter\"]();else q.attr ? q.element && q.attr(p, f, null, !0) : q.style[p] = f + this.unit;\n        c && c.call(q, f, this);\n      };\n\n      d.prototype.run = function (q, p, f) {\n        var c = this,\n            a = c.options,\n            n = function (a) {\n          return n.stopped ? !1 : c.step(a);\n        },\n            m = t.requestAnimationFrame || function (a) {\n          setTimeout(a, 13);\n        },\n            D = function () {\n          for (var a = 0; a < d.timers.length; a++) d.timers[a]() || d.timers.splice(a--, 1);\n\n          d.timers.length && m(D);\n        };\n\n        q !== p || this.elem[\"forceAnimate:\" + this.prop] ? (this.startTime = +new Date(), this.start = q, this.end = p, this.unit = f, this.now = this.start, this.pos = 0, n.elem = this.elem, n.prop = this.prop, n() && 1 === d.timers.push(n) && m(D)) : (delete a.curAnim[this.prop], a.complete && 0 === Object.keys(a.curAnim).length && a.complete.call(this.elem));\n      };\n\n      d.prototype.step = function (q) {\n        var p = +new Date(),\n            f = this.options,\n            c = this.elem,\n            a = f.complete,\n            n = f.duration,\n            m = f.curAnim;\n        if (c.attr && !c.element) q = !1;else if (q || p >= n + this.startTime) {\n          this.now = this.end;\n          this.pos = 1;\n          this.update();\n          var D = m[this.prop] = !0;\n          H(m, function (a) {\n            !0 !== a && (D = !1);\n          });\n          D && a && a.call(c);\n          q = !1;\n        } else this.pos = f.easing((p - this.startTime) / n), this.now = this.start + (this.end - this.start) * this.pos, this.update(), q = !0;\n        return q;\n      };\n\n      d.prototype.initPath = function (q, p, f) {\n        function c(a, c) {\n          for (; a.length < K;) {\n            var u = a[0],\n                k = c[K - a.length];\n            k && \"M\" === u[0] && (a[0] = \"C\" === k[0] ? [\"C\", u[1], u[2], u[1], u[2], u[1], u[2]] : [\"L\", u[1], u[2]]);\n            a.unshift(u);\n            D && (u = a.pop(), a.push(a[a.length - 1], u));\n          }\n        }\n\n        function a(a, c) {\n          for (; a.length < K;) if (c = a[Math.floor(a.length / C) - 1].slice(), \"C\" === c[0] && (c[1] = c[5], c[2] = c[6]), D) {\n            var u = a[Math.floor(a.length / C)].slice();\n            a.splice(a.length / 2, 0, c, u);\n          } else a.push(c);\n        }\n\n        var n = q.startX,\n            m = q.endX;\n        f = f.slice();\n        var D = q.isArea,\n            C = D ? 2 : 1;\n        p = p && p.slice();\n        if (!p) return [f, f];\n\n        if (n && m && m.length) {\n          for (q = 0; q < n.length; q++) if (n[q] === m[0]) {\n            var I = q;\n            break;\n          } else if (n[0] === m[m.length - n.length + q]) {\n            I = q;\n            var L = !0;\n            break;\n          } else if (n[n.length - 1] === m[m.length - n.length + q]) {\n            I = n.length - q;\n            break;\n          }\n\n          \"undefined\" === typeof I && (p = []);\n        }\n\n        if (p.length && G(I)) {\n          var K = f.length + I * C;\n          L ? (c(p, f), a(f, p)) : (c(f, p), a(p, f));\n        }\n\n        return [p, f];\n      };\n\n      d.prototype.fillSetter = function () {\n        d.prototype.strokeSetter.apply(this, arguments);\n      };\n\n      d.prototype.strokeSetter = function () {\n        this.elem.attr(this.prop, E(this.start).tweenTo(E(this.end), this.pos), void 0, !0);\n      };\n\n      d.timers = [];\n      return d;\n    }();\n  });\n  N(h, \"Core/Animation/AnimationUtilities.js\", [h[\"Core/Animation/Fx.js\"], h[\"Core/Utilities.js\"]], function (d, h) {\n    function E(a) {\n      return q(a) ? p({\n        duration: 500,\n        defer: 0\n      }, a) : {\n        duration: a ? 500 : 0,\n        defer: 0\n      };\n    }\n\n    function F(a, c) {\n      for (var n = d.timers.length; n--;) d.timers[n].elem !== a || c && c !== d.timers[n].prop || (d.timers[n].stopped = !0);\n    }\n\n    var t = h.defined,\n        G = h.getStyle,\n        H = h.isArray,\n        y = h.isNumber,\n        q = h.isObject,\n        p = h.merge,\n        f = h.objectEach,\n        c = h.pick;\n    return {\n      animate: function (a, c, m) {\n        var n,\n            C = \"\",\n            I,\n            L;\n\n        if (!q(m)) {\n          var K = arguments;\n          m = {\n            duration: K[2],\n            easing: K[3],\n            complete: K[4]\n          };\n        }\n\n        y(m.duration) || (m.duration = 400);\n        m.easing = \"function\" === typeof m.easing ? m.easing : Math[m.easing] || Math.easeInOutSine;\n        m.curAnim = p(c);\n        f(c, function (f, z) {\n          F(a, z);\n          L = new d(a, m, z);\n          I = void 0;\n          \"d\" === z && H(c.d) ? (L.paths = L.initPath(a, a.pathArray, c.d), L.toD = c.d, n = 0, I = 1) : a.attr ? n = a.attr(z) : (n = parseFloat(G(a, z)) || 0, \"opacity\" !== z && (C = \"px\"));\n          I || (I = f);\n          \"string\" === typeof I && I.match(\"px\") && (I = I.replace(/px/g, \"\"));\n          L.run(n, I, C);\n        });\n      },\n      animObject: E,\n      getDeferredAnimation: function (a, c, f) {\n        var n = E(c),\n            m = 0,\n            p = 0;\n        (f ? [f] : a.series).forEach(function (a) {\n          a = E(a.options.animation);\n          m = c && t(c.defer) ? n.defer : Math.max(m, a.duration + a.defer);\n          p = Math.min(n.duration, a.duration);\n        });\n        a.renderer.forExport && (m = 0);\n        return {\n          defer: Math.max(0, m - p),\n          duration: Math.min(m, p)\n        };\n      },\n      setAnimation: function (a, n) {\n        n.renderer.globalAnimation = c(a, n.options.chart.animation, !0);\n      },\n      stop: F\n    };\n  });\n  N(h, \"Core/Renderer/HTML/AST.js\", [h[\"Core/Globals.js\"], h[\"Core/Utilities.js\"]], function (d, h) {\n    var E = d.SVG_NS,\n        F = h.attr,\n        t = h.createElement,\n        G = h.error,\n        H = h.isFunction,\n        y = h.isString,\n        q = h.objectEach,\n        p = h.splat,\n        f = (h = d.win.trustedTypes) && H(h.createPolicy) && h.createPolicy(\"highcharts\", {\n      createHTML: function (a) {\n        return a;\n      }\n    }),\n        c = f ? f.createHTML(\"\") : \"\";\n\n    try {\n      var a = !!new DOMParser().parseFromString(c, \"text/html\");\n    } catch (n) {\n      a = !1;\n    }\n\n    H = function () {\n      function n(a) {\n        this.nodes = \"string\" === typeof a ? this.parseMarkup(a) : a;\n      }\n\n      n.filterUserAttributes = function (a) {\n        q(a, function (c, f) {\n          var m = !0;\n          -1 === n.allowedAttributes.indexOf(f) && (m = !1);\n          -1 !== [\"background\", \"dynsrc\", \"href\", \"lowsrc\", \"src\"].indexOf(f) && (m = y(c) && n.allowedReferences.some(function (a) {\n            return 0 === c.indexOf(a);\n          }));\n          m || (G(\"Highcharts warning: Invalid attribute '\" + f + \"' in config\"), delete a[f]);\n        });\n        return a;\n      };\n\n      n.setElementHTML = function (a, c) {\n        a.innerHTML = n.emptyHTML;\n        c && new n(c).addToDOM(a);\n      };\n\n      n.prototype.addToDOM = function (a) {\n        function c(a, f) {\n          var m;\n          p(a).forEach(function (a) {\n            var v = a.tagName,\n                z = a.textContent ? d.doc.createTextNode(a.textContent) : void 0;\n            if (v) if (\"#text\" === v) var u = z;else if (-1 !== n.allowedTags.indexOf(v)) {\n              v = d.doc.createElementNS(\"svg\" === v ? E : f.namespaceURI || E, v);\n              var k = a.attributes || {};\n              q(a, function (a, l) {\n                \"tagName\" !== l && \"attributes\" !== l && \"children\" !== l && \"textContent\" !== l && (k[l] = a);\n              });\n              F(v, n.filterUserAttributes(k));\n              z && v.appendChild(z);\n              c(a.children || [], v);\n              u = v;\n            } else G(\"Highcharts warning: Invalid tagName \" + v + \" in config\");\n            u && f.appendChild(u);\n            m = u;\n          });\n          return m;\n        }\n\n        return c(this.nodes, a);\n      };\n\n      n.prototype.parseMarkup = function (c) {\n        var n = [];\n        c = c.trim();\n        if (a) c = new DOMParser().parseFromString(f ? f.createHTML(c) : c, \"text/html\");else {\n          var m = t(\"div\");\n          m.innerHTML = c;\n          c = {\n            body: m\n          };\n        }\n\n        var p = function (a, c) {\n          var f = a.nodeName.toLowerCase(),\n              z = {\n            tagName: f\n          };\n          \"#text\" === f && (z.textContent = a.textContent || \"\");\n\n          if (f = a.attributes) {\n            var u = {};\n            [].forEach.call(f, function (k) {\n              u[k.name] = k.value;\n            });\n            z.attributes = u;\n          }\n\n          if (a.childNodes.length) {\n            var k = [];\n            [].forEach.call(a.childNodes, function (a) {\n              p(a, k);\n            });\n            k.length && (z.children = k);\n          }\n\n          c.push(z);\n        };\n\n        [].forEach.call(c.body.childNodes, function (a) {\n          return p(a, n);\n        });\n        return n;\n      };\n\n      n.allowedAttributes = \"aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align textAnchor textLength title type valign width x x1 x2 y y1 y2 zIndex\".split(\" \");\n      n.allowedReferences = \"https:// http:// mailto: / ../ ./ #\".split(\" \");\n      n.allowedTags = \"a abbr b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text thead tbody tspan td th tr u ul #text\".split(\" \");\n      n.emptyHTML = c;\n      return n;\n    }();\n\n    \"\";\n    return H;\n  });\n  N(h, \"Core/FormatUtilities.js\", [h[\"Core/DefaultOptions.js\"], h[\"Core/Utilities.js\"]], function (d, h) {\n    function E(p, f, c, a) {\n      p = +p || 0;\n      f = +f;\n      var n = F.lang,\n          m = (p.toString().split(\".\")[1] || \"\").split(\"e\")[0].length,\n          D = p.toString().split(\"e\"),\n          C = f;\n      if (-1 === f) f = Math.min(m, 20);else if (!H(f)) f = 2;else if (f && D[1] && 0 > D[1]) {\n        var I = f + +D[1];\n        0 <= I ? (D[0] = (+D[0]).toExponential(I).split(\"e\")[0], f = I) : (D[0] = D[0].split(\".\")[0] || 0, p = 20 > f ? (D[0] * Math.pow(10, D[1])).toFixed(f) : 0, D[1] = 0);\n      }\n      I = (Math.abs(D[1] ? D[0] : p) + Math.pow(10, -Math.max(f, m) - 1)).toFixed(f);\n      m = String(q(I));\n      var L = 3 < m.length ? m.length % 3 : 0;\n      c = y(c, n.decimalPoint);\n      a = y(a, n.thousandsSep);\n      p = (0 > p ? \"-\" : \"\") + (L ? m.substr(0, L) + a : \"\");\n      p = 0 > +D[1] && !C ? \"0\" : p + m.substr(L).replace(/(\\d{3})(?=\\d)/g, \"$1\" + a);\n      f && (p += c + I.slice(-f));\n      D[1] && 0 !== +p && (p += \"e\" + D[1]);\n      return p;\n    }\n\n    var F = d.defaultOptions,\n        t = d.defaultTime,\n        G = h.getNestedProperty,\n        H = h.isNumber,\n        y = h.pick,\n        q = h.pInt;\n    return {\n      dateFormat: function (p, f, c) {\n        return t.dateFormat(p, f, c);\n      },\n      format: function (p, f, c) {\n        var a = \"{\",\n            n = !1,\n            m = /f$/,\n            D = /\\.([0-9])/,\n            C = F.lang,\n            I = c && c.time || t;\n        c = c && c.numberFormatter || E;\n\n        for (var L = []; p;) {\n          var q = p.indexOf(a);\n          if (-1 === q) break;\n          var v = p.slice(0, q);\n\n          if (n) {\n            v = v.split(\":\");\n            a = G(v.shift() || \"\", f);\n            if (v.length && \"number\" === typeof a) if (v = v.join(\":\"), m.test(v)) {\n              var z = parseInt((v.match(D) || [\"\", \"-1\"])[1], 10);\n              null !== a && (a = c(a, z, C.decimalPoint, -1 < v.indexOf(\",\") ? C.thousandsSep : \"\"));\n            } else a = I.dateFormat(v, a);\n            L.push(a);\n          } else L.push(v);\n\n          p = p.slice(q + 1);\n          a = (n = !n) ? \"}\" : \"{\";\n        }\n\n        L.push(p);\n        return L.join(\"\");\n      },\n      numberFormat: E\n    };\n  });\n  N(h, \"Core/Renderer/RendererUtilities.js\", [h[\"Core/Utilities.js\"]], function (d) {\n    var h = d.clamp,\n        A = d.pick,\n        F = d.stableSort,\n        t;\n\n    (function (d) {\n      function t(d, q, p) {\n        var f = d,\n            c = f.reducedLen || q,\n            a = function (a, c) {\n          return (c.rank || 0) - (a.rank || 0);\n        },\n            n = function (a, c) {\n          return a.target - c.target;\n        },\n            m,\n            D = !0,\n            C = [],\n            I = 0;\n\n        for (m = d.length; m--;) I += d[m].size;\n\n        if (I > c) {\n          F(d, a);\n\n          for (I = m = 0; I <= c;) I += d[m].size, m++;\n\n          C = d.splice(m - 1, d.length);\n        }\n\n        F(d, n);\n\n        for (d = d.map(function (a) {\n          return {\n            size: a.size,\n            targets: [a.target],\n            align: A(a.align, .5)\n          };\n        }); D;) {\n          for (m = d.length; m--;) c = d[m], a = (Math.min.apply(0, c.targets) + Math.max.apply(0, c.targets)) / 2, c.pos = h(a - c.size * c.align, 0, q - c.size);\n\n          m = d.length;\n\n          for (D = !1; m--;) 0 < m && d[m - 1].pos + d[m - 1].size > d[m].pos && (d[m - 1].size += d[m].size, d[m - 1].targets = d[m - 1].targets.concat(d[m].targets), d[m - 1].align = .5, d[m - 1].pos + d[m - 1].size > q && (d[m - 1].pos = q - d[m - 1].size), d.splice(m, 1), D = !0);\n        }\n\n        f.push.apply(f, C);\n        m = 0;\n        d.some(function (a) {\n          var c = 0;\n          return (a.targets || []).some(function () {\n            f[m].pos = a.pos + c;\n            if (\"undefined\" !== typeof p && Math.abs(f[m].pos - f[m].target) > p) return f.slice(0, m + 1).forEach(function (a) {\n              return delete a.pos;\n            }), f.reducedLen = (f.reducedLen || q) - .1 * q, f.reducedLen > .1 * q && t(f, q, p), !0;\n            c += f[m].size;\n            m++;\n            return !1;\n          });\n        });\n        F(f, n);\n        return f;\n      }\n\n      d.distribute = t;\n    })(t || (t = {}));\n\n    return t;\n  });\n  N(h, \"Core/Renderer/SVG/SVGElement.js\", [h[\"Core/Animation/AnimationUtilities.js\"], h[\"Core/Renderer/HTML/AST.js\"], h[\"Core/Color/Color.js\"], h[\"Core/Globals.js\"], h[\"Core/Utilities.js\"]], function (d, h, A, F, t) {\n    var E = d.animate,\n        H = d.animObject,\n        y = d.stop,\n        q = F.deg2rad,\n        p = F.doc,\n        f = F.noop,\n        c = F.svg,\n        a = F.SVG_NS,\n        n = F.win,\n        m = t.addEvent,\n        D = t.attr,\n        C = t.createElement,\n        I = t.css,\n        L = t.defined,\n        K = t.erase,\n        v = t.extend,\n        z = t.fireEvent,\n        u = t.isArray,\n        k = t.isFunction,\n        w = t.isNumber,\n        l = t.isString,\n        e = t.merge,\n        g = t.objectEach,\n        b = t.pick,\n        B = t.pInt,\n        J = t.syncTimeout,\n        r = t.uniqueKey;\n\n    d = function () {\n      function x() {\n        this.element = void 0;\n        this.onEvents = {};\n        this.opacity = 1;\n        this.renderer = void 0;\n        this.SVG_NS = a;\n        this.symbolCustomAttribs = \"x y width height r start end innerR anchorX anchorY rounded\".split(\" \");\n      }\n\n      x.prototype._defaultGetter = function (e) {\n        e = b(this[e + \"Value\"], this[e], this.element ? this.element.getAttribute(e) : null, 0);\n        /^[\\-0-9\\.]+$/.test(e) && (e = parseFloat(e));\n        return e;\n      };\n\n      x.prototype._defaultSetter = function (b, e, g) {\n        g.setAttribute(e, b);\n      };\n\n      x.prototype.add = function (b) {\n        var e = this.renderer,\n            g = this.element;\n        b && (this.parentGroup = b);\n        this.parentInverted = b && b.inverted;\n        \"undefined\" !== typeof this.textStr && \"text\" === this.element.nodeName && e.buildText(this);\n        this.added = !0;\n        if (!b || b.handleZ || this.zIndex) var l = this.zIndexSetter();\n        l || (b ? b.element : e.box).appendChild(g);\n        if (this.onAdd) this.onAdd();\n        return this;\n      };\n\n      x.prototype.addClass = function (b, e) {\n        var g = e ? \"\" : this.attr(\"class\") || \"\";\n        b = (b || \"\").split(/ /g).reduce(function (b, e) {\n          -1 === g.indexOf(e) && b.push(e);\n          return b;\n        }, g ? [g] : []).join(\" \");\n        b !== g && this.attr(\"class\", b);\n        return this;\n      };\n\n      x.prototype.afterSetters = function () {\n        this.doTransform && (this.updateTransform(), this.doTransform = !1);\n      };\n\n      x.prototype.align = function (e, g, k) {\n        var r = {},\n            P = this.renderer,\n            a = P.alignedObjects,\n            M,\n            c,\n            B;\n\n        if (e) {\n          if (this.alignOptions = e, this.alignByTranslate = g, !k || l(k)) this.alignTo = M = k || \"renderer\", K(a, this), a.push(this), k = void 0;\n        } else e = this.alignOptions, g = this.alignByTranslate, M = this.alignTo;\n\n        k = b(k, P[M], \"scrollablePlotBox\" === M ? P.plotBox : void 0, P);\n        M = e.align;\n        var x = e.verticalAlign;\n        P = (k.x || 0) + (e.x || 0);\n        a = (k.y || 0) + (e.y || 0);\n        \"right\" === M ? c = 1 : \"center\" === M && (c = 2);\n        c && (P += (k.width - (e.width || 0)) / c);\n        r[g ? \"translateX\" : \"x\"] = Math.round(P);\n        \"bottom\" === x ? B = 1 : \"middle\" === x && (B = 2);\n        B && (a += (k.height - (e.height || 0)) / B);\n        r[g ? \"translateY\" : \"y\"] = Math.round(a);\n        this[this.placed ? \"animate\" : \"attr\"](r);\n        this.placed = !0;\n        this.alignAttr = r;\n        return this;\n      };\n\n      x.prototype.alignSetter = function (b) {\n        var e = {\n          left: \"start\",\n          center: \"middle\",\n          right: \"end\"\n        };\n        e[b] && (this.alignValue = b, this.element.setAttribute(\"text-anchor\", e[b]));\n      };\n\n      x.prototype.animate = function (e, k, l) {\n        var r = this,\n            a = H(b(k, this.renderer.globalAnimation, !0));\n        k = a.defer;\n        b(p.hidden, p.msHidden, p.webkitHidden, !1) && (a.duration = 0);\n        0 !== a.duration ? (l && (a.complete = l), J(function () {\n          r.element && E(r, e, a);\n        }, k)) : (this.attr(e, void 0, l), g(e, function (b, e) {\n          a.step && a.step.call(this, b, {\n            prop: e,\n            pos: 1,\n            elem: this\n          });\n        }, this));\n        return this;\n      };\n\n      x.prototype.applyTextOutline = function (b) {\n        var e = this.element;\n        -1 !== b.indexOf(\"contrast\") && (b = b.replace(/contrast/g, this.renderer.getContrast(e.style.fill)));\n        var g = b.split(\" \");\n        b = g[g.length - 1];\n\n        if ((g = g[0]) && \"none\" !== g && F.svg) {\n          this.fakeTS = !0;\n          this.ySetter = this.xSetter;\n          g = g.replace(/(^[\\d\\.]+)(.*?)$/g, function (b, e, g) {\n            return 2 * Number(e) + g;\n          });\n          this.removeTextOutline();\n          var k = p.createElementNS(a, \"tspan\");\n          D(k, {\n            \"class\": \"highcharts-text-outline\",\n            fill: b,\n            stroke: b,\n            \"stroke-width\": g,\n            \"stroke-linejoin\": \"round\"\n          });\n          [].forEach.call(e.childNodes, function (b) {\n            var e = b.cloneNode(!0);\n            e.removeAttribute && [\"fill\", \"stroke\", \"stroke-width\", \"stroke\"].forEach(function (b) {\n              return e.removeAttribute(b);\n            });\n            k.appendChild(e);\n          });\n          var l = p.createElementNS(a, \"tspan\");\n          l.textContent = \"\\u200b\";\n          [\"x\", \"y\"].forEach(function (b) {\n            var g = e.getAttribute(b);\n            g && l.setAttribute(b, g);\n          });\n          k.appendChild(l);\n          e.insertBefore(k, e.firstChild);\n        }\n      };\n\n      x.prototype.attr = function (b, e, k, l) {\n        var a = this.element,\n            r = this.symbolCustomAttribs,\n            P,\n            O = this,\n            M,\n            c;\n\n        if (\"string\" === typeof b && \"undefined\" !== typeof e) {\n          var B = b;\n          b = {};\n          b[B] = e;\n        }\n\n        \"string\" === typeof b ? O = (this[b + \"Getter\"] || this._defaultGetter).call(this, b, a) : (g(b, function (e, g) {\n          M = !1;\n          l || y(this, g);\n          this.symbolName && -1 !== r.indexOf(g) && (P || (this.symbolAttr(b), P = !0), M = !0);\n          !this.rotation || \"x\" !== g && \"y\" !== g || (this.doTransform = !0);\n          M || (c = this[g + \"Setter\"] || this._defaultSetter, c.call(this, e, g, a), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(g) && this.updateShadows(g, e, c));\n        }, this), this.afterSetters());\n        k && k.call(this);\n        return O;\n      };\n\n      x.prototype.clip = function (b) {\n        return this.attr(\"clip-path\", b ? \"url(\" + this.renderer.url + \"#\" + b.id + \")\" : \"none\");\n      };\n\n      x.prototype.crisp = function (b, e) {\n        e = e || b.strokeWidth || 0;\n        var g = Math.round(e) % 2 / 2;\n        b.x = Math.floor(b.x || this.x || 0) + g;\n        b.y = Math.floor(b.y || this.y || 0) + g;\n        b.width = Math.floor((b.width || this.width || 0) - 2 * g);\n        b.height = Math.floor((b.height || this.height || 0) - 2 * g);\n        L(b.strokeWidth) && (b.strokeWidth = e);\n        return b;\n      };\n\n      x.prototype.complexColor = function (b, k, l) {\n        var a = this.renderer,\n            P,\n            c,\n            B,\n            x,\n            w,\n            M,\n            J,\n            f,\n            n,\n            m,\n            v = [],\n            C;\n        z(this.renderer, \"complexColor\", {\n          args: arguments\n        }, function () {\n          b.radialGradient ? c = \"radialGradient\" : b.linearGradient && (c = \"linearGradient\");\n\n          if (c) {\n            B = b[c];\n            w = a.gradients;\n            M = b.stops;\n            n = l.radialReference;\n            u(B) && (b[c] = B = {\n              x1: B[0],\n              y1: B[1],\n              x2: B[2],\n              y2: B[3],\n              gradientUnits: \"userSpaceOnUse\"\n            });\n            \"radialGradient\" === c && n && !L(B.gradientUnits) && (x = B, B = e(B, a.getRadialAttr(n, x), {\n              gradientUnits: \"userSpaceOnUse\"\n            }));\n            g(B, function (b, e) {\n              \"id\" !== e && v.push(e, b);\n            });\n            g(M, function (b) {\n              v.push(b);\n            });\n            v = v.join(\",\");\n            if (w[v]) m = w[v].attr(\"id\");else {\n              B.id = m = r();\n              var O = w[v] = a.createElement(c).attr(B).add(a.defs);\n              O.radAttr = x;\n              O.stops = [];\n              M.forEach(function (b) {\n                0 === b[1].indexOf(\"rgba\") ? (P = A.parse(b[1]), J = P.get(\"rgb\"), f = P.get(\"a\")) : (J = b[1], f = 1);\n                b = a.createElement(\"stop\").attr({\n                  offset: b[0],\n                  \"stop-color\": J,\n                  \"stop-opacity\": f\n                }).add(O);\n                O.stops.push(b);\n              });\n            }\n            C = \"url(\" + a.url + \"#\" + m + \")\";\n            l.setAttribute(k, C);\n            l.gradient = v;\n\n            b.toString = function () {\n              return C;\n            };\n          }\n        });\n      };\n\n      x.prototype.css = function (b) {\n        var e = this.styles,\n            k = {},\n            l = this.element,\n            a = [\"textOutline\", \"textOverflow\", \"width\"],\n            r = \"\",\n            x = !e;\n        b && b.color && (b.fill = b.color);\n        e && g(b, function (b, g) {\n          e && e[g] !== b && (k[g] = b, x = !0);\n        });\n\n        if (x) {\n          e && (b = v(e, k));\n          if (b) if (null === b.width || \"auto\" === b.width) delete this.textWidth;else if (\"text\" === l.nodeName.toLowerCase() && b.width) var w = this.textWidth = B(b.width);\n          this.styles = b;\n          w && !c && this.renderer.forExport && delete b.width;\n\n          if (l.namespaceURI === this.SVG_NS) {\n            var u = function (b, e) {\n              return \"-\" + e.toLowerCase();\n            };\n\n            g(b, function (b, e) {\n              -1 === a.indexOf(e) && (r += e.replace(/([A-Z])/g, u) + \":\" + b + \";\");\n            });\n            r && D(l, \"style\", r);\n          } else I(l, b);\n\n          this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), b && b.textOutline && this.applyTextOutline(b.textOutline));\n        }\n\n        return this;\n      };\n\n      x.prototype.dashstyleSetter = function (e) {\n        var g = this[\"stroke-width\"];\n        \"inherit\" === g && (g = 1);\n\n        if (e = e && e.toLowerCase()) {\n          var k = e.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n\n          for (e = k.length; e--;) k[e] = \"\" + B(k[e]) * b(g, NaN);\n\n          e = k.join(\",\").replace(/NaN/g, \"none\");\n          this.element.setAttribute(\"stroke-dasharray\", e);\n        }\n      };\n\n      x.prototype.destroy = function () {\n        var b = this,\n            e = b.element || {},\n            k = b.renderer,\n            l = e.ownerSVGElement,\n            a = k.isSVG && \"SPAN\" === e.nodeName && b.parentGroup || void 0;\n        e.onclick = e.onmouseout = e.onmouseover = e.onmousemove = e.point = null;\n        y(b);\n\n        if (b.clipPath && l) {\n          var r = b.clipPath;\n          [].forEach.call(l.querySelectorAll(\"[clip-path],[CLIP-PATH]\"), function (b) {\n            -1 < b.getAttribute(\"clip-path\").indexOf(r.element.id) && b.removeAttribute(\"clip-path\");\n          });\n          b.clipPath = r.destroy();\n        }\n\n        if (b.stops) {\n          for (l = 0; l < b.stops.length; l++) b.stops[l].destroy();\n\n          b.stops.length = 0;\n          b.stops = void 0;\n        }\n\n        b.safeRemoveChild(e);\n\n        for (k.styledMode || b.destroyShadows(); a && a.div && 0 === a.div.childNodes.length;) e = a.parentGroup, b.safeRemoveChild(a.div), delete a.div, a = e;\n\n        b.alignTo && K(k.alignedObjects, b);\n        g(b, function (e, g) {\n          b[g] && b[g].parentGroup === b && b[g].destroy && b[g].destroy();\n          delete b[g];\n        });\n      };\n\n      x.prototype.destroyShadows = function () {\n        (this.shadows || []).forEach(function (b) {\n          this.safeRemoveChild(b);\n        }, this);\n        this.shadows = void 0;\n      };\n\n      x.prototype.destroyTextPath = function (b, e) {\n        var g = b.getElementsByTagName(\"text\")[0];\n\n        if (g) {\n          if (g.removeAttribute(\"dx\"), g.removeAttribute(\"dy\"), e.element.setAttribute(\"id\", \"\"), this.textPathWrapper && g.getElementsByTagName(\"textPath\").length) {\n            for (b = this.textPathWrapper.element.childNodes; b.length;) g.appendChild(b[0]);\n\n            g.removeChild(this.textPathWrapper.element);\n          }\n        } else if (b.getAttribute(\"dx\") || b.getAttribute(\"dy\")) b.removeAttribute(\"dx\"), b.removeAttribute(\"dy\");\n\n        this.textPathWrapper && (this.textPathWrapper = this.textPathWrapper.destroy());\n      };\n\n      x.prototype.dSetter = function (b, e, g) {\n        u(b) && (\"string\" === typeof b[0] && (b = this.renderer.pathToSegments(b)), this.pathArray = b, b = b.reduce(function (b, e, g) {\n          return e && e.join ? (g ? b + \" \" : \"\") + e.join(\" \") : (e || \"\").toString();\n        }, \"\"));\n        /(NaN| {2}|^$)/.test(b) && (b = \"M 0 0\");\n        this[e] !== b && (g.setAttribute(e, b), this[e] = b);\n      };\n\n      x.prototype.fadeOut = function (e) {\n        var g = this;\n        g.animate({\n          opacity: 0\n        }, {\n          duration: b(e, 150),\n          complete: function () {\n            g.attr({\n              y: -9999\n            }).hide();\n          }\n        });\n      };\n\n      x.prototype.fillSetter = function (b, e, g) {\n        \"string\" === typeof b ? g.setAttribute(e, b) : b && this.complexColor(b, e, g);\n      };\n\n      x.prototype.getBBox = function (e, g) {\n        var l = this.renderer,\n            a = this.element,\n            r = this.styles,\n            B = this.textStr,\n            c = l.cache,\n            w = l.cacheKeys,\n            u = a.namespaceURI === this.SVG_NS;\n        g = b(g, this.rotation, 0);\n        var J = l.styledMode ? a && x.prototype.getStyle.call(a, \"font-size\") : r && r.fontSize,\n            z;\n\n        if (L(B)) {\n          var M = B.toString();\n          -1 === M.indexOf(\"<\") && (M = M.replace(/[0-9]/g, \"0\"));\n          M += [\"\", g, J, this.textWidth, r && r.textOverflow, r && r.fontWeight].join();\n        }\n\n        M && !e && (z = c[M]);\n\n        if (!z) {\n          if (u || l.forExport) {\n            try {\n              var f = this.fakeTS && function (b) {\n                var e = a.querySelector(\".highcharts-text-outline\");\n                e && I(e, {\n                  display: b\n                });\n              };\n\n              k(f) && f(\"none\");\n              z = a.getBBox ? v({}, a.getBBox()) : {\n                width: a.offsetWidth,\n                height: a.offsetHeight\n              };\n              k(f) && f(\"\");\n            } catch (U) {\n              \"\";\n            }\n\n            if (!z || 0 > z.width) z = {\n              width: 0,\n              height: 0\n            };\n          } else z = this.htmlGetBBox();\n\n          l.isSVG && (e = z.width, l = z.height, u && (z.height = l = {\n            \"11px,17\": 14,\n            \"13px,20\": 16\n          }[(J || \"\") + \",\" + Math.round(l)] || l), g && (u = g * q, z.width = Math.abs(l * Math.sin(u)) + Math.abs(e * Math.cos(u)), z.height = Math.abs(l * Math.cos(u)) + Math.abs(e * Math.sin(u))));\n\n          if (M && (\"\" === B || 0 < z.height)) {\n            for (; 250 < w.length;) delete c[w.shift()];\n\n            c[M] || w.push(M);\n            c[M] = z;\n          }\n        }\n\n        return z;\n      };\n\n      x.prototype.getStyle = function (b) {\n        return n.getComputedStyle(this.element || this, \"\").getPropertyValue(b);\n      };\n\n      x.prototype.hasClass = function (b) {\n        return -1 !== (\"\" + this.attr(\"class\")).split(\" \").indexOf(b);\n      };\n\n      x.prototype.hide = function (b) {\n        b ? this.attr({\n          y: -9999\n        }) : this.attr({\n          visibility: \"hidden\"\n        });\n        return this;\n      };\n\n      x.prototype.htmlGetBBox = function () {\n        return {\n          height: 0,\n          width: 0,\n          x: 0,\n          y: 0\n        };\n      };\n\n      x.prototype.init = function (b, e) {\n        this.element = \"span\" === e ? C(e) : p.createElementNS(this.SVG_NS, e);\n        this.renderer = b;\n        z(this, \"afterInit\");\n      };\n\n      x.prototype.invert = function (b) {\n        this.inverted = b;\n        this.updateTransform();\n        return this;\n      };\n\n      x.prototype.on = function (b, e) {\n        var g = this.onEvents;\n        if (g[b]) g[b]();\n        g[b] = m(this.element, b, e);\n        return this;\n      };\n\n      x.prototype.opacitySetter = function (b, e, g) {\n        this.opacity = b = Number(Number(b).toFixed(3));\n        g.setAttribute(e, b);\n      };\n\n      x.prototype.removeClass = function (b) {\n        return this.attr(\"class\", (\"\" + this.attr(\"class\")).replace(l(b) ? new RegExp(\"(^| )\" + b + \"( |$)\") : b, \" \").replace(/ +/g, \" \").trim());\n      };\n\n      x.prototype.removeTextOutline = function () {\n        var b = this.element.querySelector(\"tspan.highcharts-text-outline\");\n        b && this.safeRemoveChild(b);\n      };\n\n      x.prototype.safeRemoveChild = function (b) {\n        var e = b.parentNode;\n        e && e.removeChild(b);\n      };\n\n      x.prototype.setRadialReference = function (b) {\n        var e = this.element.gradient && this.renderer.gradients[this.element.gradient];\n        this.element.radialReference = b;\n        e && e.radAttr && e.animate(this.renderer.getRadialAttr(b, e.radAttr));\n        return this;\n      };\n\n      x.prototype.setTextPath = function (b, l) {\n        var k = this.element,\n            a = this.text ? this.text.element : k,\n            B = {\n          textAnchor: \"text-anchor\"\n        },\n            c = !1,\n            x = this.textPathWrapper,\n            u = !x;\n        l = e(!0, {\n          enabled: !0,\n          attributes: {\n            dy: -5,\n            startOffset: \"50%\",\n            textAnchor: \"middle\"\n          }\n        }, l);\n        var Q = h.filterUserAttributes(l.attributes);\n\n        if (b && l && l.enabled) {\n          x && null === x.element.parentNode ? (u = !0, x = x.destroy()) : x && this.removeTextOutline.call(x.parentGroup);\n          this.options && this.options.padding && (Q.dx = -this.options.padding);\n          x || (this.textPathWrapper = x = this.renderer.createElement(\"textPath\"), c = !0);\n          var J = x.element;\n          (l = b.element.getAttribute(\"id\")) || b.element.setAttribute(\"id\", l = r());\n          if (u) for (a.setAttribute(\"y\", 0), w(Q.dx) && a.setAttribute(\"x\", -Q.dx), b = [].slice.call(a.childNodes), u = 0; u < b.length; u++) {\n            var z = b[u];\n            z.nodeType !== n.Node.TEXT_NODE && \"tspan\" !== z.nodeName || J.appendChild(z);\n          }\n          c && x && x.add({\n            element: a\n          });\n          J.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", this.renderer.url + \"#\" + l);\n          L(Q.dy) && (J.parentNode.setAttribute(\"dy\", Q.dy), delete Q.dy);\n          L(Q.dx) && (J.parentNode.setAttribute(\"dx\", Q.dx), delete Q.dx);\n          g(Q, function (b, e) {\n            J.setAttribute(B[e] || e, b);\n          });\n          k.removeAttribute(\"transform\");\n          this.removeTextOutline.call(x);\n          this.text && !this.renderer.styledMode && this.attr({\n            fill: \"none\",\n            \"stroke-width\": 0\n          });\n          this.applyTextOutline = this.updateTransform = f;\n        } else x && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(k, b), this.updateTransform(), this.options && this.options.rotation && this.applyTextOutline(this.options.style.textOutline));\n\n        return this;\n      };\n\n      x.prototype.shadow = function (b, e, l) {\n        var k = [],\n            a = this.element,\n            r = this.oldShadowOptions,\n            P = {\n          color: \"#000000\",\n          offsetX: this.parentInverted ? -1 : 1,\n          offsetY: this.parentInverted ? -1 : 1,\n          opacity: .15,\n          width: 3\n        },\n            B = !1,\n            c;\n        !0 === b ? c = P : \"object\" === typeof b && (c = v(P, b));\n        c && (c && r && g(c, function (b, e) {\n          b !== r[e] && (B = !0);\n        }), B && this.destroyShadows(), this.oldShadowOptions = c);\n        if (!c) this.destroyShadows();else if (!this.shadows) {\n          var x = c.opacity / c.width;\n          var w = this.parentInverted ? \"translate(\" + c.offsetY + \", \" + c.offsetX + \")\" : \"translate(\" + c.offsetX + \", \" + c.offsetY + \")\";\n\n          for (P = 1; P <= c.width; P++) {\n            var u = a.cloneNode(!1);\n            var J = 2 * c.width + 1 - 2 * P;\n            D(u, {\n              stroke: b.color || \"#000000\",\n              \"stroke-opacity\": x * P,\n              \"stroke-width\": J,\n              transform: w,\n              fill: \"none\"\n            });\n            u.setAttribute(\"class\", (u.getAttribute(\"class\") || \"\") + \" highcharts-shadow\");\n            l && (D(u, \"height\", Math.max(D(u, \"height\") - J, 0)), u.cutHeight = J);\n            e ? e.element.appendChild(u) : a.parentNode && a.parentNode.insertBefore(u, a);\n            k.push(u);\n          }\n\n          this.shadows = k;\n        }\n        return this;\n      };\n\n      x.prototype.show = function (b) {\n        return this.attr({\n          visibility: b ? \"inherit\" : \"visible\"\n        });\n      };\n\n      x.prototype.strokeSetter = function (b, e, g) {\n        this[e] = b;\n        this.stroke && this[\"stroke-width\"] ? (x.prototype.fillSetter.call(this, this.stroke, \"stroke\", g), g.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0) : \"stroke-width\" === e && 0 === b && this.hasStroke ? (g.removeAttribute(\"stroke\"), this.hasStroke = !1) : this.renderer.styledMode && this[\"stroke-width\"] && (g.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0);\n      };\n\n      x.prototype.strokeWidth = function () {\n        if (!this.renderer.styledMode) return this[\"stroke-width\"] || 0;\n        var b = this.getStyle(\"stroke-width\"),\n            e = 0;\n        if (b.indexOf(\"px\") === b.length - 2) e = B(b);else if (\"\" !== b) {\n          var g = p.createElementNS(a, \"rect\");\n          D(g, {\n            width: b,\n            \"stroke-width\": 0\n          });\n          this.element.parentNode.appendChild(g);\n          e = g.getBBox().width;\n          g.parentNode.removeChild(g);\n        }\n        return e;\n      };\n\n      x.prototype.symbolAttr = function (e) {\n        var g = this;\n        \"x y r start end width height innerR anchorX anchorY clockwise\".split(\" \").forEach(function (l) {\n          g[l] = b(e[l], g[l]);\n        });\n        g.attr({\n          d: g.renderer.symbols[g.symbolName](g.x, g.y, g.width, g.height, g)\n        });\n      };\n\n      x.prototype.textSetter = function (b) {\n        b !== this.textStr && (delete this.textPxLength, this.textStr = b, this.added && this.renderer.buildText(this));\n      };\n\n      x.prototype.titleSetter = function (e) {\n        var g = this.element,\n            l = g.getElementsByTagName(\"title\")[0] || p.createElementNS(this.SVG_NS, \"title\");\n        g.insertBefore ? g.insertBefore(l, g.firstChild) : g.appendChild(l);\n        l.textContent = String(b(e, \"\")).replace(/<[^>]*>/g, \"\").replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\");\n      };\n\n      x.prototype.toFront = function () {\n        var b = this.element;\n        b.parentNode.appendChild(b);\n        return this;\n      };\n\n      x.prototype.translate = function (b, e) {\n        return this.attr({\n          translateX: b,\n          translateY: e\n        });\n      };\n\n      x.prototype.updateShadows = function (b, e, g) {\n        var l = this.shadows;\n        if (l) for (var k = l.length; k--;) g.call(l[k], \"height\" === b ? Math.max(e - (l[k].cutHeight || 0), 0) : \"d\" === b ? this.d : e, b, l[k]);\n      };\n\n      x.prototype.updateTransform = function () {\n        var e = this.scaleX,\n            g = this.scaleY,\n            l = this.inverted,\n            k = this.rotation,\n            a = this.matrix,\n            r = this.element,\n            c = this.translateX || 0,\n            B = this.translateY || 0;\n        l && (c += this.width, B += this.height);\n        c = [\"translate(\" + c + \",\" + B + \")\"];\n        L(a) && c.push(\"matrix(\" + a.join(\",\") + \")\");\n        l ? c.push(\"rotate(90) scale(-1,1)\") : k && c.push(\"rotate(\" + k + \" \" + b(this.rotationOriginX, r.getAttribute(\"x\"), 0) + \" \" + b(this.rotationOriginY, r.getAttribute(\"y\") || 0) + \")\");\n        (L(e) || L(g)) && c.push(\"scale(\" + b(e, 1) + \" \" + b(g, 1) + \")\");\n        c.length && r.setAttribute(\"transform\", c.join(\" \"));\n      };\n\n      x.prototype.visibilitySetter = function (b, e, g) {\n        \"inherit\" === b ? g.removeAttribute(e) : this[e] !== b && g.setAttribute(e, b);\n        this[e] = b;\n      };\n\n      x.prototype.xGetter = function (b) {\n        \"circle\" === this.element.nodeName && (\"x\" === b ? b = \"cx\" : \"y\" === b && (b = \"cy\"));\n        return this._defaultGetter(b);\n      };\n\n      x.prototype.zIndexSetter = function (b, e) {\n        var g = this.renderer,\n            l = this.parentGroup,\n            k = (l || g).element || g.box,\n            a = this.element;\n        g = k === g.box;\n        var r = !1;\n        var c = this.added;\n        var x;\n        L(b) ? (a.setAttribute(\"data-z-index\", b), b = +b, this[e] === b && (c = !1)) : L(this[e]) && a.removeAttribute(\"data-z-index\");\n        this[e] = b;\n\n        if (c) {\n          (b = this.zIndex) && l && (l.handleZ = !0);\n          e = k.childNodes;\n\n          for (x = e.length - 1; 0 <= x && !r; x--) {\n            l = e[x];\n            c = l.getAttribute(\"data-z-index\");\n            var u = !L(c);\n            if (l !== a) if (0 > b && u && !g && !x) k.insertBefore(a, e[x]), r = !0;else if (B(c) <= b || u && (!L(b) || 0 <= b)) k.insertBefore(a, e[x + 1] || null), r = !0;\n          }\n\n          r || (k.insertBefore(a, e[g ? 3 : 0] || null), r = !0);\n        }\n\n        return r;\n      };\n\n      return x;\n    }();\n\n    d.prototype[\"stroke-widthSetter\"] = d.prototype.strokeSetter;\n    d.prototype.yGetter = d.prototype.xGetter;\n\n    d.prototype.matrixSetter = d.prototype.rotationOriginXSetter = d.prototype.rotationOriginYSetter = d.prototype.rotationSetter = d.prototype.scaleXSetter = d.prototype.scaleYSetter = d.prototype.translateXSetter = d.prototype.translateYSetter = d.prototype.verticalAlignSetter = function (b, e) {\n      this[e] = b;\n      this.doTransform = !0;\n    };\n\n    \"\";\n    return d;\n  });\n  N(h, \"Core/Renderer/RendererRegistry.js\", [h[\"Core/Globals.js\"]], function (d) {\n    var h;\n\n    (function (h) {\n      h.rendererTypes = {};\n      var E;\n\n      h.getRendererType = function (d) {\n        void 0 === d && (d = E);\n        return h.rendererTypes[d] || h.rendererTypes[E];\n      };\n\n      h.registerRendererType = function (t, A, H) {\n        h.rendererTypes[t] = A;\n        if (!E || H) E = t, d.Renderer = A;\n      };\n    })(h || (h = {}));\n\n    return h;\n  });\n  N(h, \"Core/Renderer/SVG/SVGLabel.js\", [h[\"Core/Renderer/SVG/SVGElement.js\"], h[\"Core/Utilities.js\"]], function (d, h) {\n    var E = this && this.__extends || function () {\n      var p = function (f, c) {\n        p = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, c) {\n          a.__proto__ = c;\n        } || function (a, c) {\n          for (var f in c) c.hasOwnProperty(f) && (a[f] = c[f]);\n        };\n\n        return p(f, c);\n      };\n\n      return function (f, c) {\n        function a() {\n          this.constructor = f;\n        }\n\n        p(f, c);\n        f.prototype = null === c ? Object.create(c) : (a.prototype = c.prototype, new a());\n      };\n    }(),\n        F = h.defined,\n        t = h.extend,\n        G = h.isNumber,\n        H = h.merge,\n        y = h.pick,\n        q = h.removeEvent;\n\n    return function (p) {\n      function f(c, a, n, m, D, C, I, L, d, v) {\n        var z = p.call(this) || this;\n        z.paddingLeftSetter = z.paddingSetter;\n        z.paddingRightSetter = z.paddingSetter;\n        z.init(c, \"g\");\n        z.textStr = a;\n        z.x = n;\n        z.y = m;\n        z.anchorX = C;\n        z.anchorY = I;\n        z.baseline = d;\n        z.className = v;\n        z.addClass(\"button\" === v ? \"highcharts-no-tooltip\" : \"highcharts-label\");\n        v && z.addClass(\"highcharts-\" + v);\n        z.text = c.text(void 0, 0, 0, L).attr({\n          zIndex: 1\n        });\n        var u;\n        \"string\" === typeof D && ((u = /^url\\((.*?)\\)$/.test(D)) || z.renderer.symbols[D]) && (z.symbolKey = D);\n        z.bBox = f.emptyBBox;\n        z.padding = 3;\n        z.baselineOffset = 0;\n        z.needsBox = c.styledMode || u;\n        z.deferredAttr = {};\n        z.alignFactor = 0;\n        return z;\n      }\n\n      E(f, p);\n\n      f.prototype.alignSetter = function (c) {\n        c = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[c];\n        c !== this.alignFactor && (this.alignFactor = c, this.bBox && G(this.xSetting) && this.attr({\n          x: this.xSetting\n        }));\n      };\n\n      f.prototype.anchorXSetter = function (c, a) {\n        this.anchorX = c;\n        this.boxAttr(a, Math.round(c) - this.getCrispAdjust() - this.xSetting);\n      };\n\n      f.prototype.anchorYSetter = function (c, a) {\n        this.anchorY = c;\n        this.boxAttr(a, c - this.ySetting);\n      };\n\n      f.prototype.boxAttr = function (c, a) {\n        this.box ? this.box.attr(c, a) : this.deferredAttr[c] = a;\n      };\n\n      f.prototype.css = function (c) {\n        if (c) {\n          var a = {};\n          c = H(c);\n          f.textProps.forEach(function (f) {\n            \"undefined\" !== typeof c[f] && (a[f] = c[f], delete c[f]);\n          });\n          this.text.css(a);\n          var n = (\"width\" in a);\n          \"fontSize\" in a || \"fontWeight\" in a ? this.updateTextPadding() : n && this.updateBoxSize();\n        }\n\n        return d.prototype.css.call(this, c);\n      };\n\n      f.prototype.destroy = function () {\n        q(this.element, \"mouseenter\");\n        q(this.element, \"mouseleave\");\n        this.text && this.text.destroy();\n        this.box && (this.box = this.box.destroy());\n        d.prototype.destroy.call(this);\n      };\n\n      f.prototype.fillSetter = function (c, a) {\n        c && (this.needsBox = !0);\n        this.fill = c;\n        this.boxAttr(a, c);\n      };\n\n      f.prototype.getBBox = function () {\n        this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();\n        var c = this.padding,\n            a = y(this.paddingLeft, c);\n        return {\n          width: this.width,\n          height: this.height,\n          x: this.bBox.x - a,\n          y: this.bBox.y - c\n        };\n      };\n\n      f.prototype.getCrispAdjust = function () {\n        return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this[\"stroke-width\"] ? parseInt(this[\"stroke-width\"], 10) : 0) % 2 / 2;\n      };\n\n      f.prototype.heightSetter = function (c) {\n        this.heightSetting = c;\n      };\n\n      f.prototype.onAdd = function () {\n        var c = this.textStr;\n        this.text.add(this);\n        this.attr({\n          text: F(c) ? c : \"\",\n          x: this.x,\n          y: this.y\n        });\n        this.box && F(this.anchorX) && this.attr({\n          anchorX: this.anchorX,\n          anchorY: this.anchorY\n        });\n      };\n\n      f.prototype.paddingSetter = function (c, a) {\n        G(c) ? c !== this[a] && (this[a] = c, this.updateTextPadding()) : this[a] = void 0;\n      };\n\n      f.prototype.rSetter = function (c, a) {\n        this.boxAttr(a, c);\n      };\n\n      f.prototype.shadow = function (c) {\n        c && !this.renderer.styledMode && (this.updateBoxSize(), this.box && this.box.shadow(c));\n        return this;\n      };\n\n      f.prototype.strokeSetter = function (c, a) {\n        this.stroke = c;\n        this.boxAttr(a, c);\n      };\n\n      f.prototype[\"stroke-widthSetter\"] = function (c, a) {\n        c && (this.needsBox = !0);\n        this[\"stroke-width\"] = c;\n        this.boxAttr(a, c);\n      };\n\n      f.prototype[\"text-alignSetter\"] = function (c) {\n        this.textAlign = c;\n      };\n\n      f.prototype.textSetter = function (c) {\n        \"undefined\" !== typeof c && this.text.attr({\n          text: c\n        });\n        this.updateTextPadding();\n      };\n\n      f.prototype.updateBoxSize = function () {\n        var c = this.text.element.style,\n            a = {},\n            n = this.padding,\n            m = this.bBox = G(this.widthSetting) && G(this.heightSetting) && !this.textAlign || !F(this.text.textStr) ? f.emptyBBox : this.text.getBBox();\n        this.width = this.getPaddedWidth();\n        this.height = (this.heightSetting || m.height || 0) + 2 * n;\n        c = this.renderer.fontMetrics(c && c.fontSize, this.text);\n        this.baselineOffset = n + Math.min((this.text.firstLineMetrics || c).b, m.height || Infinity);\n        this.heightSetting && (this.baselineOffset += (this.heightSetting - c.h) / 2);\n        this.needsBox && (this.box || (n = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), n.addClass((\"button\" === this.className ? \"\" : \"highcharts-label-box\") + (this.className ? \" highcharts-\" + this.className + \"-box\" : \"\")), n.add(this)), n = this.getCrispAdjust(), a.x = n, a.y = (this.baseline ? -this.baselineOffset : 0) + n, a.width = Math.round(this.width), a.height = Math.round(this.height), this.box.attr(t(a, this.deferredAttr)), this.deferredAttr = {});\n      };\n\n      f.prototype.updateTextPadding = function () {\n        var c = this.text;\n        this.updateBoxSize();\n        var a = this.baseline ? 0 : this.baselineOffset,\n            f = y(this.paddingLeft, this.padding);\n        F(this.widthSetting) && this.bBox && (\"center\" === this.textAlign || \"right\" === this.textAlign) && (f += {\n          center: .5,\n          right: 1\n        }[this.textAlign] * (this.widthSetting - this.bBox.width));\n        if (f !== c.x || a !== c.y) c.attr(\"x\", f), c.hasBoxWidthChanged && (this.bBox = c.getBBox(!0)), \"undefined\" !== typeof a && c.attr(\"y\", a);\n        c.x = f;\n        c.y = a;\n      };\n\n      f.prototype.widthSetter = function (c) {\n        this.widthSetting = G(c) ? c : void 0;\n      };\n\n      f.prototype.getPaddedWidth = function () {\n        var c = this.padding,\n            a = y(this.paddingLeft, c);\n        c = y(this.paddingRight, c);\n        return (this.widthSetting || this.bBox.width || 0) + a + c;\n      };\n\n      f.prototype.xSetter = function (c) {\n        this.x = c;\n        this.alignFactor && (c -= this.alignFactor * this.getPaddedWidth(), this[\"forceAnimate:x\"] = !0);\n        this.xSetting = Math.round(c);\n        this.attr(\"translateX\", this.xSetting);\n      };\n\n      f.prototype.ySetter = function (c) {\n        this.ySetting = this.y = Math.round(c);\n        this.attr(\"translateY\", this.ySetting);\n      };\n\n      f.emptyBBox = {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0\n      };\n      f.textProps = \"color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow width\".split(\" \");\n      return f;\n    }(d);\n  });\n  N(h, \"Core/Renderer/SVG/Symbols.js\", [h[\"Core/Utilities.js\"]], function (d) {\n    function h(d, q, p, f, c) {\n      var a = [];\n\n      if (c) {\n        var n = c.start || 0,\n            m = H(c.r, p);\n        p = H(c.r, f || p);\n        var D = (c.end || 0) - .001;\n        f = c.innerR;\n        var C = H(c.open, .001 > Math.abs((c.end || 0) - n - 2 * Math.PI)),\n            I = Math.cos(n),\n            L = Math.sin(n),\n            h = Math.cos(D),\n            v = Math.sin(D);\n        n = H(c.longArc, .001 > D - n - Math.PI ? 0 : 1);\n        a.push([\"M\", d + m * I, q + p * L], [\"A\", m, p, 0, n, H(c.clockwise, 1), d + m * h, q + p * v]);\n        t(f) && a.push(C ? [\"M\", d + f * h, q + f * v] : [\"L\", d + f * h, q + f * v], [\"A\", f, f, 0, n, t(c.clockwise) ? 1 - c.clockwise : 0, d + f * I, q + f * L]);\n        C || a.push([\"Z\"]);\n      }\n\n      return a;\n    }\n\n    function A(d, q, p, f, c) {\n      return c && c.r ? F(d, q, p, f, c) : [[\"M\", d, q], [\"L\", d + p, q], [\"L\", d + p, q + f], [\"L\", d, q + f], [\"Z\"]];\n    }\n\n    function F(d, q, p, f, c) {\n      c = c && c.r || 0;\n      return [[\"M\", d + c, q], [\"L\", d + p - c, q], [\"C\", d + p, q, d + p, q, d + p, q + c], [\"L\", d + p, q + f - c], [\"C\", d + p, q + f, d + p, q + f, d + p - c, q + f], [\"L\", d + c, q + f], [\"C\", d, q + f, d, q + f, d, q + f - c], [\"L\", d, q + c], [\"C\", d, q, d, q, d + c, q]];\n    }\n\n    var t = d.defined,\n        G = d.isNumber,\n        H = d.pick;\n    return {\n      arc: h,\n      callout: function (d, q, p, f, c) {\n        var a = Math.min(c && c.r || 0, p, f),\n            n = a + 6,\n            m = c && c.anchorX;\n        c = c && c.anchorY || 0;\n        var D = F(d, q, p, f, {\n          r: a\n        });\n        if (!G(m)) return D;\n        d + m >= p ? c > q + n && c < q + f - n ? D.splice(3, 1, [\"L\", d + p, c - 6], [\"L\", d + p + 6, c], [\"L\", d + p, c + 6], [\"L\", d + p, q + f - a]) : D.splice(3, 1, [\"L\", d + p, f / 2], [\"L\", m, c], [\"L\", d + p, f / 2], [\"L\", d + p, q + f - a]) : 0 >= d + m ? c > q + n && c < q + f - n ? D.splice(7, 1, [\"L\", d, c + 6], [\"L\", d - 6, c], [\"L\", d, c - 6], [\"L\", d, q + a]) : D.splice(7, 1, [\"L\", d, f / 2], [\"L\", m, c], [\"L\", d, f / 2], [\"L\", d, q + a]) : c && c > f && m > d + n && m < d + p - n ? D.splice(5, 1, [\"L\", m + 6, q + f], [\"L\", m, q + f + 6], [\"L\", m - 6, q + f], [\"L\", d + a, q + f]) : c && 0 > c && m > d + n && m < d + p - n && D.splice(1, 1, [\"L\", m - 6, q], [\"L\", m, q - 6], [\"L\", m + 6, q], [\"L\", p - a, q]);\n        return D;\n      },\n      circle: function (d, q, p, f) {\n        return h(d + p / 2, q + f / 2, p / 2, f / 2, {\n          start: .5 * Math.PI,\n          end: 2.5 * Math.PI,\n          open: !1\n        });\n      },\n      diamond: function (d, q, p, f) {\n        return [[\"M\", d + p / 2, q], [\"L\", d + p, q + f / 2], [\"L\", d + p / 2, q + f], [\"L\", d, q + f / 2], [\"Z\"]];\n      },\n      rect: A,\n      roundedRect: F,\n      square: A,\n      triangle: function (d, q, p, f) {\n        return [[\"M\", d + p / 2, q], [\"L\", d + p, q + f], [\"L\", d, q + f], [\"Z\"]];\n      },\n      \"triangle-down\": function (d, q, p, f) {\n        return [[\"M\", d, q], [\"L\", d + p, q], [\"L\", d + p / 2, q + f], [\"Z\"]];\n      }\n    };\n  });\n  N(h, \"Core/Renderer/SVG/TextBuilder.js\", [h[\"Core/Renderer/HTML/AST.js\"], h[\"Core/Globals.js\"], h[\"Core/Utilities.js\"]], function (d, h, A) {\n    var E = h.doc,\n        t = h.SVG_NS,\n        G = h.win,\n        H = A.attr,\n        y = A.isString,\n        q = A.objectEach,\n        p = A.pick;\n    return function () {\n      function f(c) {\n        var a = c.styles;\n        this.renderer = c.renderer;\n        this.svgElement = c;\n        this.width = c.textWidth;\n        this.textLineHeight = a && a.lineHeight;\n        this.textOutline = a && a.textOutline;\n        this.ellipsis = !(!a || \"ellipsis\" !== a.textOverflow);\n        this.noWrap = !(!a || \"nowrap\" !== a.whiteSpace);\n        this.fontSize = a && a.fontSize;\n      }\n\n      f.prototype.buildSVG = function () {\n        var c = this.svgElement,\n            a = c.element,\n            f = c.renderer,\n            m = p(c.textStr, \"\").toString(),\n            D = -1 !== m.indexOf(\"<\"),\n            C = a.childNodes;\n        f = this.width && !c.added && f.box;\n        var I = /<br.*?>/g,\n            L = [m, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, this.fontSize, this.width].join();\n\n        if (L !== c.textCache) {\n          c.textCache = L;\n          delete c.actualWidth;\n\n          for (L = C.length; L--;) a.removeChild(C[L]);\n\n          D || this.ellipsis || this.width || -1 !== m.indexOf(\" \") && (!this.noWrap || I.test(m)) ? \"\" !== m && (f && f.appendChild(a), m = new d(m), this.modifyTree(m.nodes), m.addToDOM(c.element), this.modifyDOM(), this.ellipsis && -1 !== (a.textContent || \"\").indexOf(\"\\u2026\") && c.attr(\"title\", this.unescapeEntities(c.textStr || \"\", [\"&lt;\", \"&gt;\"])), f && f.removeChild(a)) : a.appendChild(E.createTextNode(this.unescapeEntities(m)));\n          y(this.textOutline) && c.applyTextOutline && c.applyTextOutline(this.textOutline);\n        }\n      };\n\n      f.prototype.modifyDOM = function () {\n        var c = this,\n            a = this.svgElement,\n            f = H(a.element, \"x\");\n        a.firstLineMetrics = void 0;\n\n        for (var m; m = a.element.firstChild;) if (/^[\\s\\u200B]*$/.test(m.textContent || \" \")) a.element.removeChild(m);else break;\n\n        [].forEach.call(a.element.querySelectorAll(\"tspan.highcharts-br\"), function (n, m) {\n          n.nextSibling && n.previousSibling && (0 === m && 1 === n.previousSibling.nodeType && (a.firstLineMetrics = a.renderer.fontMetrics(void 0, n.previousSibling)), H(n, {\n            dy: c.getLineHeight(n.nextSibling),\n            x: f\n          }));\n        });\n        var d = this.width || 0;\n\n        if (d) {\n          var C = function (n, m) {\n            var v = n.textContent || \"\",\n                z = v.replace(/([^\\^])-/g, \"$1- \").split(\" \"),\n                u = !c.noWrap && (1 < z.length || 1 < a.element.childNodes.length),\n                k = c.getLineHeight(m),\n                w = 0,\n                l = a.actualWidth;\n            if (c.ellipsis) v && c.truncate(n, v, void 0, 0, Math.max(0, d - parseInt(c.fontSize || 12, 10)), function (e, g) {\n              return e.substring(0, g) + \"\\u2026\";\n            });else if (u) {\n              v = [];\n\n              for (u = []; m.firstChild && m.firstChild !== n;) u.push(m.firstChild), m.removeChild(m.firstChild);\n\n              for (; z.length;) z.length && !c.noWrap && 0 < w && (v.push(n.textContent || \"\"), n.textContent = z.join(\" \").replace(/- /g, \"-\")), c.truncate(n, void 0, z, 0 === w ? l || 0 : 0, d, function (e, g) {\n                return z.slice(0, g).join(\" \").replace(/- /g, \"-\");\n              }), l = a.actualWidth, w++;\n\n              u.forEach(function (e) {\n                m.insertBefore(e, n);\n              });\n              v.forEach(function (e) {\n                m.insertBefore(E.createTextNode(e), n);\n                e = E.createElementNS(t, \"tspan\");\n                e.textContent = \"\\u200b\";\n                H(e, {\n                  dy: k,\n                  x: f\n                });\n                m.insertBefore(e, n);\n              });\n            }\n          },\n              p = function (c) {\n            [].slice.call(c.childNodes).forEach(function (f) {\n              f.nodeType === G.Node.TEXT_NODE ? C(f, c) : (-1 !== f.className.baseVal.indexOf(\"highcharts-br\") && (a.actualWidth = 0), p(f));\n            });\n          };\n\n          p(a.element);\n        }\n      };\n\n      f.prototype.getLineHeight = function (c) {\n        var a;\n        c = c.nodeType === G.Node.TEXT_NODE ? c.parentElement : c;\n        this.renderer.styledMode || (a = c && /(px|em)$/.test(c.style.fontSize) ? c.style.fontSize : this.fontSize || this.renderer.style.fontSize || 12);\n        return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(a, c || this.svgElement.element).h;\n      };\n\n      f.prototype.modifyTree = function (c) {\n        var a = this,\n            f = function (n, d) {\n          var m = n.attributes;\n          m = void 0 === m ? {} : m;\n          var p = n.children,\n              D = n.tagName,\n              q = a.renderer.styledMode;\n          if (\"b\" === D || \"strong\" === D) q ? m[\"class\"] = \"highcharts-strong\" : m.style = \"font-weight:bold;\" + (m.style || \"\");else if (\"i\" === D || \"em\" === D) q ? m[\"class\"] = \"highcharts-emphasized\" : m.style = \"font-style:italic;\" + (m.style || \"\");\n          y(m.style) && (m.style = m.style.replace(/(;| |^)color([ :])/, \"$1fill$2\"));\n          \"br\" === D ? (m[\"class\"] = \"highcharts-br\", n.textContent = \"\\u200b\", (d = c[d + 1]) && d.textContent && (d.textContent = d.textContent.replace(/^ +/gm, \"\"))) : \"a\" === D && p && p.some(function (a) {\n            return \"#text\" === a.tagName;\n          }) && (n.children = [{\n            children: p,\n            tagName: \"tspan\"\n          }]);\n          \"#text\" !== D && \"a\" !== D && (n.tagName = \"tspan\");\n          n.attributes = m;\n          p && p.filter(function (a) {\n            return \"#text\" !== a.tagName;\n          }).forEach(f);\n        };\n\n        c.forEach(f);\n      };\n\n      f.prototype.truncate = function (c, a, f, m, d, p) {\n        var n = this.svgElement,\n            C = n.renderer,\n            D = n.rotation,\n            v = [],\n            z = f ? 1 : 0,\n            u = (a || f || \"\").length,\n            k = u,\n            w,\n            l = function (e, b) {\n          b = b || e;\n          var g = c.parentNode;\n          if (g && \"undefined\" === typeof v[b]) if (g.getSubStringLength) try {\n            v[b] = m + g.getSubStringLength(0, f ? b + 1 : b);\n          } catch (J) {\n            \"\";\n          } else C.getSpanWidth && (c.textContent = p(a || f, e), v[b] = m + C.getSpanWidth(n, c));\n          return v[b];\n        };\n\n        n.rotation = 0;\n        var e = l(c.textContent.length);\n\n        if (m + e > d) {\n          for (; z <= u;) k = Math.ceil((z + u) / 2), f && (w = p(f, k)), e = l(k, w && w.length - 1), z === u ? z = u + 1 : e > d ? u = k - 1 : z = k;\n\n          0 === u ? c.textContent = \"\" : a && u === a.length - 1 || (c.textContent = w || p(a || f, k));\n        }\n\n        f && f.splice(0, k);\n        n.actualWidth = e;\n        n.rotation = D;\n      };\n\n      f.prototype.unescapeEntities = function (c, a) {\n        q(this.renderer.escapes, function (f, m) {\n          a && -1 !== a.indexOf(f) || (c = c.toString().replace(new RegExp(f, \"g\"), m));\n        });\n        return c;\n      };\n\n      return f;\n    }();\n  });\n  N(h, \"Core/Renderer/SVG/SVGRenderer.js\", [h[\"Core/Renderer/HTML/AST.js\"], h[\"Core/Color/Color.js\"], h[\"Core/Globals.js\"], h[\"Core/Renderer/RendererRegistry.js\"], h[\"Core/Renderer/SVG/SVGElement.js\"], h[\"Core/Renderer/SVG/SVGLabel.js\"], h[\"Core/Renderer/SVG/Symbols.js\"], h[\"Core/Renderer/SVG/TextBuilder.js\"], h[\"Core/Utilities.js\"]], function (d, h, A, F, t, G, H, y, q) {\n    var p = A.charts,\n        f = A.deg2rad,\n        c = A.doc,\n        a = A.isFirefox,\n        n = A.isMS,\n        m = A.isWebKit,\n        D = A.noop,\n        C = A.SVG_NS,\n        I = A.symbolSizes,\n        L = A.win,\n        K = q.addEvent,\n        v = q.attr,\n        z = q.createElement,\n        u = q.css,\n        k = q.defined,\n        w = q.destroyObjectProperties,\n        l = q.extend,\n        e = q.isArray,\n        g = q.isNumber,\n        b = q.isObject,\n        B = q.isString,\n        J = q.merge,\n        r = q.pick,\n        x = q.pInt,\n        M = q.uniqueKey,\n        X;\n\n    A = function () {\n      function P(b, e, g, l, k, a, r) {\n        this.width = this.url = this.style = this.isSVG = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;\n        this.init(b, e, g, l, k, a, r);\n      }\n\n      P.prototype.init = function (b, e, g, l, k, r, B) {\n        var x = this.createElement(\"svg\").attr({\n          version: \"1.1\",\n          \"class\": \"highcharts-root\"\n        }),\n            O = x.element;\n        B || x.css(this.getStyle(l));\n        b.appendChild(O);\n        v(b, \"dir\", \"ltr\");\n        -1 === b.innerHTML.indexOf(\"xmlns\") && v(O, \"xmlns\", this.SVG_NS);\n        this.isSVG = !0;\n        this.box = O;\n        this.boxWrapper = x;\n        this.alignedObjects = [];\n        this.url = this.getReferenceURL();\n        this.createElement(\"desc\").add().element.appendChild(c.createTextNode(\"Created with Highcharts 9.3.2\"));\n        this.defs = this.createElement(\"defs\").add();\n        this.allowHTML = r;\n        this.forExport = k;\n        this.styledMode = B;\n        this.gradients = {};\n        this.cache = {};\n        this.cacheKeys = [];\n        this.imgCount = 0;\n        this.setSize(e, g, !1);\n        var P;\n        a && b.getBoundingClientRect && (e = function () {\n          u(b, {\n            left: 0,\n            top: 0\n          });\n          P = b.getBoundingClientRect();\n          u(b, {\n            left: Math.ceil(P.left) - P.left + \"px\",\n            top: Math.ceil(P.top) - P.top + \"px\"\n          });\n        }, e(), this.unSubPixelFix = K(L, \"resize\", e));\n      };\n\n      P.prototype.definition = function (b) {\n        return new d([b]).addToDOM(this.defs.element);\n      };\n\n      P.prototype.getReferenceURL = function () {\n        if ((a || m) && c.getElementsByTagName(\"base\").length) {\n          if (!k(X)) {\n            var b = M();\n            b = new d([{\n              tagName: \"svg\",\n              attributes: {\n                width: 8,\n                height: 8\n              },\n              children: [{\n                tagName: \"defs\",\n                children: [{\n                  tagName: \"clipPath\",\n                  attributes: {\n                    id: b\n                  },\n                  children: [{\n                    tagName: \"rect\",\n                    attributes: {\n                      width: 4,\n                      height: 4\n                    }\n                  }]\n                }]\n              }, {\n                tagName: \"rect\",\n                attributes: {\n                  id: \"hitme\",\n                  width: 8,\n                  height: 8,\n                  \"clip-path\": \"url(#\" + b + \")\",\n                  fill: \"rgba(0,0,0,0.001)\"\n                }\n              }]\n            }]).addToDOM(c.body);\n            u(b, {\n              position: \"fixed\",\n              top: 0,\n              left: 0,\n              zIndex: 9E5\n            });\n            var e = c.elementFromPoint(6, 6);\n            X = \"hitme\" === (e && e.id);\n            c.body.removeChild(b);\n          }\n\n          if (X) return L.location.href.split(\"#\")[0].replace(/<[^>]*>/g, \"\").replace(/([\\('\\)])/g, \"\\\\$1\").replace(/ /g, \"%20\");\n        }\n\n        return \"\";\n      };\n\n      P.prototype.getStyle = function (b) {\n        return this.style = l({\n          fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif',\n          fontSize: \"12px\"\n        }, b);\n      };\n\n      P.prototype.setStyle = function (b) {\n        this.boxWrapper.css(this.getStyle(b));\n      };\n\n      P.prototype.isHidden = function () {\n        return !this.boxWrapper.getBBox().width;\n      };\n\n      P.prototype.destroy = function () {\n        var b = this.defs;\n        this.box = null;\n        this.boxWrapper = this.boxWrapper.destroy();\n        w(this.gradients || {});\n        this.gradients = null;\n        b && (this.defs = b.destroy());\n        this.unSubPixelFix && this.unSubPixelFix();\n        return this.alignedObjects = null;\n      };\n\n      P.prototype.createElement = function (b) {\n        var e = new this.Element();\n        e.init(this, b);\n        return e;\n      };\n\n      P.prototype.getRadialAttr = function (b, e) {\n        return {\n          cx: b[0] - b[2] / 2 + (e.cx || 0) * b[2],\n          cy: b[1] - b[2] / 2 + (e.cy || 0) * b[2],\n          r: (e.r || 0) * b[2]\n        };\n      };\n\n      P.prototype.buildText = function (b) {\n        new y(b).buildSVG();\n      };\n\n      P.prototype.getContrast = function (b) {\n        b = h.parse(b).rgba;\n        b[0] *= 1;\n        b[1] *= 1.2;\n        b[2] *= .5;\n        return 459 < b[0] + b[1] + b[2] ? \"#000000\" : \"#FFFFFF\";\n      };\n\n      P.prototype.button = function (b, e, g, k, a, r, c, B, x, P) {\n        var u = this.label(b, e, g, x, void 0, void 0, P, void 0, \"button\"),\n            w = this.styledMode,\n            O = 0,\n            f = a ? J(a) : {};\n        b = f && f.style || {};\n        f = d.filterUserAttributes(f);\n        u.attr(J({\n          padding: 8,\n          r: 2\n        }, f));\n\n        if (!w) {\n          f = J({\n            fill: \"#f7f7f7\",\n            stroke: \"#cccccc\",\n            \"stroke-width\": 1,\n            style: {\n              color: \"#333333\",\n              cursor: \"pointer\",\n              fontWeight: \"normal\"\n            }\n          }, {\n            style: b\n          }, f);\n          var Q = f.style;\n          delete f.style;\n          r = J(f, {\n            fill: \"#e6e6e6\"\n          }, d.filterUserAttributes(r || {}));\n          var z = r.style;\n          delete r.style;\n          c = J(f, {\n            fill: \"#e6ebf5\",\n            style: {\n              color: \"#000000\",\n              fontWeight: \"bold\"\n            }\n          }, d.filterUserAttributes(c || {}));\n          var m = c.style;\n          delete c.style;\n          B = J(f, {\n            style: {\n              color: \"#cccccc\"\n            }\n          }, d.filterUserAttributes(B || {}));\n          var W = B.style;\n          delete B.style;\n        }\n\n        K(u.element, n ? \"mouseover\" : \"mouseenter\", function () {\n          3 !== O && u.setState(1);\n        });\n        K(u.element, n ? \"mouseout\" : \"mouseleave\", function () {\n          3 !== O && u.setState(O);\n        });\n\n        u.setState = function (b) {\n          1 !== b && (u.state = O = b);\n          u.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][b || 0]);\n          w || u.attr([f, r, c, B][b || 0]).css([Q, z, m, W][b || 0]);\n        };\n\n        w || u.attr(f).css(l({\n          cursor: \"default\"\n        }, Q));\n        return u.on(\"touchstart\", function (b) {\n          return b.stopPropagation();\n        }).on(\"click\", function (b) {\n          3 !== O && k.call(u, b);\n        });\n      };\n\n      P.prototype.crispLine = function (b, e, g) {\n        void 0 === g && (g = \"round\");\n        var l = b[0],\n            a = b[1];\n        k(l[1]) && l[1] === a[1] && (l[1] = a[1] = Math[g](l[1]) - e % 2 / 2);\n        k(l[2]) && l[2] === a[2] && (l[2] = a[2] = Math[g](l[2]) + e % 2 / 2);\n        return b;\n      };\n\n      P.prototype.path = function (g) {\n        var k = this.styledMode ? {} : {\n          fill: \"none\"\n        };\n        e(g) ? k.d = g : b(g) && l(k, g);\n        return this.createElement(\"path\").attr(k);\n      };\n\n      P.prototype.circle = function (e, g, l) {\n        e = b(e) ? e : \"undefined\" === typeof e ? {} : {\n          x: e,\n          y: g,\n          r: l\n        };\n        g = this.createElement(\"circle\");\n\n        g.xSetter = g.ySetter = function (b, e, g) {\n          g.setAttribute(\"c\" + e, b);\n        };\n\n        return g.attr(e);\n      };\n\n      P.prototype.arc = function (e, g, l, k, a, r) {\n        b(e) ? (k = e, g = k.y, l = k.r, e = k.x) : k = {\n          innerR: k,\n          start: a,\n          end: r\n        };\n        e = this.symbol(\"arc\", e, g, l, l, k);\n        e.r = l;\n        return e;\n      };\n\n      P.prototype.rect = function (e, g, l, k, a, r) {\n        a = b(e) ? e.r : a;\n        var c = this.createElement(\"rect\");\n        e = b(e) ? e : \"undefined\" === typeof e ? {} : {\n          x: e,\n          y: g,\n          width: Math.max(l, 0),\n          height: Math.max(k, 0)\n        };\n        this.styledMode || (\"undefined\" !== typeof r && (e[\"stroke-width\"] = r, e = c.crisp(e)), e.fill = \"none\");\n        a && (e.r = a);\n\n        c.rSetter = function (b, e, g) {\n          c.r = b;\n          v(g, {\n            rx: b,\n            ry: b\n          });\n        };\n\n        c.rGetter = function () {\n          return c.r || 0;\n        };\n\n        return c.attr(e);\n      };\n\n      P.prototype.setSize = function (b, e, g) {\n        this.width = b;\n        this.height = e;\n        this.boxWrapper.animate({\n          width: b,\n          height: e\n        }, {\n          step: function () {\n            this.attr({\n              viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n            });\n          },\n          duration: r(g, !0) ? void 0 : 0\n        });\n        this.alignElements();\n      };\n\n      P.prototype.g = function (b) {\n        var e = this.createElement(\"g\");\n        return b ? e.attr({\n          \"class\": \"highcharts-\" + b\n        }) : e;\n      };\n\n      P.prototype.image = function (b, e, l, k, a, r) {\n        var c = {\n          preserveAspectRatio: \"none\"\n        },\n            B = function (b, e) {\n          b.setAttributeNS ? b.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", e) : b.setAttribute(\"hc-svg-href\", e);\n        };\n\n        g(e) && (c.x = e);\n        g(l) && (c.y = l);\n        g(k) && (c.width = k);\n        g(a) && (c.height = a);\n        var x = this.createElement(\"image\").attr(c);\n\n        e = function (e) {\n          B(x.element, b);\n          r.call(x, e);\n        };\n\n        r ? (B(x.element, \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"), l = new L.Image(), K(l, \"load\", e), l.src = b, l.complete && e({})) : B(x.element, b);\n        return x;\n      };\n\n      P.prototype.symbol = function (b, e, g, a, B, x) {\n        var P = this,\n            w = /^url\\((.*?)\\)$/,\n            f = w.test(b),\n            J = !f && (this.symbols[b] ? b : \"circle\"),\n            O = J && this.symbols[J],\n            Q;\n\n        if (O) {\n          \"number\" === typeof e && (Q = O.call(this.symbols, Math.round(e || 0), Math.round(g || 0), a || 0, B || 0, x));\n          var n = this.path(Q);\n          P.styledMode || n.attr(\"fill\", \"none\");\n          l(n, {\n            symbolName: J || void 0,\n            x: e,\n            y: g,\n            width: a,\n            height: B\n          });\n          x && l(n, x);\n        } else if (f) {\n          var m = b.match(w)[1];\n          var v = n = this.image(m);\n          v.imgwidth = r(I[m] && I[m].width, x && x.width);\n          v.imgheight = r(I[m] && I[m].height, x && x.height);\n\n          var d = function (b) {\n            return b.attr({\n              width: b.width,\n              height: b.height\n            });\n          };\n\n          [\"width\", \"height\"].forEach(function (b) {\n            v[b + \"Setter\"] = function (b, e) {\n              var g = this[\"img\" + e];\n              this[e] = b;\n              k(g) && (x && \"within\" === x.backgroundSize && this.width && this.height && (g = Math.round(g * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(e, g), this.alignByTranslate || (b = ((this[e] || 0) - g) / 2, this.attr(\"width\" === e ? {\n                translateX: b\n              } : {\n                translateY: b\n              })));\n            };\n          });\n          k(e) && v.attr({\n            x: e,\n            y: g\n          });\n          v.isImg = !0;\n          k(v.imgwidth) && k(v.imgheight) ? d(v) : (v.attr({\n            width: 0,\n            height: 0\n          }), z(\"img\", {\n            onload: function () {\n              var b = p[P.chartIndex];\n              0 === this.width && (u(this, {\n                position: \"absolute\",\n                top: \"-999em\"\n              }), c.body.appendChild(this));\n              I[m] = {\n                width: this.width,\n                height: this.height\n              };\n              v.imgwidth = this.width;\n              v.imgheight = this.height;\n              v.element && d(v);\n              this.parentNode && this.parentNode.removeChild(this);\n              P.imgCount--;\n              if (!P.imgCount && b && !b.hasLoaded) b.onload();\n            },\n            src: m\n          }), this.imgCount++);\n        }\n\n        return n;\n      };\n\n      P.prototype.clipRect = function (b, e, g, l) {\n        var k = M() + \"-\",\n            a = this.createElement(\"clipPath\").attr({\n          id: k\n        }).add(this.defs);\n        b = this.rect(b, e, g, l, 0).add(a);\n        b.id = k;\n        b.clipPath = a;\n        b.count = 0;\n        return b;\n      };\n\n      P.prototype.text = function (b, e, g, l) {\n        var a = {};\n        if (l && (this.allowHTML || !this.forExport)) return this.html(b, e, g);\n        a.x = Math.round(e || 0);\n        g && (a.y = Math.round(g));\n        k(b) && (a.text = b);\n        b = this.createElement(\"text\").attr(a);\n        if (!l || this.forExport && !this.allowHTML) b.xSetter = function (b, e, g) {\n          for (var l = g.getElementsByTagName(\"tspan\"), k = g.getAttribute(e), a = 0, r; a < l.length; a++) r = l[a], r.getAttribute(e) === k && r.setAttribute(e, b);\n\n          g.setAttribute(e, b);\n        };\n        return b;\n      };\n\n      P.prototype.fontMetrics = function (b, e) {\n        b = !this.styledMode && /px/.test(b) || !L.getComputedStyle ? b || e && e.style && e.style.fontSize || this.style && this.style.fontSize : e && t.prototype.getStyle.call(e, \"font-size\");\n        b = /px/.test(b) ? x(b) : 12;\n        e = 24 > b ? b + 3 : Math.round(1.2 * b);\n        return {\n          h: e,\n          b: Math.round(.8 * e),\n          f: b\n        };\n      };\n\n      P.prototype.rotCorr = function (b, e, g) {\n        var l = b;\n        e && g && (l = Math.max(l * Math.cos(e * f), 4));\n        return {\n          x: -b / 3 * Math.sin(e * f),\n          y: l\n        };\n      };\n\n      P.prototype.pathToSegments = function (b) {\n        for (var e = [], l = [], k = {\n          A: 8,\n          C: 7,\n          H: 2,\n          L: 3,\n          M: 3,\n          Q: 5,\n          S: 5,\n          T: 3,\n          V: 2\n        }, a = 0; a < b.length; a++) B(l[0]) && g(b[a]) && l.length === k[l[0].toUpperCase()] && b.splice(a, 0, l[0].replace(\"M\", \"L\").replace(\"m\", \"l\")), \"string\" === typeof b[a] && (l.length && e.push(l.slice(0)), l.length = 0), l.push(b[a]);\n\n        e.push(l.slice(0));\n        return e;\n      };\n\n      P.prototype.label = function (b, e, g, l, k, a, r, c, x) {\n        return new G(this, b, e, g, l, k, a, r, c, x);\n      };\n\n      P.prototype.alignElements = function () {\n        this.alignedObjects.forEach(function (b) {\n          return b.align();\n        });\n      };\n\n      return P;\n    }();\n\n    l(A.prototype, {\n      Element: t,\n      SVG_NS: C,\n      escapes: {\n        \"&\": \"&amp;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        \"'\": \"&#39;\",\n        '\"': \"&quot;\"\n      },\n      symbols: H,\n      draw: D\n    });\n    F.registerRendererType(\"svg\", A, !0);\n    \"\";\n    return A;\n  });\n  N(h, \"Core/Renderer/HTML/HTMLElement.js\", [h[\"Core/Globals.js\"], h[\"Core/Renderer/SVG/SVGElement.js\"], h[\"Core/Utilities.js\"]], function (d, h, A) {\n    var E = this && this.__extends || function () {\n      var a = function (c, f) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, c) {\n          a.__proto__ = c;\n        } || function (a, c) {\n          for (var f in c) c.hasOwnProperty(f) && (a[f] = c[f]);\n        };\n\n        return a(c, f);\n      };\n\n      return function (c, f) {\n        function n() {\n          this.constructor = c;\n        }\n\n        a(c, f);\n        c.prototype = null === f ? Object.create(f) : (n.prototype = f.prototype, new n());\n      };\n    }(),\n        t = d.isFirefox,\n        G = d.isMS,\n        H = d.isWebKit,\n        y = d.win,\n        q = A.css,\n        p = A.defined,\n        f = A.extend,\n        c = A.pick,\n        a = A.pInt;\n\n    return function (n) {\n      function m() {\n        return null !== n && n.apply(this, arguments) || this;\n      }\n\n      E(m, n);\n\n      m.compose = function (a) {\n        if (-1 === m.composedClasses.indexOf(a)) {\n          m.composedClasses.push(a);\n          var c = m.prototype,\n              f = a.prototype;\n          f.getSpanCorrection = c.getSpanCorrection;\n          f.htmlCss = c.htmlCss;\n          f.htmlGetBBox = c.htmlGetBBox;\n          f.htmlUpdateTransform = c.htmlUpdateTransform;\n          f.setSpanRotation = c.setSpanRotation;\n        }\n\n        return a;\n      };\n\n      m.prototype.getSpanCorrection = function (a, c, f) {\n        this.xCorr = -a * f;\n        this.yCorr = -c;\n      };\n\n      m.prototype.htmlCss = function (a) {\n        var n = \"SPAN\" === this.element.tagName && a && \"width\" in a,\n            m = c(n && a.width, void 0);\n\n        if (n) {\n          delete a.width;\n          this.textWidth = m;\n          var d = !0;\n        }\n\n        a && \"ellipsis\" === a.textOverflow && (a.whiteSpace = \"nowrap\", a.overflow = \"hidden\");\n        this.styles = f(this.styles, a);\n        q(this.element, a);\n        d && this.htmlUpdateTransform();\n        return this;\n      };\n\n      m.prototype.htmlGetBBox = function () {\n        var a = this.element;\n        return {\n          x: a.offsetLeft,\n          y: a.offsetTop,\n          width: a.offsetWidth,\n          height: a.offsetHeight\n        };\n      };\n\n      m.prototype.htmlUpdateTransform = function () {\n        if (this.added) {\n          var c = this.renderer,\n              f = this.element,\n              n = this.translateX || 0,\n              m = this.translateY || 0,\n              d = this.x || 0,\n              v = this.y || 0,\n              z = this.textAlign || \"left\",\n              u = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[z],\n              k = this.styles;\n          k = k && k.whiteSpace;\n          q(f, {\n            marginLeft: n,\n            marginTop: m\n          });\n          !c.styledMode && this.shadows && this.shadows.forEach(function (b) {\n            q(b, {\n              marginLeft: n + 1,\n              marginTop: m + 1\n            });\n          });\n          this.inverted && [].forEach.call(f.childNodes, function (b) {\n            c.invertChild(b, f);\n          });\n\n          if (\"SPAN\" === f.tagName) {\n            var w = this.rotation,\n                l = this.textWidth && a(this.textWidth),\n                e = [w, z, f.innerHTML, this.textWidth, this.textAlign].join(),\n                g = void 0;\n            g = !1;\n\n            if (l !== this.oldTextWidth) {\n              if (this.textPxLength) var b = this.textPxLength;else q(f, {\n                width: \"\",\n                whiteSpace: k || \"nowrap\"\n              }), b = f.offsetWidth;\n              (l > this.oldTextWidth || b > l) && (/[ \\-]/.test(f.textContent || f.innerText) || \"ellipsis\" === f.style.textOverflow) && (q(f, {\n                width: b > l || w ? l + \"px\" : \"auto\",\n                display: \"block\",\n                whiteSpace: k || \"normal\"\n              }), this.oldTextWidth = l, g = !0);\n            }\n\n            this.hasBoxWidthChanged = g;\n            e !== this.cTT && (g = c.fontMetrics(f.style.fontSize, f).b, !p(w) || w === (this.oldRotation || 0) && z === this.oldAlign || this.setSpanRotation(w, u, g), this.getSpanCorrection(!p(w) && this.textPxLength || f.offsetWidth, g, u, w, z));\n            q(f, {\n              left: d + (this.xCorr || 0) + \"px\",\n              top: v + (this.yCorr || 0) + \"px\"\n            });\n            this.cTT = e;\n            this.oldRotation = w;\n            this.oldAlign = z;\n          }\n        } else this.alignOnAdd = !0;\n      };\n\n      m.prototype.setSpanRotation = function (a, c, f) {\n        var n = {},\n            m = G && !/Edge/.test(y.navigator.userAgent) ? \"-ms-transform\" : H ? \"-webkit-transform\" : t ? \"MozTransform\" : y.opera ? \"-o-transform\" : void 0;\n        m && (n[m] = n.transform = \"rotate(\" + a + \"deg)\", n[m + (t ? \"Origin\" : \"-origin\")] = n.transformOrigin = 100 * c + \"% \" + f + \"px\", q(this.element, n));\n      };\n\n      m.composedClasses = [];\n      return m;\n    }(h);\n  });\n  N(h, \"Core/Renderer/HTML/HTMLRenderer.js\", [h[\"Core/Renderer/HTML/AST.js\"], h[\"Core/Renderer/SVG/SVGElement.js\"], h[\"Core/Renderer/SVG/SVGRenderer.js\"], h[\"Core/Utilities.js\"]], function (d, h, A, F) {\n    var t = this && this.__extends || function () {\n      var d = function (f, c) {\n        d = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, c) {\n          a.__proto__ = c;\n        } || function (a, c) {\n          for (var f in c) c.hasOwnProperty(f) && (a[f] = c[f]);\n        };\n\n        return d(f, c);\n      };\n\n      return function (f, c) {\n        function a() {\n          this.constructor = f;\n        }\n\n        d(f, c);\n        f.prototype = null === c ? Object.create(c) : (a.prototype = c.prototype, new a());\n      };\n    }(),\n        E = F.attr,\n        H = F.createElement,\n        y = F.extend,\n        q = F.pick;\n\n    return function (p) {\n      function f() {\n        return null !== p && p.apply(this, arguments) || this;\n      }\n\n      t(f, p);\n\n      f.compose = function (c) {\n        -1 === f.composedClasses.indexOf(c) && (f.composedClasses.push(c), c.prototype.html = f.prototype.html);\n        return c;\n      };\n\n      f.prototype.html = function (c, a, f) {\n        var n = this.createElement(\"span\"),\n            p = n.element,\n            C = n.renderer,\n            I = C.isSVG,\n            L = function (a, c) {\n          [\"opacity\", \"visibility\"].forEach(function (f) {\n            a[f + \"Setter\"] = function (u, k, w) {\n              var l = a.div ? a.div.style : c;\n              h.prototype[f + \"Setter\"].call(this, u, k, w);\n              l && (l[k] = u);\n            };\n          });\n          a.addedSetters = !0;\n        };\n\n        n.textSetter = function (a) {\n          a !== this.textStr && (delete this.bBox, delete this.oldTextWidth, d.setElementHTML(this.element, q(a, \"\")), this.textStr = a, n.doTransform = !0);\n        };\n\n        I && L(n, n.element.style);\n\n        n.xSetter = n.ySetter = n.alignSetter = n.rotationSetter = function (a, c) {\n          \"align\" === c ? n.alignValue = n.textAlign = a : n[c] = a;\n          n.doTransform = !0;\n        };\n\n        n.afterSetters = function () {\n          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);\n        };\n\n        n.attr({\n          text: c,\n          x: Math.round(a),\n          y: Math.round(f)\n        }).css({\n          position: \"absolute\"\n        });\n        C.styledMode || n.css({\n          fontFamily: this.style.fontFamily,\n          fontSize: this.style.fontSize\n        });\n        p.style.whiteSpace = \"nowrap\";\n        n.css = n.htmlCss;\n        I && (n.add = function (a) {\n          var c = C.box.parentNode,\n              f = [];\n\n          if (this.parentGroup = a) {\n            var u = a.div;\n\n            if (!u) {\n              for (; a;) f.push(a), a = a.parentGroup;\n\n              f.reverse().forEach(function (k) {\n                function a(b, e) {\n                  k[e] = b;\n                  \"translateX\" === e ? g.left = b + \"px\" : g.top = b + \"px\";\n                  k.doTransform = !0;\n                }\n\n                var l = E(k.element, \"class\"),\n                    e = k.styles || {};\n                u = k.div = k.div || H(\"div\", l ? {\n                  className: l\n                } : void 0, {\n                  position: \"absolute\",\n                  left: (k.translateX || 0) + \"px\",\n                  top: (k.translateY || 0) + \"px\",\n                  display: k.display,\n                  opacity: k.opacity,\n                  cursor: e.cursor,\n                  pointerEvents: e.pointerEvents,\n                  visibility: k.visibility\n                }, u || c);\n                var g = u.style;\n                y(k, {\n                  classSetter: function (b) {\n                    return function (e) {\n                      this.element.setAttribute(\"class\", e);\n                      b.className = e;\n                    };\n                  }(u),\n                  on: function () {\n                    f[0].div && n.on.apply({\n                      element: f[0].div,\n                      onEvents: k.onEvents\n                    }, arguments);\n                    return k;\n                  },\n                  translateXSetter: a,\n                  translateYSetter: a\n                });\n                k.addedSetters || L(k);\n              });\n            }\n          } else u = c;\n\n          u.appendChild(p);\n          n.added = !0;\n          n.alignOnAdd && n.htmlUpdateTransform();\n          return n;\n        });\n        return n;\n      };\n\n      f.composedClasses = [];\n      return f;\n    }(A);\n  });\n  N(h, \"Core/Axis/AxisDefaults.js\", [], function () {\n    var d = /*#__PURE__*/(() => {\n      (function (d) {\n        d.defaultXAxisOptions = {\n          alignTicks: !0,\n          allowDecimals: void 0,\n          panningEnabled: !0,\n          zIndex: 2,\n          zoomEnabled: !0,\n          dateTimeLabelFormats: {\n            millisecond: {\n              main: \"%H:%M:%S.%L\",\n              range: !1\n            },\n            second: {\n              main: \"%H:%M:%S\",\n              range: !1\n            },\n            minute: {\n              main: \"%H:%M\",\n              range: !1\n            },\n            hour: {\n              main: \"%H:%M\",\n              range: !1\n            },\n            day: {\n              main: \"%e. %b\"\n            },\n            week: {\n              main: \"%e. %b\"\n            },\n            month: {\n              main: \"%b '%y\"\n            },\n            year: {\n              main: \"%Y\"\n            }\n          },\n          endOnTick: !1,\n          gridLineDashStyle: \"Solid\",\n          gridZIndex: 1,\n          labels: {\n            autoRotation: void 0,\n            autoRotationLimit: 80,\n            distance: void 0,\n            enabled: !0,\n            indentation: 10,\n            overflow: \"justify\",\n            padding: 5,\n            reserveSpace: void 0,\n            rotation: void 0,\n            staggerLines: 0,\n            step: 0,\n            useHTML: !1,\n            x: 0,\n            zIndex: 7,\n            style: {\n              color: \"#666666\",\n              cursor: \"default\",\n              fontSize: \"11px\"\n            }\n          },\n          maxPadding: .01,\n          minorGridLineDashStyle: \"Solid\",\n          minorTickLength: 2,\n          minorTickPosition: \"outside\",\n          minPadding: .01,\n          offset: void 0,\n          opposite: !1,\n          reversed: void 0,\n          reversedStacks: !1,\n          showEmpty: !0,\n          showFirstLabel: !0,\n          showLastLabel: !0,\n          startOfWeek: 1,\n          startOnTick: !1,\n          tickLength: 10,\n          tickPixelInterval: 100,\n          tickmarkPlacement: \"between\",\n          tickPosition: \"outside\",\n          title: {\n            align: \"middle\",\n            rotation: 0,\n            useHTML: !1,\n            x: 0,\n            y: 0,\n            style: {\n              color: \"#666666\"\n            }\n          },\n          type: \"linear\",\n          uniqueNames: !0,\n          visible: !0,\n          minorGridLineColor: \"#f2f2f2\",\n          minorGridLineWidth: 1,\n          minorTickColor: \"#999999\",\n          lineColor: \"#ccd6eb\",\n          lineWidth: 1,\n          gridLineColor: \"#e6e6e6\",\n          gridLineWidth: void 0,\n          tickColor: \"#ccd6eb\"\n        };\n        d.defaultYAxisOptions = {\n          reversedStacks: !0,\n          endOnTick: !0,\n          maxPadding: .05,\n          minPadding: .05,\n          tickPixelInterval: 72,\n          showLastLabel: !0,\n          labels: {\n            x: -8\n          },\n          startOnTick: !0,\n          title: {\n            rotation: 270,\n            text: \"Values\"\n          },\n          stackLabels: {\n            animation: {},\n            allowOverlap: !1,\n            enabled: !1,\n            crop: !0,\n            overflow: \"justify\",\n            formatter: function () {\n              var d = this.axis.chart.numberFormatter;\n              return d(this.total, -1);\n            },\n            style: {\n              color: \"#000000\",\n              fontSize: \"11px\",\n              fontWeight: \"bold\",\n              textOutline: \"1px contrast\"\n            }\n          },\n          gridLineWidth: 1,\n          lineWidth: 0\n        };\n        d.defaultLeftAxisOptions = {\n          labels: {\n            x: -15\n          },\n          title: {\n            rotation: 270\n          }\n        };\n        d.defaultRightAxisOptions = {\n          labels: {\n            x: 15\n          },\n          title: {\n            rotation: 90\n          }\n        };\n        d.defaultBottomAxisOptions = {\n          labels: {\n            autoRotation: [-45],\n            x: 0\n          },\n          margin: 15,\n          title: {\n            rotation: 0\n          }\n        };\n        d.defaultTopAxisOptions = {\n          labels: {\n            autoRotation: [-45],\n            x: 0\n          },\n          margin: 15,\n          title: {\n            rotation: 0\n          }\n        };\n      })(d || (d = {}));\n\n      return d;\n    })();\n    return d;\n  });\n  N(h, \"Core/Foundation.js\", [h[\"Core/Utilities.js\"]], function (d) {\n    var h = d.addEvent,\n        A = d.isFunction,\n        F = d.objectEach,\n        t = d.removeEvent,\n        G;\n\n    (function (d) {\n      d.registerEventOptions = function (d, q) {\n        d.eventOptions = d.eventOptions || {};\n        F(q.events, function (p, f) {\n          d.eventOptions[f] !== p && (d.eventOptions[f] && (t(d, f, d.eventOptions[f]), delete d.eventOptions[f]), A(p) && (d.eventOptions[f] = p, h(d, f, p)));\n        });\n      };\n    })(G || (G = {}));\n\n    return G;\n  });\n  N(h, \"Core/Axis/Tick.js\", [h[\"Core/FormatUtilities.js\"], h[\"Core/Globals.js\"], h[\"Core/Utilities.js\"]], function (d, h, A) {\n    var E = h.deg2rad,\n        t = A.clamp,\n        G = A.correctFloat,\n        H = A.defined,\n        y = A.destroyObjectProperties,\n        q = A.extend,\n        p = A.fireEvent,\n        f = A.isNumber,\n        c = A.merge,\n        a = A.objectEach,\n        n = A.pick;\n\n    h = function () {\n      function m(a, c, f, n, d) {\n        this.isNewLabel = this.isNew = !0;\n        this.axis = a;\n        this.pos = c;\n        this.type = f || \"\";\n        this.parameters = d || {};\n        this.tickmarkOffset = this.parameters.tickmarkOffset;\n        this.options = this.parameters.options;\n        p(this, \"init\");\n        f || n || this.addLabel();\n      }\n\n      m.prototype.addLabel = function () {\n        var a = this,\n            c = a.axis,\n            m = c.options,\n            h = c.chart,\n            K = c.categories,\n            v = c.logarithmic,\n            z = c.names,\n            u = a.pos,\n            k = n(a.options && a.options.labels, m.labels),\n            w = c.tickPositions,\n            l = u === w[0],\n            e = u === w[w.length - 1],\n            g = (!k.step || 1 === k.step) && 1 === c.tickInterval;\n        w = w.info;\n        var b = a.label,\n            B;\n        K = this.parameters.category || (K ? n(K[u], z[u], u) : u);\n        v && f(K) && (K = G(v.lin2log(K)));\n        if (c.dateTime) if (w) {\n          var J = h.time.resolveDTLFormat(m.dateTimeLabelFormats[!m.grid && w.higherRanks[u] || w.unitName]);\n          var r = J.main;\n        } else f(K) && (r = c.dateTime.getXDateFormat(K, m.dateTimeLabelFormats || {}));\n        a.isFirst = l;\n        a.isLast = e;\n        var x = {\n          axis: c,\n          chart: h,\n          dateTimeLabelFormat: r,\n          isFirst: l,\n          isLast: e,\n          pos: u,\n          tick: a,\n          tickPositionInfo: w,\n          value: K\n        };\n        p(this, \"labelFormat\", x);\n\n        var M = function (b) {\n          return k.formatter ? k.formatter.call(b, b) : k.format ? (b.text = c.defaultLabelFormatter.call(b), d.format(k.format, b, h)) : c.defaultLabelFormatter.call(b, b);\n        };\n\n        m = M.call(x, x);\n        var X = J && J.list;\n        a.shortenLabel = X ? function () {\n          for (B = 0; B < X.length; B++) if (q(x, {\n            dateTimeLabelFormat: X[B]\n          }), b.attr({\n            text: M.call(x, x)\n          }), b.getBBox().width < c.getSlotWidth(a) - 2 * k.padding) return;\n\n          b.attr({\n            text: \"\"\n          });\n        } : void 0;\n        g && c._addedPlotLB && a.moveLabel(m, k);\n        H(b) || a.movedLabel ? b && b.textStr !== m && !g && (!b.textWidth || k.style.width || b.styles.width || b.css({\n          width: null\n        }), b.attr({\n          text: m\n        }), b.textPxLength = b.getBBox().width) : (a.label = b = a.createLabel({\n          x: 0,\n          y: 0\n        }, m, k), a.rotation = 0);\n      };\n\n      m.prototype.createLabel = function (a, f, n) {\n        var d = this.axis,\n            m = d.chart;\n        if (a = H(f) && n.enabled ? m.renderer.text(f, a.x, a.y, n.useHTML).add(d.labelGroup) : null) m.styledMode || a.css(c(n.style)), a.textPxLength = a.getBBox().width;\n        return a;\n      };\n\n      m.prototype.destroy = function () {\n        y(this, this.axis);\n      };\n\n      m.prototype.getPosition = function (a, c, f, n) {\n        var d = this.axis,\n            m = d.chart,\n            z = n && m.oldChartHeight || m.chartHeight;\n        a = {\n          x: a ? G(d.translate(c + f, null, null, n) + d.transB) : d.left + d.offset + (d.opposite ? (n && m.oldChartWidth || m.chartWidth) - d.right - d.left : 0),\n          y: a ? z - d.bottom + d.offset - (d.opposite ? d.height : 0) : G(z - d.translate(c + f, null, null, n) - d.transB)\n        };\n        a.y = t(a.y, -1E5, 1E5);\n        p(this, \"afterGetPosition\", {\n          pos: a\n        });\n        return a;\n      };\n\n      m.prototype.getLabelPosition = function (a, c, f, n, d, m, z, u) {\n        var k = this.axis,\n            w = k.transA,\n            l = k.isLinked && k.linkedParent ? k.linkedParent.reversed : k.reversed,\n            e = k.staggerLines,\n            g = k.tickRotCorr || {\n          x: 0,\n          y: 0\n        },\n            b = n || k.reserveSpaceDefault ? 0 : -k.labelOffset * (\"center\" === k.labelAlign ? .5 : 1),\n            B = {},\n            J = d.y;\n        H(J) || (J = 0 === k.side ? f.rotation ? -8 : -f.getBBox().height : 2 === k.side ? g.y + 8 : Math.cos(f.rotation * E) * (g.y - f.getBBox(!1, 0).height / 2));\n        a = a + d.x + b + g.x - (m && n ? m * w * (l ? -1 : 1) : 0);\n        c = c + J - (m && !n ? m * w * (l ? 1 : -1) : 0);\n        e && (f = z / (u || 1) % e, k.opposite && (f = e - f - 1), c += k.labelOffset / e * f);\n        B.x = a;\n        B.y = Math.round(c);\n        p(this, \"afterGetLabelPosition\", {\n          pos: B,\n          tickmarkOffset: m,\n          index: z\n        });\n        return B;\n      };\n\n      m.prototype.getLabelSize = function () {\n        return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n      };\n\n      m.prototype.getMarkPath = function (a, c, f, n, d, m) {\n        return m.crispLine([[\"M\", a, c], [\"L\", a + (d ? 0 : -f), c + (d ? f : 0)]], n);\n      };\n\n      m.prototype.handleOverflow = function (a) {\n        var c = this.axis,\n            f = c.options.labels,\n            d = a.x,\n            m = c.chart.chartWidth,\n            v = c.chart.spacing,\n            z = n(c.labelLeft, Math.min(c.pos, v[3]));\n        v = n(c.labelRight, Math.max(c.isRadial ? 0 : c.pos + c.len, m - v[1]));\n        var u = this.label,\n            k = this.rotation,\n            w = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[c.labelAlign || u.attr(\"align\")],\n            l = u.getBBox().width,\n            e = c.getSlotWidth(this),\n            g = {},\n            b = e,\n            B = 1,\n            J;\n        if (k || \"justify\" !== f.overflow) 0 > k && d - w * l < z ? J = Math.round(d / Math.cos(k * E) - z) : 0 < k && d + w * l > v && (J = Math.round((m - d) / Math.cos(k * E)));else if (m = d + (1 - w) * l, d - w * l < z ? b = a.x + b * (1 - w) - z : m > v && (b = v - a.x + b * w, B = -1), b = Math.min(e, b), b < e && \"center\" === c.labelAlign && (a.x += B * (e - b - w * (e - Math.min(l, b)))), l > b || c.autoRotation && (u.styles || {}).width) J = b;\n        J && (this.shortenLabel ? this.shortenLabel() : (g.width = Math.floor(J) + \"px\", (f.style || {}).textOverflow || (g.textOverflow = \"ellipsis\"), u.css(g)));\n      };\n\n      m.prototype.moveLabel = function (c, f) {\n        var n = this,\n            d = n.label,\n            m = n.axis,\n            v = m.reversed,\n            z = !1;\n        d && d.textStr === c ? (n.movedLabel = d, z = !0, delete n.label) : a(m.ticks, function (a) {\n          z || a.isNew || a === n || !a.label || a.label.textStr !== c || (n.movedLabel = a.label, z = !0, a.labelPos = n.movedLabel.xy, delete a.label);\n        });\n\n        if (!z && (n.labelPos || d)) {\n          var u = n.labelPos || d.xy;\n          d = m.horiz ? v ? 0 : m.width + m.left : u.x;\n          m = m.horiz ? u.y : v ? m.width + m.left : 0;\n          n.movedLabel = n.createLabel({\n            x: d,\n            y: m\n          }, c, f);\n          n.movedLabel && n.movedLabel.attr({\n            opacity: 0\n          });\n        }\n      };\n\n      m.prototype.render = function (a, c, f) {\n        var d = this.axis,\n            m = d.horiz,\n            v = this.pos,\n            z = n(this.tickmarkOffset, d.tickmarkOffset);\n        v = this.getPosition(m, v, z, c);\n        z = v.x;\n        var u = v.y;\n        d = m && z === d.pos + d.len || !m && u === d.pos ? -1 : 1;\n        m = n(f, this.label && this.label.newOpacity, 1);\n        f = n(f, 1);\n        this.isActive = !0;\n        this.renderGridLine(c, f, d);\n        this.renderMark(v, f, d);\n        this.renderLabel(v, c, m, a);\n        this.isNew = !1;\n        p(this, \"afterRender\");\n      };\n\n      m.prototype.renderGridLine = function (a, c, f) {\n        var d = this.axis,\n            m = d.options,\n            v = {},\n            z = this.pos,\n            u = this.type,\n            k = n(this.tickmarkOffset, d.tickmarkOffset),\n            w = d.chart.renderer,\n            l = this.gridLine,\n            e = m.gridLineWidth,\n            g = m.gridLineColor,\n            b = m.gridLineDashStyle;\n        \"minor\" === this.type && (e = m.minorGridLineWidth, g = m.minorGridLineColor, b = m.minorGridLineDashStyle);\n        l || (d.chart.styledMode || (v.stroke = g, v[\"stroke-width\"] = e || 0, v.dashstyle = b), u || (v.zIndex = 1), a && (c = 0), this.gridLine = l = w.path().attr(v).addClass(\"highcharts-\" + (u ? u + \"-\" : \"\") + \"grid-line\").add(d.gridGroup));\n        if (l && (f = d.getPlotLinePath({\n          value: z + k,\n          lineWidth: l.strokeWidth() * f,\n          force: \"pass\",\n          old: a\n        }))) l[a || this.isNew ? \"attr\" : \"animate\"]({\n          d: f,\n          opacity: c\n        });\n      };\n\n      m.prototype.renderMark = function (a, c, f) {\n        var d = this.axis,\n            m = d.options,\n            v = d.chart.renderer,\n            z = this.type,\n            u = d.tickSize(z ? z + \"Tick\" : \"tick\"),\n            k = a.x;\n        a = a.y;\n        var w = n(m[\"minor\" !== z ? \"tickWidth\" : \"minorTickWidth\"], !z && d.isXAxis ? 1 : 0);\n        m = m[\"minor\" !== z ? \"tickColor\" : \"minorTickColor\"];\n        var l = this.mark,\n            e = !l;\n        u && (d.opposite && (u[0] = -u[0]), l || (this.mark = l = v.path().addClass(\"highcharts-\" + (z ? z + \"-\" : \"\") + \"tick\").add(d.axisGroup), d.chart.styledMode || l.attr({\n          stroke: m,\n          \"stroke-width\": w\n        })), l[e ? \"attr\" : \"animate\"]({\n          d: this.getMarkPath(k, a, u[0], l.strokeWidth() * f, d.horiz, v),\n          opacity: c\n        }));\n      };\n\n      m.prototype.renderLabel = function (a, c, d, m) {\n        var p = this.axis,\n            v = p.horiz,\n            z = p.options,\n            u = this.label,\n            k = z.labels,\n            w = k.step;\n        p = n(this.tickmarkOffset, p.tickmarkOffset);\n        var l = a.x;\n        a = a.y;\n        var e = !0;\n        u && f(l) && (u.xy = a = this.getLabelPosition(l, a, u, v, k, p, m, w), this.isFirst && !this.isLast && !z.showFirstLabel || this.isLast && !this.isFirst && !z.showLastLabel ? e = !1 : !v || k.step || k.rotation || c || 0 === d || this.handleOverflow(a), w && m % w && (e = !1), e && f(a.y) ? (a.opacity = d, u[this.isNewLabel ? \"attr\" : \"animate\"](a), this.isNewLabel = !1) : (u.attr(\"y\", -9999), this.isNewLabel = !0));\n      };\n\n      m.prototype.replaceMovedLabel = function () {\n        var a = this.label,\n            c = this.axis,\n            f = c.reversed;\n\n        if (a && !this.isNew) {\n          var n = c.horiz ? f ? c.left : c.width + c.left : a.xy.x;\n          f = c.horiz ? a.xy.y : f ? c.width + c.top : c.top;\n          a.animate({\n            x: n,\n            y: f,\n            opacity: 0\n          }, void 0, a.destroy);\n          delete this.label;\n        }\n\n        c.isDirty = !0;\n        this.label = this.movedLabel;\n        delete this.movedLabel;\n      };\n\n      return m;\n    }();\n\n    \"\";\n    return h;\n  });\n  N(h, \"Core/Axis/Axis.js\", [h[\"Core/Animation/AnimationUtilities.js\"], h[\"Core/Axis/AxisDefaults.js\"], h[\"Core/Color/Color.js\"], h[\"Core/DefaultOptions.js\"], h[\"Core/Foundation.js\"], h[\"Core/Globals.js\"], h[\"Core/Axis/Tick.js\"], h[\"Core/Utilities.js\"]], function (d, h, A, F, t, G, H, y) {\n    var q = d.animObject,\n        p = F.defaultOptions,\n        f = t.registerEventOptions,\n        c = G.deg2rad,\n        a = y.arrayMax,\n        n = y.arrayMin,\n        m = y.clamp,\n        D = y.correctFloat,\n        C = y.defined,\n        I = y.destroyObjectProperties,\n        L = y.erase,\n        K = y.error,\n        v = y.extend,\n        z = y.fireEvent,\n        u = y.getMagnitude,\n        k = y.isArray,\n        w = y.isNumber,\n        l = y.isString,\n        e = y.merge,\n        g = y.normalizeTickInterval,\n        b = y.objectEach,\n        B = y.pick,\n        J = y.relativeLength,\n        r = y.removeEvent,\n        x = y.splat,\n        M = y.syncTimeout;\n\n    d = function () {\n      function d(b, e) {\n        this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.height = this.hasVisibleSeries = this.hasNames = this.eventOptions = this.coll = this.closestPointRange = this.chart = this.categories = this.bottom = this.alternateBands = void 0;\n        this.init(b, e);\n      }\n\n      d.prototype.init = function (b, e) {\n        var g = e.isX;\n        this.chart = b;\n        this.horiz = b.inverted && !this.isZAxis ? !g : g;\n        this.isXAxis = g;\n        this.coll = this.coll || (g ? \"xAxis\" : \"yAxis\");\n        z(this, \"init\", {\n          userOptions: e\n        });\n        this.opposite = B(e.opposite, this.opposite);\n        this.side = B(e.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);\n        this.setOptions(e);\n        var a = this.options,\n            l = a.labels,\n            k = a.type;\n        this.userOptions = e;\n        this.minPixelPadding = 0;\n        this.reversed = B(a.reversed, this.reversed);\n        this.visible = a.visible;\n        this.zoomEnabled = a.zoomEnabled;\n        this.hasNames = \"category\" === k || !0 === a.categories;\n        this.categories = a.categories || this.hasNames;\n        this.names || (this.names = [], this.names.keys = {});\n        this.plotLinesAndBandsGroups = {};\n        this.positiveValuesOnly = !!this.logarithmic;\n        this.isLinked = C(a.linkedTo);\n        this.ticks = {};\n        this.labelEdge = [];\n        this.minorTicks = {};\n        this.plotLinesAndBands = [];\n        this.alternateBands = {};\n        this.len = 0;\n        this.minRange = this.userMinRange = a.minRange || a.maxZoom;\n        this.range = a.range;\n        this.offset = a.offset || 0;\n        this.min = this.max = null;\n        e = B(a.crosshair, x(b.options.tooltip.crosshairs)[g ? 0 : 1]);\n        this.crosshair = !0 === e ? {} : e;\n        -1 === b.axes.indexOf(this) && (g ? b.axes.splice(b.xAxis.length, 0, this) : b.axes.push(this), b[this.coll].push(this));\n        this.series = this.series || [];\n        b.inverted && !this.isZAxis && g && \"undefined\" === typeof this.reversed && (this.reversed = !0);\n        this.labelRotation = w(l.rotation) ? l.rotation : void 0;\n        f(this, a);\n        z(this, \"afterInit\");\n      };\n\n      d.prototype.setOptions = function (b) {\n        this.options = e(h.defaultXAxisOptions, \"yAxis\" === this.coll && h.defaultYAxisOptions, [h.defaultTopAxisOptions, h.defaultRightAxisOptions, h.defaultBottomAxisOptions, h.defaultLeftAxisOptions][this.side], e(p[this.coll], b));\n        z(this, \"afterSetOptions\", {\n          userOptions: b\n        });\n      };\n\n      d.prototype.defaultLabelFormatter = function (b) {\n        var e = this.axis;\n        b = this.chart.numberFormatter;\n        var g = w(this.value) ? this.value : NaN,\n            a = e.chart.time,\n            l = this.dateTimeLabelFormat,\n            k = p.lang,\n            c = k.numericSymbols;\n        k = k.numericSymbolMagnitude || 1E3;\n        var r = e.logarithmic ? Math.abs(g) : e.tickInterval,\n            f = c && c.length;\n        if (e.categories) var x = \"\" + this.value;else if (l) x = a.dateFormat(l, g);else if (f && 1E3 <= r) for (; f-- && \"undefined\" === typeof x;) e = Math.pow(k, f + 1), r >= e && 0 === 10 * g % e && null !== c[f] && 0 !== g && (x = b(g / e, -1) + c[f]);\n        \"undefined\" === typeof x && (x = 1E4 <= Math.abs(g) ? b(g, -1) : b(g, -1, void 0, \"\"));\n        return x;\n      };\n\n      d.prototype.getSeriesExtremes = function () {\n        var b = this,\n            e = b.chart,\n            g;\n        z(this, \"getSeriesExtremes\", null, function () {\n          b.hasVisibleSeries = !1;\n          b.dataMin = b.dataMax = b.threshold = null;\n          b.softThreshold = !b.isXAxis;\n          b.stacking && b.stacking.buildStacks();\n          b.series.forEach(function (a) {\n            if (a.visible || !e.options.chart.ignoreHiddenSeries) {\n              var l = a.options,\n                  k = l.threshold;\n              b.hasVisibleSeries = !0;\n              b.positiveValuesOnly && 0 >= k && (k = null);\n\n              if (b.isXAxis) {\n                if (l = a.xData, l.length) {\n                  l = b.logarithmic ? l.filter(b.validatePositiveValue) : l;\n                  g = a.getXExtremes(l);\n                  var c = g.min;\n                  var r = g.max;\n                  w(c) || c instanceof Date || (l = l.filter(w), g = a.getXExtremes(l), c = g.min, r = g.max);\n                  l.length && (b.dataMin = Math.min(B(b.dataMin, c), c), b.dataMax = Math.max(B(b.dataMax, r), r));\n                }\n              } else if (a = a.applyExtremes(), w(a.dataMin) && (c = a.dataMin, b.dataMin = Math.min(B(b.dataMin, c), c)), w(a.dataMax) && (r = a.dataMax, b.dataMax = Math.max(B(b.dataMax, r), r)), C(k) && (b.threshold = k), !l.softThreshold || b.positiveValuesOnly) b.softThreshold = !1;\n            }\n          });\n        });\n        z(this, \"afterGetSeriesExtremes\");\n      };\n\n      d.prototype.translate = function (b, e, g, a, l, k) {\n        var c = this.linkedParent || this,\n            r = a && c.old ? c.old.min : c.min,\n            f = c.minPixelPadding;\n        l = (c.isOrdinal || c.brokenAxis && c.brokenAxis.hasBreaks || c.logarithmic && l) && c.lin2val;\n        var x = 1,\n            B = 0;\n        a = a && c.old ? c.old.transA : c.transA;\n        a || (a = c.transA);\n        g && (x *= -1, B = c.len);\n        c.reversed && (x *= -1, B -= x * (c.sector || c.len));\n        e ? (b = (b * x + B - f) / a + r, l && (b = c.lin2val(b))) : (l && (b = c.val2lin(b)), b = w(r) ? x * (b - r) * a + B + x * f + (w(k) ? a * k : 0) : void 0);\n        return b;\n      };\n\n      d.prototype.toPixels = function (b, e) {\n        return this.translate(b, !1, !this.horiz, null, !0) + (e ? 0 : this.pos);\n      };\n\n      d.prototype.toValue = function (b, e) {\n        return this.translate(b - (e ? 0 : this.pos), !0, !this.horiz, null, !0);\n      };\n\n      d.prototype.getPlotLinePath = function (b) {\n        function e(b, e, g) {\n          if (\"pass\" !== n && b < e || b > g) n ? b = m(b, e, g) : h = !0;\n          return b;\n        }\n\n        var g = this,\n            a = g.chart,\n            l = g.left,\n            k = g.top,\n            c = b.old,\n            r = b.value,\n            f = b.lineWidth,\n            x = c && a.oldChartHeight || a.chartHeight,\n            u = c && a.oldChartWidth || a.chartWidth,\n            d = g.transB,\n            J = b.translatedValue,\n            n = b.force,\n            P,\n            v,\n            p,\n            M,\n            h;\n        b = {\n          value: r,\n          lineWidth: f,\n          old: c,\n          force: n,\n          acrossPanes: b.acrossPanes,\n          translatedValue: J\n        };\n        z(this, \"getPlotLinePath\", b, function (b) {\n          J = B(J, g.translate(r, null, null, c));\n          J = m(J, -1E5, 1E5);\n          P = p = Math.round(J + d);\n          v = M = Math.round(x - J - d);\n          w(J) ? g.horiz ? (v = k, M = x - g.bottom, P = p = e(P, l, l + g.width)) : (P = l, p = u - g.right, v = M = e(v, k, k + g.height)) : (h = !0, n = !1);\n          b.path = h && !n ? null : a.renderer.crispLine([[\"M\", P, v], [\"L\", p, M]], f || 1);\n        });\n        return b.path;\n      };\n\n      d.prototype.getLinearTickPositions = function (b, e, g) {\n        var a = D(Math.floor(e / b) * b);\n        g = D(Math.ceil(g / b) * b);\n        var l = [],\n            k;\n        D(a + b) === a && (k = 20);\n        if (this.single) return [e];\n\n        for (e = a; e <= g;) {\n          l.push(e);\n          e = D(e + b, k);\n          if (e === c) break;\n          var c = e;\n        }\n\n        return l;\n      };\n\n      d.prototype.getMinorTickInterval = function () {\n        var b = this.options;\n        return !0 === b.minorTicks ? B(b.minorTickInterval, \"auto\") : !1 === b.minorTicks ? null : b.minorTickInterval;\n      };\n\n      d.prototype.getMinorTickPositions = function () {\n        var b = this.options,\n            e = this.tickPositions,\n            g = this.minorTickInterval,\n            a = this.pointRangePadding || 0,\n            l = this.min - a;\n        a = this.max + a;\n        var k = a - l,\n            c = [];\n\n        if (k && k / g < this.len / 3) {\n          var r = this.logarithmic;\n          if (r) this.paddedTicks.forEach(function (b, e, a) {\n            e && c.push.apply(c, r.getLogTickPositions(g, a[e - 1], a[e], !0));\n          });else if (this.dateTime && \"auto\" === this.getMinorTickInterval()) c = c.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(g), l, a, b.startOfWeek));else for (b = l + (e[0] - l) % g; b <= a && b !== c[0]; b += g) c.push(b);\n        }\n\n        0 !== c.length && this.trimTicks(c);\n        return c;\n      };\n\n      d.prototype.adjustForMinRange = function () {\n        var b = this.options,\n            e = this.logarithmic,\n            g = this.min,\n            l = this.max,\n            k = 0,\n            c,\n            r,\n            f,\n            x;\n        this.isXAxis && \"undefined\" === typeof this.minRange && !e && (C(b.min) || C(b.max) || C(b.floor) || C(b.ceiling) ? this.minRange = null : (this.series.forEach(function (b) {\n          f = b.xData;\n          x = b.xIncrement ? 1 : f.length - 1;\n          if (1 < f.length) for (c = x; 0 < c; c--) if (r = f[c] - f[c - 1], !k || r < k) k = r;\n        }), this.minRange = Math.min(5 * k, this.dataMax - this.dataMin)));\n\n        if (l - g < this.minRange) {\n          var u = this.dataMax - this.dataMin >= this.minRange;\n          var d = this.minRange;\n          var w = (d - l + g) / 2;\n          w = [g - w, B(b.min, g - w)];\n          u && (w[2] = this.logarithmic ? this.logarithmic.log2lin(this.dataMin) : this.dataMin);\n          g = a(w);\n          l = [g + d, B(b.max, g + d)];\n          u && (l[2] = e ? e.log2lin(this.dataMax) : this.dataMax);\n          l = n(l);\n          l - g < d && (w[0] = l - d, w[1] = B(b.min, l - d), g = a(w));\n        }\n\n        this.min = g;\n        this.max = l;\n      };\n\n      d.prototype.getClosest = function () {\n        var b;\n        this.categories ? b = 1 : this.series.forEach(function (e) {\n          var g = e.closestPointRange,\n              a = e.visible || !e.chart.options.chart.ignoreHiddenSeries;\n          !e.noSharedTooltip && C(g) && a && (b = C(b) ? Math.min(b, g) : g);\n        });\n        return b;\n      };\n\n      d.prototype.nameToX = function (b) {\n        var e = k(this.categories),\n            g = e ? this.categories : this.names,\n            a = b.options.x;\n        b.series.requireSorting = !1;\n        C(a) || (a = this.options.uniqueNames ? e ? g.indexOf(b.name) : B(g.keys[b.name], -1) : b.series.autoIncrement());\n\n        if (-1 === a) {\n          if (!e) var l = g.length;\n        } else l = a;\n\n        \"undefined\" !== typeof l && (this.names[l] = b.name, this.names.keys[b.name] = l);\n        return l;\n      };\n\n      d.prototype.updateNames = function () {\n        var b = this,\n            e = this.names;\n        0 < e.length && (Object.keys(e.keys).forEach(function (b) {\n          delete e.keys[b];\n        }), e.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (e) {\n          e.xIncrement = null;\n          if (!e.points || e.isDirtyData) b.max = Math.max(b.max, e.xData.length - 1), e.processData(), e.generatePoints();\n          e.data.forEach(function (g, a) {\n            if (g && g.options && \"undefined\" !== typeof g.name) {\n              var l = b.nameToX(g);\n              \"undefined\" !== typeof l && l !== g.x && (g.x = l, e.xData[a] = l);\n            }\n          });\n        }));\n      };\n\n      d.prototype.setAxisTranslation = function () {\n        var b = this,\n            e = b.max - b.min,\n            g = b.linkedParent,\n            a = !!b.categories,\n            k = b.isXAxis,\n            c = b.axisPointRange || 0,\n            r = 0,\n            f = 0,\n            x = b.transA;\n\n        if (k || a || c) {\n          var u = b.getClosest();\n          g ? (r = g.minPointOffset, f = g.pointRangePadding) : b.series.forEach(function (e) {\n            var g = a ? 1 : k ? B(e.options.pointRange, u, 0) : b.axisPointRange || 0,\n                x = e.options.pointPlacement;\n            c = Math.max(c, g);\n            if (!b.single || a) e = e.is(\"xrange\") ? !k : k, r = Math.max(r, e && l(x) ? 0 : g / 2), f = Math.max(f, e && \"on\" === x ? 0 : g);\n          });\n          g = b.ordinal && b.ordinal.slope && u ? b.ordinal.slope / u : 1;\n          b.minPointOffset = r *= g;\n          b.pointRangePadding = f *= g;\n          b.pointRange = Math.min(c, b.single && a ? 1 : e);\n          k && (b.closestPointRange = u);\n        }\n\n        b.translationSlope = b.transA = x = b.staticScale || b.len / (e + f || 1);\n        b.transB = b.horiz ? b.left : b.bottom;\n        b.minPixelPadding = x * r;\n        z(this, \"afterSetAxisTranslation\");\n      };\n\n      d.prototype.minFromRange = function () {\n        return this.max - this.range;\n      };\n\n      d.prototype.setTickInterval = function (b) {\n        var e = this.chart,\n            a = this.logarithmic,\n            l = this.options,\n            k = this.isXAxis,\n            c = this.isLinked,\n            r = l.tickPixelInterval,\n            f = this.categories,\n            x = this.softThreshold,\n            d = l.maxPadding,\n            J = l.minPadding,\n            n = w(l.tickInterval) && 0 <= l.tickInterval ? l.tickInterval : void 0,\n            m = w(this.threshold) ? this.threshold : null;\n        this.dateTime || f || c || this.getTickAmount();\n        var P = B(this.userMin, l.min);\n        var v = B(this.userMax, l.max);\n\n        if (c) {\n          this.linkedParent = e[this.coll][l.linkedTo];\n          var p = this.linkedParent.getExtremes();\n          this.min = B(p.min, p.dataMin);\n          this.max = B(p.max, p.dataMax);\n          l.type !== this.linkedParent.options.type && K(11, 1, e);\n        } else {\n          if (x && C(m)) if (this.dataMin >= m) p = m, J = 0;else if (this.dataMax <= m) {\n            var M = m;\n            d = 0;\n          }\n          this.min = B(P, p, this.dataMin);\n          this.max = B(v, M, this.dataMax);\n        }\n\n        a && (this.positiveValuesOnly && !b && 0 >= Math.min(this.min, B(this.dataMin, this.min)) && K(10, 1, e), this.min = D(a.log2lin(this.min), 16), this.max = D(a.log2lin(this.max), 16));\n        this.range && C(this.max) && (this.userMin = this.min = P = Math.max(this.dataMin, this.minFromRange()), this.userMax = v = this.max, this.range = null);\n        z(this, \"foundExtremes\");\n        this.beforePadding && this.beforePadding();\n        this.adjustForMinRange();\n        !(f || this.axisPointRange || this.stacking && this.stacking.usePercentage || c) && C(this.min) && C(this.max) && (e = this.max - this.min) && (!C(P) && J && (this.min -= e * J), !C(v) && d && (this.max += e * d));\n        w(this.userMin) || (w(l.softMin) && l.softMin < this.min && (this.min = P = l.softMin), w(l.floor) && (this.min = Math.max(this.min, l.floor)));\n        w(this.userMax) || (w(l.softMax) && l.softMax > this.max && (this.max = v = l.softMax), w(l.ceiling) && (this.max = Math.min(this.max, l.ceiling)));\n        x && C(this.dataMin) && (m = m || 0, !C(P) && this.min < m && this.dataMin >= m ? this.min = this.options.minRange ? Math.min(m, this.max - this.minRange) : m : !C(v) && this.max > m && this.dataMax <= m && (this.max = this.options.minRange ? Math.max(m, this.min + this.minRange) : m));\n        w(this.min) && w(this.max) && !this.chart.polar && this.min > this.max && (C(this.options.min) ? this.max = this.min : C(this.options.max) && (this.min = this.max));\n        this.tickInterval = this.min === this.max || \"undefined\" === typeof this.min || \"undefined\" === typeof this.max ? 1 : c && this.linkedParent && !n && r === this.linkedParent.options.tickPixelInterval ? n = this.linkedParent.tickInterval : B(n, this.tickAmount ? (this.max - this.min) / Math.max(this.tickAmount - 1, 1) : void 0, f ? 1 : (this.max - this.min) * r / Math.max(this.len, r));\n\n        if (k && !b) {\n          var h = this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max);\n          this.series.forEach(function (b) {\n            b.forceCrop = b.forceCropping && b.forceCropping();\n            b.processData(h);\n          });\n          z(this, \"postProcessData\", {\n            hasExtemesChanged: h\n          });\n        }\n\n        this.setAxisTranslation();\n        z(this, \"initialAxisTranslation\");\n        this.pointRange && !n && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));\n        b = B(l.minTickInterval, this.dateTime && !this.series.some(function (b) {\n          return b.noSharedTooltip;\n        }) ? this.closestPointRange : 0);\n        !n && this.tickInterval < b && (this.tickInterval = b);\n        this.dateTime || this.logarithmic || n || (this.tickInterval = g(this.tickInterval, void 0, u(this.tickInterval), B(l.allowDecimals, .5 > this.tickInterval || void 0 !== this.tickAmount), !!this.tickAmount));\n        this.tickAmount || (this.tickInterval = this.unsquish());\n        this.setTickPositions();\n      };\n\n      d.prototype.setTickPositions = function () {\n        var b = this.options,\n            e = b.tickPositions,\n            g = this.getMinorTickInterval(),\n            a = this.hasVerticalPanning(),\n            l = \"colorAxis\" === this.coll,\n            k = (l || !a) && b.startOnTick;\n        a = (l || !a) && b.endOnTick;\n        l = b.tickPositioner;\n        this.tickmarkOffset = this.categories && \"between\" === b.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;\n        this.minorTickInterval = \"auto\" === g && this.tickInterval ? this.tickInterval / 5 : g;\n        this.single = this.min === this.max && C(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== b.allowDecimals);\n        this.tickPositions = g = e && e.slice();\n        !g && (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) ? g = this.dateTime ? this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, b.units), this.min, this.max, b.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0) : this.logarithmic ? this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max) : (g = [this.min, this.max], K(19, !1, this.chart)), g.length > this.len && (g = [g[0], g.pop()], g[0] === g[1] && (g.length = 1)), this.tickPositions = g, l && (l = l.apply(this, [this.min, this.max]))) && (this.tickPositions = g = l);\n        this.paddedTicks = g.slice(0);\n        this.trimTicks(g, k, a);\n        this.isLinked || (this.single && 2 > g.length && !this.categories && !this.series.some(function (b) {\n          return b.is(\"heatmap\") && \"between\" === b.options.pointPlacement;\n        }) && (this.min -= .5, this.max += .5), e || l || this.adjustTickAmount());\n        z(this, \"afterSetTickPositions\");\n      };\n\n      d.prototype.trimTicks = function (b, e, g) {\n        var a = b[0],\n            l = b[b.length - 1],\n            k = !this.isOrdinal && this.minPointOffset || 0;\n        z(this, \"trimTicks\");\n\n        if (!this.isLinked) {\n          if (e && -Infinity !== a) this.min = a;else for (; this.min - k > b[0];) b.shift();\n          if (g) this.max = l;else for (; this.max + k < b[b.length - 1];) b.pop();\n          0 === b.length && C(a) && !this.options.tickPositions && b.push((l + a) / 2);\n        }\n      };\n\n      d.prototype.alignToOthers = function () {\n        var b = {},\n            e = this.options,\n            g;\n        !1 !== this.chart.options.chart.alignTicks && e.alignTicks && !1 !== e.startOnTick && !1 !== e.endOnTick && !this.logarithmic && this.chart[this.coll].forEach(function (e) {\n          var a = e.options;\n          a = [e.horiz ? a.left : a.top, a.width, a.height, a.pane].join();\n          e.series.length && (b[a] ? g = !0 : b[a] = 1);\n        });\n        return g;\n      };\n\n      d.prototype.getTickAmount = function () {\n        var b = this.options,\n            e = b.tickPixelInterval,\n            g = b.tickAmount;\n        !C(b.tickInterval) && !g && this.len < e && !this.isRadial && !this.logarithmic && b.startOnTick && b.endOnTick && (g = 2);\n        !g && this.alignToOthers() && (g = Math.ceil(this.len / e) + 1);\n        4 > g && (this.finalTickAmt = g, g = 5);\n        this.tickAmount = g;\n      };\n\n      d.prototype.adjustTickAmount = function () {\n        var b = this.options,\n            e = this.tickInterval,\n            g = this.tickPositions,\n            a = this.tickAmount,\n            l = this.finalTickAmt,\n            k = g && g.length,\n            c = B(this.threshold, this.softThreshold ? 0 : null);\n\n        if (this.hasData() && w(this.min) && w(this.max)) {\n          if (k < a) {\n            for (; g.length < a;) g.length % 2 || this.min === c ? g.push(D(g[g.length - 1] + e)) : g.unshift(D(g[0] - e));\n\n            this.transA *= (k - 1) / (a - 1);\n            this.min = b.startOnTick ? g[0] : Math.min(this.min, g[0]);\n            this.max = b.endOnTick ? g[g.length - 1] : Math.max(this.max, g[g.length - 1]);\n          } else k > a && (this.tickInterval *= 2, this.setTickPositions());\n\n          if (C(l)) {\n            for (e = b = g.length; e--;) (3 === l && 1 === e % 2 || 2 >= l && 0 < e && e < b - 1) && g.splice(e, 1);\n\n            this.finalTickAmt = void 0;\n          }\n        }\n      };\n\n      d.prototype.setScale = function () {\n        var b = !1,\n            e = !1;\n        this.series.forEach(function (g) {\n          b = b || g.isDirtyData || g.isDirty;\n          e = e || g.xAxis && g.xAxis.isDirty || !1;\n        });\n        this.setAxisSize();\n        var g = this.len !== (this.old && this.old.len);\n        g || b || e || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (this.stacking && this.stacking.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = g || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : this.stacking && this.stacking.cleanStacks();\n        b && this.panningState && (this.panningState.isDirty = !0);\n        z(this, \"afterSetScale\");\n      };\n\n      d.prototype.setExtremes = function (b, e, g, a, l) {\n        var k = this,\n            c = k.chart;\n        g = B(g, !0);\n        k.series.forEach(function (b) {\n          delete b.kdTree;\n        });\n        l = v(l, {\n          min: b,\n          max: e\n        });\n        z(k, \"setExtremes\", l, function () {\n          k.userMin = b;\n          k.userMax = e;\n          k.eventArgs = l;\n          g && c.redraw(a);\n        });\n      };\n\n      d.prototype.zoom = function (b, e) {\n        var g = this,\n            a = this.dataMin,\n            l = this.dataMax,\n            k = this.options,\n            c = Math.min(a, B(k.min, a)),\n            r = Math.max(l, B(k.max, l));\n        b = {\n          newMin: b,\n          newMax: e\n        };\n        z(this, \"zoom\", b, function (b) {\n          var e = b.newMin,\n              k = b.newMax;\n          if (e !== g.min || k !== g.max) g.allowZoomOutside || (C(a) && (e < c && (e = c), e > r && (e = r)), C(l) && (k < c && (k = c), k > r && (k = r))), g.displayBtn = \"undefined\" !== typeof e || \"undefined\" !== typeof k, g.setExtremes(e, k, !1, void 0, {\n            trigger: \"zoom\"\n          });\n          b.zoomed = !0;\n        });\n        return b.zoomed;\n      };\n\n      d.prototype.setAxisSize = function () {\n        var b = this.chart,\n            e = this.options,\n            g = e.offsets || [0, 0, 0, 0],\n            a = this.horiz,\n            l = this.width = Math.round(J(B(e.width, b.plotWidth - g[3] + g[1]), b.plotWidth)),\n            k = this.height = Math.round(J(B(e.height, b.plotHeight - g[0] + g[2]), b.plotHeight)),\n            c = this.top = Math.round(J(B(e.top, b.plotTop + g[0]), b.plotHeight, b.plotTop));\n        e = this.left = Math.round(J(B(e.left, b.plotLeft + g[3]), b.plotWidth, b.plotLeft));\n        this.bottom = b.chartHeight - k - c;\n        this.right = b.chartWidth - l - e;\n        this.len = Math.max(a ? l : k, 0);\n        this.pos = a ? e : c;\n      };\n\n      d.prototype.getExtremes = function () {\n        var b = this.logarithmic;\n        return {\n          min: b ? D(b.lin2log(this.min)) : this.min,\n          max: b ? D(b.lin2log(this.max)) : this.max,\n          dataMin: this.dataMin,\n          dataMax: this.dataMax,\n          userMin: this.userMin,\n          userMax: this.userMax\n        };\n      };\n\n      d.prototype.getThreshold = function (b) {\n        var e = this.logarithmic,\n            g = e ? e.lin2log(this.min) : this.min;\n        e = e ? e.lin2log(this.max) : this.max;\n        null === b || -Infinity === b ? b = g : Infinity === b ? b = e : g > b ? b = g : e < b && (b = e);\n        return this.translate(b, 0, 1, 0, 1);\n      };\n\n      d.prototype.autoLabelAlign = function (b) {\n        var e = (B(b, 0) - 90 * this.side + 720) % 360;\n        b = {\n          align: \"center\"\n        };\n        z(this, \"autoLabelAlign\", b, function (b) {\n          15 < e && 165 > e ? b.align = \"right\" : 195 < e && 345 > e && (b.align = \"left\");\n        });\n        return b.align;\n      };\n\n      d.prototype.tickSize = function (b) {\n        var e = this.options,\n            g = B(e[\"tick\" === b ? \"tickWidth\" : \"minorTickWidth\"], \"tick\" === b && this.isXAxis && !this.categories ? 1 : 0),\n            a = e[\"tick\" === b ? \"tickLength\" : \"minorTickLength\"];\n\n        if (g && a) {\n          \"inside\" === e[b + \"Position\"] && (a = -a);\n          var l = [a, g];\n        }\n\n        b = {\n          tickSize: l\n        };\n        z(this, \"afterTickSize\", b);\n        return b.tickSize;\n      };\n\n      d.prototype.labelMetrics = function () {\n        var b = this.tickPositions && this.tickPositions[0] || 0;\n        return this.chart.renderer.fontMetrics(this.options.labels.style.fontSize, this.ticks[b] && this.ticks[b].label);\n      };\n\n      d.prototype.unsquish = function () {\n        var b = this.options.labels,\n            e = this.horiz,\n            g = this.tickInterval,\n            a = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / g),\n            l = b.rotation,\n            k = this.labelMetrics(),\n            r = Math.max(this.max - this.min, 0),\n            f = function (b) {\n          var e = b / (a || 1);\n          e = 1 < e ? Math.ceil(e) : 1;\n          e * g > r && Infinity !== b && Infinity !== a && r && (e = Math.ceil(r / g));\n          return D(e * g);\n        },\n            x = g,\n            u,\n            d,\n            J = Number.MAX_VALUE;\n\n        if (e) {\n          if (!b.staggerLines && !b.step) if (w(l)) var n = [l];else a < b.autoRotationLimit && (n = b.autoRotation);\n          n && n.forEach(function (b) {\n            if (b === l || b && -90 <= b && 90 >= b) {\n              d = f(Math.abs(k.h / Math.sin(c * b)));\n              var e = d + Math.abs(b / 360);\n              e < J && (J = e, u = b, x = d);\n            }\n          });\n        } else b.step || (x = f(k.h));\n\n        this.autoRotation = n;\n        this.labelRotation = B(u, w(l) ? l : 0);\n        return x;\n      };\n\n      d.prototype.getSlotWidth = function (b) {\n        var e = this.chart,\n            g = this.horiz,\n            a = this.options.labels,\n            l = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n            k = e.margin[3];\n        if (b && w(b.slotWidth)) return b.slotWidth;\n        if (g && 2 > a.step) return a.rotation ? 0 : (this.staggerLines || 1) * this.len / l;\n\n        if (!g) {\n          b = a.style.width;\n          if (void 0 !== b) return parseInt(String(b), 10);\n          if (k) return k - e.spacing[3];\n        }\n\n        return .33 * e.chartWidth;\n      };\n\n      d.prototype.renderUnsquish = function () {\n        var b = this.chart,\n            e = b.renderer,\n            g = this.tickPositions,\n            a = this.ticks,\n            k = this.options.labels,\n            c = k.style,\n            r = this.horiz,\n            f = this.getSlotWidth(),\n            x = Math.max(1, Math.round(f - 2 * k.padding)),\n            B = {},\n            u = this.labelMetrics(),\n            d = c.textOverflow,\n            w = 0;\n        l(k.rotation) || (B.rotation = k.rotation || 0);\n        g.forEach(function (b) {\n          b = a[b];\n          b.movedLabel && b.replaceMovedLabel();\n          b && b.label && b.label.textPxLength > w && (w = b.label.textPxLength);\n        });\n        this.maxLabelLength = w;\n        if (this.autoRotation) w > x && w > u.h ? B.rotation = this.labelRotation : this.labelRotation = 0;else if (f) {\n          var J = x;\n\n          if (!d) {\n            var n = \"clip\";\n\n            for (x = g.length; !r && x--;) {\n              var m = g[x];\n              if (m = a[m].label) m.styles && \"ellipsis\" === m.styles.textOverflow ? m.css({\n                textOverflow: \"clip\"\n              }) : m.textPxLength > f && m.css({\n                width: f + \"px\"\n              }), m.getBBox().height > this.len / g.length - (u.h - u.f) && (m.specificTextOverflow = \"ellipsis\");\n            }\n          }\n        }\n        B.rotation && (J = w > .5 * b.chartHeight ? .33 * b.chartHeight : w, d || (n = \"ellipsis\"));\n        if (this.labelAlign = k.align || this.autoLabelAlign(this.labelRotation)) B.align = this.labelAlign;\n        g.forEach(function (b) {\n          var e = (b = a[b]) && b.label,\n              g = c.width,\n              l = {};\n          e && (e.attr(B), b.shortenLabel ? b.shortenLabel() : J && !g && \"nowrap\" !== c.whiteSpace && (J < e.textPxLength || \"SPAN\" === e.element.tagName) ? (l.width = J + \"px\", d || (l.textOverflow = e.specificTextOverflow || n), e.css(l)) : e.styles && e.styles.width && !l.width && !g && e.css({\n            width: null\n          }), delete e.specificTextOverflow, b.rotation = B.rotation);\n        }, this);\n        this.tickRotCorr = e.rotCorr(u.b, this.labelRotation || 0, 0 !== this.side);\n      };\n\n      d.prototype.hasData = function () {\n        return this.series.some(function (b) {\n          return b.hasData();\n        }) || this.options.showEmpty && C(this.min) && C(this.max);\n      };\n\n      d.prototype.addTitle = function (b) {\n        var g = this.chart.renderer,\n            a = this.horiz,\n            l = this.opposite,\n            k = this.options.title,\n            c = this.chart.styledMode,\n            r;\n        this.axisTitle || ((r = k.textAlign) || (r = (a ? {\n          low: \"left\",\n          middle: \"center\",\n          high: \"right\"\n        } : {\n          low: l ? \"right\" : \"left\",\n          middle: \"center\",\n          high: l ? \"left\" : \"right\"\n        })[k.align]), this.axisTitle = g.text(k.text || \"\", 0, 0, k.useHTML).attr({\n          zIndex: 7,\n          rotation: k.rotation,\n          align: r\n        }).addClass(\"highcharts-axis-title\"), c || this.axisTitle.css(e(k.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);\n        c || k.style.width || this.isRadial || this.axisTitle.css({\n          width: this.len + \"px\"\n        });\n        this.axisTitle[b ? \"show\" : \"hide\"](b);\n      };\n\n      d.prototype.generateTick = function (b) {\n        var e = this.ticks;\n        e[b] ? e[b].addLabel() : e[b] = new H(this, b);\n      };\n\n      d.prototype.getOffset = function () {\n        var e = this,\n            g = this,\n            a = g.chart,\n            l = g.horiz,\n            k = g.options,\n            c = g.side,\n            r = g.ticks,\n            f = g.tickPositions,\n            x = g.coll,\n            u = g.axisParent,\n            d = a.renderer,\n            w = a.inverted && !g.isZAxis ? [1, 0, 3, 2][c] : c,\n            J = g.hasData(),\n            n = k.title,\n            m = k.labels,\n            v = a.axisOffset;\n        a = a.clipOffset;\n        var p = [-1, 1, 1, -1][c],\n            M = k.className,\n            h,\n            q = 0,\n            I = 0,\n            D = 0;\n        g.showAxis = h = J || k.showEmpty;\n        g.staggerLines = g.horiz && m.staggerLines || void 0;\n\n        if (!g.axisGroup) {\n          var L = function (b, g, a) {\n            return d.g(b).attr({\n              zIndex: a\n            }).addClass(\"highcharts-\" + x.toLowerCase() + g + \" \" + (e.isRadial ? \"highcharts-radial-axis\" + g + \" \" : \"\") + (M || \"\")).add(u);\n          };\n\n          g.gridGroup = L(\"grid\", \"-grid\", k.gridZIndex);\n          g.axisGroup = L(\"axis\", \"\", k.zIndex);\n          g.labelGroup = L(\"axis-labels\", \"-labels\", m.zIndex);\n        }\n\n        J || g.isLinked ? (f.forEach(function (b) {\n          g.generateTick(b);\n        }), g.renderUnsquish(), g.reserveSpaceDefault = 0 === c || 2 === c || {\n          1: \"left\",\n          3: \"right\"\n        }[c] === g.labelAlign, B(m.reserveSpace, \"center\" === g.labelAlign ? !0 : null, g.reserveSpaceDefault) && f.forEach(function (b) {\n          D = Math.max(r[b].getLabelSize(), D);\n        }), g.staggerLines && (D *= g.staggerLines), g.labelOffset = D * (g.opposite ? -1 : 1)) : b(r, function (b, e) {\n          b.destroy();\n          delete r[e];\n        });\n\n        if (n && n.text && !1 !== n.enabled && (g.addTitle(h), h && !1 !== n.reserveSpace)) {\n          g.titleOffset = q = g.axisTitle.getBBox()[l ? \"height\" : \"width\"];\n          var K = n.offset;\n          I = C(K) ? 0 : B(n.margin, l ? 5 : 10);\n        }\n\n        g.renderLine();\n        g.offset = p * B(k.offset, v[c] ? v[c] + (k.margin || 0) : 0);\n        g.tickRotCorr = g.tickRotCorr || {\n          x: 0,\n          y: 0\n        };\n        n = 0 === c ? -g.labelMetrics().h : 2 === c ? g.tickRotCorr.y : 0;\n        J = Math.abs(D) + I;\n        D && (J = J - n + p * (l ? B(m.y, g.tickRotCorr.y + 8 * p) : m.x));\n        g.axisTitleMargin = B(K, J);\n        g.getMaxLabelDimensions && (g.maxLabelDimensions = g.getMaxLabelDimensions(r, f));\n        \"colorAxis\" !== x && (l = this.tickSize(\"tick\"), v[c] = Math.max(v[c], (g.axisTitleMargin || 0) + q + p * g.offset, J, f && f.length && l ? l[0] + p * g.offset : 0), k = !g.axisLine || k.offset ? 0 : 2 * Math.floor(g.axisLine.strokeWidth() / 2), a[w] = Math.max(a[w], k));\n        z(this, \"afterGetOffset\");\n      };\n\n      d.prototype.getLinePath = function (b) {\n        var e = this.chart,\n            g = this.opposite,\n            a = this.offset,\n            l = this.horiz,\n            k = this.left + (g ? this.width : 0) + a;\n        a = e.chartHeight - this.bottom - (g ? this.height : 0) + a;\n        g && (b *= -1);\n        return e.renderer.crispLine([[\"M\", l ? this.left : k, l ? a : this.top], [\"L\", l ? e.chartWidth - this.right : k, l ? a : e.chartHeight - this.bottom]], b);\n      };\n\n      d.prototype.renderLine = function () {\n        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({\n          stroke: this.options.lineColor,\n          \"stroke-width\": this.options.lineWidth,\n          zIndex: 7\n        }));\n      };\n\n      d.prototype.getTitlePosition = function () {\n        var b = this.horiz,\n            e = this.left,\n            g = this.top,\n            a = this.len,\n            l = this.options.title,\n            k = b ? e : g,\n            c = this.opposite,\n            r = this.offset,\n            f = l.x,\n            x = l.y,\n            B = this.axisTitle,\n            u = this.chart.renderer.fontMetrics(l.style.fontSize, B);\n        B = Math.max(B.getBBox(null, 0).height - u.h - 1, 0);\n        a = {\n          low: k + (b ? 0 : a),\n          middle: k + a / 2,\n          high: k + (b ? a : 0)\n        }[l.align];\n        e = (b ? g + this.height : e) + (b ? 1 : -1) * (c ? -1 : 1) * this.axisTitleMargin + [-B, B, u.f, -B][this.side];\n        b = {\n          x: b ? a + f : e + (c ? this.width : 0) + r + f,\n          y: b ? e + x - (c ? this.height : 0) + r : a + x\n        };\n        z(this, \"afterGetTitlePosition\", {\n          titlePosition: b\n        });\n        return b;\n      };\n\n      d.prototype.renderMinorTick = function (b, e) {\n        var g = this.minorTicks;\n        g[b] || (g[b] = new H(this, b, \"minor\"));\n        e && g[b].isNew && g[b].render(null, !0);\n        g[b].render(null, !1, 1);\n      };\n\n      d.prototype.renderTick = function (b, e, g) {\n        var a = this.ticks;\n        if (!this.isLinked || b >= this.min && b <= this.max || this.grid && this.grid.isColumn) a[b] || (a[b] = new H(this, b)), g && a[b].isNew && a[b].render(e, !0, -1), a[b].render(e);\n      };\n\n      d.prototype.render = function () {\n        var e = this,\n            g = e.chart,\n            a = e.logarithmic,\n            l = e.options,\n            k = e.isLinked,\n            c = e.tickPositions,\n            r = e.axisTitle,\n            f = e.ticks,\n            x = e.minorTicks,\n            B = e.alternateBands,\n            u = l.stackLabels,\n            d = l.alternateGridColor,\n            J = e.tickmarkOffset,\n            n = e.axisLine,\n            m = e.showAxis,\n            v = q(g.renderer.globalAnimation),\n            p,\n            h;\n        e.labelEdge.length = 0;\n        e.overlap = !1;\n        [f, x, B].forEach(function (e) {\n          b(e, function (b) {\n            b.isActive = !1;\n          });\n        });\n\n        if (e.hasData() || k) {\n          var C = e.chart.hasRendered && e.old && w(e.old.min);\n          e.minorTickInterval && !e.categories && e.getMinorTickPositions().forEach(function (b) {\n            e.renderMinorTick(b, C);\n          });\n          c.length && (c.forEach(function (b, g) {\n            e.renderTick(b, g, C);\n          }), J && (0 === e.min || e.single) && (f[-1] || (f[-1] = new H(e, -1, null, !0)), f[-1].render(-1)));\n          d && c.forEach(function (b, l) {\n            h = \"undefined\" !== typeof c[l + 1] ? c[l + 1] + J : e.max - J;\n            0 === l % 2 && b < e.max && h <= e.max + (g.polar ? -J : J) && (B[b] || (B[b] = new G.PlotLineOrBand(e)), p = b + J, B[b].options = {\n              from: a ? a.lin2log(p) : p,\n              to: a ? a.lin2log(h) : h,\n              color: d,\n              className: \"highcharts-alternate-grid\"\n            }, B[b].render(), B[b].isActive = !0);\n          });\n          e._addedPlotLB || (e._addedPlotLB = !0, (l.plotLines || []).concat(l.plotBands || []).forEach(function (b) {\n            e.addPlotBandOrLine(b);\n          }));\n        }\n\n        [f, x, B].forEach(function (e) {\n          var a = [],\n              l = v.duration;\n          b(e, function (b, e) {\n            b.isActive || (b.render(e, !1, 0), b.isActive = !1, a.push(e));\n          });\n          M(function () {\n            for (var b = a.length; b--;) e[a[b]] && !e[a[b]].isActive && (e[a[b]].destroy(), delete e[a[b]]);\n          }, e !== B && g.hasRendered && l ? l : 0);\n        });\n        n && (n[n.isPlaced ? \"animate\" : \"attr\"]({\n          d: this.getLinePath(n.strokeWidth())\n        }), n.isPlaced = !0, n[m ? \"show\" : \"hide\"](m));\n        r && m && (l = e.getTitlePosition(), w(l.y) ? (r[r.isNew ? \"attr\" : \"animate\"](l), r.isNew = !1) : (r.attr(\"y\", -9999), r.isNew = !0));\n        u && u.enabled && e.stacking && e.stacking.renderStackTotals();\n        e.old = {\n          len: e.len,\n          max: e.max,\n          min: e.min,\n          transA: e.transA,\n          userMax: e.userMax,\n          userMin: e.userMin\n        };\n        e.isDirty = !1;\n        z(this, \"afterRender\");\n      };\n\n      d.prototype.redraw = function () {\n        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (b) {\n          b.render();\n        }));\n        this.series.forEach(function (b) {\n          b.isDirty = !0;\n        });\n      };\n\n      d.prototype.getKeepProps = function () {\n        return this.keepProps || d.keepProps;\n      };\n\n      d.prototype.destroy = function (e) {\n        var g = this,\n            a = g.plotLinesAndBands,\n            l = this.eventOptions;\n        z(this, \"destroy\", {\n          keepEvents: e\n        });\n        e || r(g);\n        [g.ticks, g.minorTicks, g.alternateBands].forEach(function (b) {\n          I(b);\n        });\n        if (a) for (e = a.length; e--;) a[e].destroy();\n        \"axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar\".split(\" \").forEach(function (b) {\n          g[b] && (g[b] = g[b].destroy());\n        });\n\n        for (var k in g.plotLinesAndBandsGroups) g.plotLinesAndBandsGroups[k] = g.plotLinesAndBandsGroups[k].destroy();\n\n        b(g, function (b, e) {\n          -1 === g.getKeepProps().indexOf(e) && delete g[e];\n        });\n        this.eventOptions = l;\n      };\n\n      d.prototype.drawCrosshair = function (b, e) {\n        var g = this.crosshair,\n            a = B(g && g.snap, !0),\n            l = this.chart,\n            k,\n            c = this.cross;\n        z(this, \"drawCrosshair\", {\n          e: b,\n          point: e\n        });\n        b || (b = this.cross && this.cross.e);\n\n        if (g && !1 !== (C(e) || !a)) {\n          a ? C(e) && (k = B(\"colorAxis\" !== this.coll ? e.crosshairPos : null, this.isXAxis ? e.plotX : this.len - e.plotY)) : k = b && (this.horiz ? b.chartX - this.pos : this.len - b.chartY + this.pos);\n\n          if (C(k)) {\n            var r = {\n              value: e && (this.isXAxis ? e.x : B(e.stackY, e.y)),\n              translatedValue: k\n            };\n            l.polar && v(r, {\n              isCrosshair: !0,\n              chartX: b && b.chartX,\n              chartY: b && b.chartY,\n              point: e\n            });\n            r = this.getPlotLinePath(r) || null;\n          }\n\n          if (!C(r)) {\n            this.hideCrosshair();\n            return;\n          }\n\n          a = this.categories && !this.isRadial;\n          c || (this.cross = c = l.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (a ? \"category \" : \"thin \") + (g.className || \"\")).attr({\n            zIndex: B(g.zIndex, 2)\n          }).add(), l.styledMode || (c.attr({\n            stroke: g.color || (a ? A.parse(\"#ccd6eb\").setOpacity(.25).get() : \"#cccccc\"),\n            \"stroke-width\": B(g.width, 1)\n          }).css({\n            \"pointer-events\": \"none\"\n          }), g.dashStyle && c.attr({\n            dashstyle: g.dashStyle\n          })));\n          c.show().attr({\n            d: r\n          });\n          a && !g.width && c.attr({\n            \"stroke-width\": this.transA\n          });\n          this.cross.e = b;\n        } else this.hideCrosshair();\n\n        z(this, \"afterDrawCrosshair\", {\n          e: b,\n          point: e\n        });\n      };\n\n      d.prototype.hideCrosshair = function () {\n        this.cross && this.cross.hide();\n        z(this, \"afterHideCrosshair\");\n      };\n\n      d.prototype.hasVerticalPanning = function () {\n        var b = this.chart.options.chart.panning;\n        return !!(b && b.enabled && /y/.test(b.type));\n      };\n\n      d.prototype.validatePositiveValue = function (b) {\n        return w(b) && 0 < b;\n      };\n\n      d.prototype.update = function (b, g) {\n        var a = this.chart;\n        b = e(this.userOptions, b);\n        this.destroy(!0);\n        this.init(a, b);\n        a.isDirtyBox = !0;\n        B(g, !0) && a.redraw();\n      };\n\n      d.prototype.remove = function (b) {\n        for (var e = this.chart, g = this.coll, a = this.series, l = a.length; l--;) a[l] && a[l].remove(!1);\n\n        L(e.axes, this);\n        L(e[g], this);\n        e[g].forEach(function (b, e) {\n          b.options.index = b.userOptions.index = e;\n        });\n        this.destroy();\n        e.isDirtyBox = !0;\n        B(b, !0) && e.redraw();\n      };\n\n      d.prototype.setTitle = function (b, e) {\n        this.update({\n          title: b\n        }, e);\n      };\n\n      d.prototype.setCategories = function (b, e) {\n        this.update({\n          categories: b\n        }, e);\n      };\n\n      d.defaultOptions = h.defaultXAxisOptions;\n      d.keepProps = \"extKey hcEvents names series userMax userMin\".split(\" \");\n      return d;\n    }();\n\n    \"\";\n    return d;\n  });\n  N(h, \"Core/Axis/DateTimeAxis.js\", [h[\"Core/Utilities.js\"]], function (d) {\n    var h = d.addEvent,\n        A = d.getMagnitude,\n        F = d.normalizeTickInterval,\n        t = d.timeUnits,\n        G;\n\n    (function (d) {\n      function y() {\n        return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n      }\n\n      function q(c) {\n        \"datetime\" !== c.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new f(this));\n      }\n\n      var p = [];\n\n      d.compose = function (c) {\n        -1 === p.indexOf(c) && (p.push(c), c.keepProps.push(\"dateTime\"), c.prototype.getTimeTicks = y, h(c, \"init\", q));\n        return c;\n      };\n\n      var f = function () {\n        function c(a) {\n          this.axis = a;\n        }\n\n        c.prototype.normalizeTimeTickInterval = function (a, c) {\n          var f = c || [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2]], [\"week\", [1, 2]], [\"month\", [1, 2, 3, 4, 6]], [\"year\", null]];\n          c = f[f.length - 1];\n          var d = t[c[0]],\n              n = c[1],\n              p;\n\n          for (p = 0; p < f.length && !(c = f[p], d = t[c[0]], n = c[1], f[p + 1] && a <= (d * n[n.length - 1] + t[f[p + 1][0]]) / 2); p++);\n\n          d === t.year && a < 5 * d && (n = [1, 2, 5]);\n          a = F(a / d, n, \"year\" === c[0] ? Math.max(A(a / d), 1) : 1);\n          return {\n            unitRange: d,\n            count: a,\n            unitName: c[0]\n          };\n        };\n\n        c.prototype.getXDateFormat = function (a, c) {\n          var f = this.axis;\n          return f.closestPointRange ? f.chart.time.getDateFormat(f.closestPointRange, a, f.options.startOfWeek, c) || c.year : c.day;\n        };\n\n        return c;\n      }();\n\n      d.Additions = f;\n    })(G || (G = {}));\n\n    return G;\n  });\n  N(h, \"Core/Axis/LogarithmicAxis.js\", [h[\"Core/Utilities.js\"]], function (d) {\n    var h = d.addEvent,\n        A = d.getMagnitude,\n        F = d.normalizeTickInterval,\n        t = d.pick,\n        G;\n\n    (function (d) {\n      function y(c) {\n        var a = this.logarithmic;\n        \"logarithmic\" !== c.userOptions.type ? this.logarithmic = void 0 : a || (this.logarithmic = new f(this));\n      }\n\n      function q() {\n        var c = this.logarithmic;\n        c && (this.lin2val = function (a) {\n          return c.lin2log(a);\n        }, this.val2lin = function (a) {\n          return c.log2lin(a);\n        });\n      }\n\n      var p = [];\n\n      d.compose = function (c) {\n        -1 === p.indexOf(c) && (p.push(c), c.keepProps.push(\"logarithmic\"), h(c, \"init\", y), h(c, \"afterInit\", q));\n        return c;\n      };\n\n      var f = function () {\n        function c(a) {\n          this.axis = a;\n        }\n\n        c.prototype.getLogTickPositions = function (a, c, f, d) {\n          var n = this.axis,\n              m = n.len,\n              p = n.options,\n              h = [];\n          d || (this.minorAutoInterval = void 0);\n          if (.5 <= a) a = Math.round(a), h = n.getLinearTickPositions(a, c, f);else if (.08 <= a) {\n            var v = Math.floor(c),\n                z,\n                u = p = void 0;\n\n            for (m = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; v < f + 1 && !u; v++) {\n              var k = m.length;\n\n              for (z = 0; z < k && !u; z++) {\n                var w = this.log2lin(this.lin2log(v) * m[z]);\n                w > c && (!d || p <= f) && \"undefined\" !== typeof p && h.push(p);\n                p > f && (u = !0);\n                p = w;\n              }\n            }\n          } else c = this.lin2log(c), f = this.lin2log(f), a = d ? n.getMinorTickInterval() : p.tickInterval, a = t(\"auto\" === a ? null : a, this.minorAutoInterval, p.tickPixelInterval / (d ? 5 : 1) * (f - c) / ((d ? m / n.tickPositions.length : m) || 1)), a = F(a, void 0, A(a)), h = n.getLinearTickPositions(a, c, f).map(this.log2lin), d || (this.minorAutoInterval = a / 5);\n          d || (n.tickInterval = a);\n          return h;\n        };\n\n        c.prototype.lin2log = function (a) {\n          return Math.pow(10, a);\n        };\n\n        c.prototype.log2lin = function (a) {\n          return Math.log(a) / Math.LN10;\n        };\n\n        return c;\n      }();\n\n      d.Additions = f;\n    })(G || (G = {}));\n\n    return G;\n  });\n  N(h, \"Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js\", [h[\"Core/Utilities.js\"]], function (d) {\n    var h = d.erase,\n        A = d.extend,\n        F = d.isNumber,\n        t;\n\n    (function (d) {\n      var t = [],\n          y;\n\n      d.compose = function (d, f) {\n        y || (y = d);\n        -1 === t.indexOf(f) && (t.push(f), A(f.prototype, q.prototype));\n        return f;\n      };\n\n      var q = function () {\n        function d() {}\n\n        d.prototype.getPlotBandPath = function (f, c, a) {\n          void 0 === a && (a = this.options);\n          var d = this.getPlotLinePath({\n            value: c,\n            force: !0,\n            acrossPanes: a.acrossPanes\n          }),\n              m = [],\n              p = this.horiz;\n          c = !F(this.min) || !F(this.max) || f < this.min && c < this.min || f > this.max && c > this.max;\n          f = this.getPlotLinePath({\n            value: f,\n            force: !0,\n            acrossPanes: a.acrossPanes\n          });\n          a = 1;\n\n          if (f && d) {\n            if (c) {\n              var h = f.toString() === d.toString();\n              a = 0;\n            }\n\n            for (c = 0; c < f.length; c += 2) {\n              var q = f[c],\n                  L = f[c + 1],\n                  K = d[c],\n                  v = d[c + 1];\n              \"M\" !== q[0] && \"L\" !== q[0] || \"M\" !== L[0] && \"L\" !== L[0] || \"M\" !== K[0] && \"L\" !== K[0] || \"M\" !== v[0] && \"L\" !== v[0] || (p && K[1] === q[1] ? (K[1] += a, v[1] += a) : p || K[2] !== q[2] || (K[2] += a, v[2] += a), m.push([\"M\", q[1], q[2]], [\"L\", L[1], L[2]], [\"L\", v[1], v[2]], [\"L\", K[1], K[2]], [\"Z\"]));\n              m.isFlat = h;\n            }\n          }\n\n          return m;\n        };\n\n        d.prototype.addPlotBand = function (f) {\n          return this.addPlotBandOrLine(f, \"plotBands\");\n        };\n\n        d.prototype.addPlotLine = function (f) {\n          return this.addPlotBandOrLine(f, \"plotLines\");\n        };\n\n        d.prototype.addPlotBandOrLine = function (f, c) {\n          var a = this,\n              d = this.userOptions,\n              m = new y(this, f);\n          this.visible && (m = m.render());\n\n          if (m) {\n            this._addedPlotLB || (this._addedPlotLB = !0, (d.plotLines || []).concat(d.plotBands || []).forEach(function (c) {\n              a.addPlotBandOrLine(c);\n            }));\n\n            if (c) {\n              var p = d[c] || [];\n              p.push(f);\n              d[c] = p;\n            }\n\n            this.plotLinesAndBands.push(m);\n          }\n\n          return m;\n        };\n\n        d.prototype.removePlotBandOrLine = function (f) {\n          var c = this.plotLinesAndBands,\n              a = this.options,\n              d = this.userOptions;\n\n          if (c) {\n            for (var m = c.length; m--;) c[m].id === f && c[m].destroy();\n\n            [a.plotLines || [], d.plotLines || [], a.plotBands || [], d.plotBands || []].forEach(function (a) {\n              for (m = a.length; m--;) (a[m] || {}).id === f && h(a, a[m]);\n            });\n          }\n        };\n\n        d.prototype.removePlotBand = function (f) {\n          this.removePlotBandOrLine(f);\n        };\n\n        d.prototype.removePlotLine = function (f) {\n          this.removePlotBandOrLine(f);\n        };\n\n        return d;\n      }();\n    })(t || (t = {}));\n\n    return t;\n  });\n  N(h, \"Core/Axis/PlotLineOrBand/PlotLineOrBand.js\", [h[\"Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js\"], h[\"Core/Utilities.js\"]], function (d, h) {\n    var A = h.arrayMax,\n        E = h.arrayMin,\n        t = h.defined,\n        G = h.destroyObjectProperties,\n        H = h.erase,\n        y = h.fireEvent,\n        q = h.merge,\n        p = h.objectEach,\n        f = h.pick;\n\n    h = function () {\n      function c(a, c) {\n        this.axis = a;\n        c && (this.options = c, this.id = c.id);\n      }\n\n      c.compose = function (a) {\n        return d.compose(c, a);\n      };\n\n      c.prototype.render = function () {\n        y(this, \"render\");\n        var a = this,\n            c = a.axis,\n            d = c.horiz,\n            h = c.logarithmic,\n            C = a.options,\n            I = C.color,\n            L = f(C.zIndex, 0),\n            K = C.events,\n            v = {},\n            z = c.chart.renderer,\n            u = C.label,\n            k = a.label,\n            w = C.to,\n            l = C.from,\n            e = C.value,\n            g = a.svgElem,\n            b = [],\n            B = t(l) && t(w);\n        b = t(e);\n        var J = !g,\n            r = {\n          \"class\": \"highcharts-plot-\" + (B ? \"band \" : \"line \") + (C.className || \"\")\n        },\n            x = B ? \"bands\" : \"lines\";\n        h && (l = h.log2lin(l), w = h.log2lin(w), e = h.log2lin(e));\n        c.chart.styledMode || (b ? (r.stroke = I || \"#999999\", r[\"stroke-width\"] = f(C.width, 1), C.dashStyle && (r.dashstyle = C.dashStyle)) : B && (r.fill = I || \"#e6ebf5\", C.borderWidth && (r.stroke = C.borderColor, r[\"stroke-width\"] = C.borderWidth)));\n        v.zIndex = L;\n        x += \"-\" + L;\n        (h = c.plotLinesAndBandsGroups[x]) || (c.plotLinesAndBandsGroups[x] = h = z.g(\"plot-\" + x).attr(v).add());\n        J && (a.svgElem = g = z.path().attr(r).add(h));\n        if (b) b = c.getPlotLinePath({\n          value: e,\n          lineWidth: g.strokeWidth(),\n          acrossPanes: C.acrossPanes\n        });else if (B) b = c.getPlotBandPath(l, w, C);else return;\n        !a.eventsAdded && K && (p(K, function (b, e) {\n          g.on(e, function (b) {\n            K[e].apply(a, [b]);\n          });\n        }), a.eventsAdded = !0);\n        (J || !g.d) && b && b.length ? g.attr({\n          d: b\n        }) : g && (b ? (g.show(!0), g.animate({\n          d: b\n        })) : g.d && (g.hide(), k && (a.label = k = k.destroy())));\n        u && (t(u.text) || t(u.formatter)) && b && b.length && 0 < c.width && 0 < c.height && !b.isFlat ? (u = q({\n          align: d && B && \"center\",\n          x: d ? !B && 4 : 10,\n          verticalAlign: !d && B && \"middle\",\n          y: d ? B ? 16 : 10 : B ? 6 : -4,\n          rotation: d && !B && 90\n        }, u), this.renderLabel(u, b, B, L)) : k && k.hide();\n        return a;\n      };\n\n      c.prototype.renderLabel = function (a, c, f, d) {\n        var n = this.axis,\n            m = n.chart.renderer,\n            p = this.label;\n        p || (this.label = p = m.text(this.getLabelText(a), 0, 0, a.useHTML).attr({\n          align: a.textAlign || a.align,\n          rotation: a.rotation,\n          \"class\": \"highcharts-plot-\" + (f ? \"band\" : \"line\") + \"-label \" + (a.className || \"\"),\n          zIndex: d\n        }).add(), n.chart.styledMode || p.css(q({\n          textOverflow: \"ellipsis\"\n        }, a.style)));\n        d = c.xBounds || [c[0][1], c[1][1], f ? c[2][1] : c[0][1]];\n        c = c.yBounds || [c[0][2], c[1][2], f ? c[2][2] : c[0][2]];\n        f = E(d);\n        m = E(c);\n        p.align(a, !1, {\n          x: f,\n          y: m,\n          width: A(d) - f,\n          height: A(c) - m\n        });\n        p.alignValue && \"left\" !== p.alignValue || p.css({\n          width: (90 === p.rotation ? n.height - (p.alignAttr.y - n.top) : n.width - (p.alignAttr.x - n.left)) + \"px\"\n        });\n        p.show(!0);\n      };\n\n      c.prototype.getLabelText = function (a) {\n        return t(a.formatter) ? a.formatter.call(this) : a.text;\n      };\n\n      c.prototype.destroy = function () {\n        H(this.axis.plotLinesAndBands, this);\n        delete this.axis;\n        G(this);\n      };\n\n      return c;\n    }();\n\n    \"\";\n    \"\";\n    return h;\n  });\n  N(h, \"Core/Tooltip.js\", [h[\"Core/FormatUtilities.js\"], h[\"Core/Globals.js\"], h[\"Core/Renderer/RendererUtilities.js\"], h[\"Core/Renderer/RendererRegistry.js\"], h[\"Core/Utilities.js\"]], function (d, h, A, F, t) {\n    var E = d.format,\n        H = h.doc,\n        y = A.distribute,\n        q = t.addEvent,\n        p = t.clamp,\n        f = t.css,\n        c = t.defined,\n        a = t.discardElement,\n        n = t.extend,\n        m = t.fireEvent,\n        D = t.isArray,\n        C = t.isNumber,\n        I = t.isString,\n        L = t.merge,\n        K = t.pick,\n        v = t.splat,\n        z = t.syncTimeout;\n\n    d = function () {\n      function d(a, c) {\n        this.allowShared = !0;\n        this.container = void 0;\n        this.crosshairs = [];\n        this.distance = 0;\n        this.isHidden = !0;\n        this.isSticky = !1;\n        this.now = {};\n        this.options = {};\n        this.outside = !1;\n        this.chart = a;\n        this.init(a, c);\n      }\n\n      d.prototype.applyFilter = function () {\n        var a = this.chart;\n        a.renderer.definition({\n          tagName: \"filter\",\n          attributes: {\n            id: \"drop-shadow-\" + a.index,\n            opacity: .5\n          },\n          children: [{\n            tagName: \"feGaussianBlur\",\n            attributes: {\n              \"in\": \"SourceAlpha\",\n              stdDeviation: 1\n            }\n          }, {\n            tagName: \"feOffset\",\n            attributes: {\n              dx: 1,\n              dy: 1\n            }\n          }, {\n            tagName: \"feComponentTransfer\",\n            children: [{\n              tagName: \"feFuncA\",\n              attributes: {\n                type: \"linear\",\n                slope: .3\n              }\n            }]\n          }, {\n            tagName: \"feMerge\",\n            children: [{\n              tagName: \"feMergeNode\"\n            }, {\n              tagName: \"feMergeNode\",\n              attributes: {\n                \"in\": \"SourceGraphic\"\n              }\n            }]\n          }]\n        });\n      };\n\n      d.prototype.bodyFormatter = function (a) {\n        return a.map(function (a) {\n          var l = a.series.tooltipOptions;\n          return (l[(a.point.formatPrefix || \"point\") + \"Formatter\"] || a.point.tooltipFormatter).call(a.point, l[(a.point.formatPrefix || \"point\") + \"Format\"] || \"\");\n        });\n      };\n\n      d.prototype.cleanSplit = function (a) {\n        this.chart.series.forEach(function (c) {\n          var l = c && c.tt;\n          l && (!l.isActive || a ? c.tt = l.destroy() : l.isActive = !1);\n        });\n      };\n\n      d.prototype.defaultFormatter = function (a) {\n        var c = this.points || v(this);\n        var l = [a.tooltipFooterHeaderFormatter(c[0])];\n        l = l.concat(a.bodyFormatter(c));\n        l.push(a.tooltipFooterHeaderFormatter(c[0], !0));\n        return l;\n      };\n\n      d.prototype.destroy = function () {\n        this.label && (this.label = this.label.destroy());\n        this.split && this.tt && (this.cleanSplit(!0), this.tt = this.tt.destroy());\n        this.renderer && (this.renderer = this.renderer.destroy(), a(this.container));\n        t.clearTimeout(this.hideTimer);\n        t.clearTimeout(this.tooltipTimeout);\n      };\n\n      d.prototype.getAnchor = function (a, c) {\n        var l = this.chart,\n            e = l.pointer,\n            g = l.inverted,\n            b = l.plotTop,\n            k = l.plotLeft,\n            f,\n            r,\n            d = 0,\n            u = 0;\n        a = v(a);\n        this.followPointer && c ? (\"undefined\" === typeof c.chartX && (c = e.normalize(c)), e = [c.chartX - k, c.chartY - b]) : a[0].tooltipPos ? e = a[0].tooltipPos : (a.forEach(function (e) {\n          f = e.series.yAxis;\n          r = e.series.xAxis;\n          d += e.plotX || 0;\n          u += e.plotLow ? (e.plotLow + (e.plotHigh || 0)) / 2 : e.plotY || 0;\n          r && f && (g ? (d += b + l.plotHeight - r.len - r.pos, u += k + l.plotWidth - f.len - f.pos) : (d += r.pos - k, u += f.pos - b));\n        }), d /= a.length, u /= a.length, e = [g ? l.plotWidth - u : d, g ? l.plotHeight - d : u], this.shared && 1 < a.length && c && (g ? e[0] = c.chartX - k : e[1] = c.chartY - b));\n        return e.map(Math.round);\n      };\n\n      d.prototype.getLabel = function () {\n        var a = this,\n            d = this.chart.styledMode,\n            l = this.options,\n            e = this.split && this.allowShared,\n            g = \"tooltip\" + (c(l.className) ? \" \" + l.className : \"\"),\n            b = l.style.pointerEvents || (!this.followPointer && l.stickOnContact ? \"auto\" : \"none\"),\n            B = function () {\n          a.inContact = !0;\n        },\n            u = function (b) {\n          var e = a.chart.hoverSeries;\n          a.inContact = a.shouldStickOnContact() && a.chart.pointer.inClass(b.relatedTarget, \"highcharts-tooltip\");\n          if (!a.inContact && e && e.onMouseOut) e.onMouseOut();\n        },\n            r,\n            x = this.chart.renderer;\n\n        if (a.label) {\n          var n = !a.label.hasClass(\"highcharts-label\");\n          (e && !n || !e && n) && a.destroy();\n        }\n\n        if (!this.label) {\n          if (this.outside) {\n            n = this.chart.options.chart.style;\n            var m = F.getRendererType();\n            this.container = r = h.doc.createElement(\"div\");\n            r.className = \"highcharts-tooltip-container\";\n            f(r, {\n              position: \"absolute\",\n              top: \"1px\",\n              pointerEvents: b,\n              zIndex: Math.max(this.options.style.zIndex || 0, (n && n.zIndex || 0) + 3)\n            });\n            q(r, \"mouseenter\", B);\n            q(r, \"mouseleave\", u);\n            h.doc.body.appendChild(r);\n            this.renderer = x = new m(r, 0, 0, n, void 0, void 0, x.styledMode);\n          }\n\n          e ? this.label = x.g(g) : (this.label = x.label(\"\", 0, 0, l.shape, void 0, void 0, l.useHTML, void 0, g).attr({\n            padding: l.padding,\n            r: l.borderRadius\n          }), d || this.label.attr({\n            fill: l.backgroundColor,\n            \"stroke-width\": l.borderWidth\n          }).css(l.style).css({\n            pointerEvents: b\n          }).shadow(l.shadow));\n          d && l.shadow && (this.applyFilter(), this.label.attr({\n            filter: \"url(#drop-shadow-\" + this.chart.index + \")\"\n          }));\n\n          if (a.outside && !a.split) {\n            var z = this.label,\n                p = z.xSetter,\n                v = z.ySetter;\n\n            z.xSetter = function (b) {\n              p.call(z, a.distance);\n              r.style.left = b + \"px\";\n            };\n\n            z.ySetter = function (b) {\n              v.call(z, a.distance);\n              r.style.top = b + \"px\";\n            };\n          }\n\n          this.label.on(\"mouseenter\", B).on(\"mouseleave\", u).attr({\n            zIndex: 8\n          }).add();\n        }\n\n        return this.label;\n      };\n\n      d.prototype.getPosition = function (a, c, l) {\n        var e = this.chart,\n            g = this.distance,\n            b = {},\n            k = e.inverted && l.h || 0,\n            f = this.outside,\n            r = f ? H.documentElement.clientWidth - 2 * g : e.chartWidth,\n            d = f ? Math.max(H.body.scrollHeight, H.documentElement.scrollHeight, H.body.offsetHeight, H.documentElement.offsetHeight, H.documentElement.clientHeight) : e.chartHeight,\n            u = e.pointer.getChartPosition(),\n            w = function (b) {\n          var k = \"x\" === b;\n          return [b, k ? r : d, k ? a : c].concat(f ? [k ? a * u.scaleX : c * u.scaleY, k ? u.left - g + (l.plotX + e.plotLeft) * u.scaleX : u.top - g + (l.plotY + e.plotTop) * u.scaleY, 0, k ? r : d] : [k ? a : c, k ? l.plotX + e.plotLeft : l.plotY + e.plotTop, k ? e.plotLeft : e.plotTop, k ? e.plotLeft + e.plotWidth : e.plotTop + e.plotHeight]);\n        },\n            n = w(\"y\"),\n            m = w(\"x\"),\n            z;\n\n        w = !!l.negative;\n        !e.polar && e.hoverSeries && e.hoverSeries.yAxis && e.hoverSeries.yAxis.reversed && (w = !w);\n\n        var p = !this.followPointer && K(l.ttBelow, !e.inverted === w),\n            v = function (e, a, l, c, r, d, x) {\n          var B = f ? \"y\" === e ? g * u.scaleY : g * u.scaleX : g,\n              w = (l - c) / 2,\n              J = c < r - g,\n              n = r + g + c < a,\n              m = r - B - l + w;\n          r = r + B - w;\n          if (p && n) b[e] = r;else if (!p && J) b[e] = m;else if (J) b[e] = Math.min(x - c, 0 > m - k ? m : m - k);else if (n) b[e] = Math.max(d, r + k + l > a ? r : r + k);else return !1;\n        },\n            h = function (e, a, l, c, k) {\n          var r;\n          k < g || k > a - g ? r = !1 : b[e] = k < l / 2 ? 1 : k > a - c / 2 ? a - c - 2 : k - l / 2;\n          return r;\n        },\n            Q = function (b) {\n          var e = n;\n          n = m;\n          m = e;\n          z = b;\n        },\n            q = function () {\n          !1 !== v.apply(0, n) ? !1 !== h.apply(0, m) || z || (Q(!0), q()) : z ? b.x = b.y = 0 : (Q(!0), q());\n        };\n\n        (e.inverted || 1 < this.len) && Q();\n        q();\n        return b;\n      };\n\n      d.prototype.hide = function (a) {\n        var c = this;\n        t.clearTimeout(this.hideTimer);\n        a = K(a, this.options.hideDelay);\n        this.isHidden || (this.hideTimer = z(function () {\n          c.getLabel().fadeOut(a ? void 0 : a);\n          c.isHidden = !0;\n        }, a));\n      };\n\n      d.prototype.init = function (a, c) {\n        this.chart = a;\n        this.options = c;\n        this.crosshairs = [];\n        this.now = {\n          x: 0,\n          y: 0\n        };\n        this.isHidden = !0;\n        this.split = c.split && !a.inverted && !a.polar;\n        this.shared = c.shared || this.split;\n        this.outside = K(c.outside, !(!a.scrollablePixelsX && !a.scrollablePixelsY));\n      };\n\n      d.prototype.shouldStickOnContact = function () {\n        return !(this.followPointer || !this.options.stickOnContact);\n      };\n\n      d.prototype.isStickyOnContact = function () {\n        return !(!this.shouldStickOnContact() || !this.inContact);\n      };\n\n      d.prototype.move = function (a, c, l, e) {\n        var g = this,\n            b = g.now,\n            k = !1 !== g.options.animation && !g.isHidden && (1 < Math.abs(a - b.x) || 1 < Math.abs(c - b.y)),\n            f = g.followPointer || 1 < g.len;\n        n(b, {\n          x: k ? (2 * b.x + a) / 3 : a,\n          y: k ? (b.y + c) / 2 : c,\n          anchorX: f ? void 0 : k ? (2 * b.anchorX + l) / 3 : l,\n          anchorY: f ? void 0 : k ? (b.anchorY + e) / 2 : e\n        });\n        g.getLabel().attr(b);\n        g.drawTracker();\n        k && (t.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {\n          g && g.move(a, c, l, e);\n        }, 32));\n      };\n\n      d.prototype.refresh = function (a, c) {\n        var l = this.chart,\n            e = this.options,\n            g = v(a),\n            b = g[0],\n            k = [],\n            f = e.formatter || this.defaultFormatter,\n            r = this.shared,\n            d = l.styledMode,\n            u = {};\n\n        if (e.enabled) {\n          t.clearTimeout(this.hideTimer);\n          this.allowShared = !(!D(a) && a.series && a.series.noSharedTooltip);\n          this.followPointer = !this.split && b.series.tooltipOptions.followPointer;\n          a = this.getAnchor(a, c);\n          var w = a[0],\n              n = a[1];\n          r && this.allowShared ? (l.pointer.applyInactiveState(g), g.forEach(function (b) {\n            b.setState(\"hover\");\n            k.push(b.getLabelConfig());\n          }), u = {\n            x: b.category,\n            y: b.y\n          }, u.points = k) : u = b.getLabelConfig();\n          this.len = k.length;\n          f = f.call(u, this);\n          r = b.series;\n          this.distance = K(r.tooltipOptions.distance, 16);\n          if (!1 === f) this.hide();else {\n            if (this.split && this.allowShared) this.renderSplit(f, g);else {\n              var z = w,\n                  p = n;\n              c && l.pointer.isDirectTouch && (z = c.chartX - l.plotLeft, p = c.chartY - l.plotTop);\n              if (l.polar || !1 === r.options.clip || g.some(function (b) {\n                return b.series.shouldShowTooltip(z, p);\n              })) c = this.getLabel(), e.style.width && !d || c.css({\n                width: this.chart.spacingBox.width + \"px\"\n              }), c.attr({\n                text: f && f.join ? f.join(\"\") : f\n              }), c.removeClass(/highcharts-color-[\\d]+/g).addClass(\"highcharts-color-\" + K(b.colorIndex, r.colorIndex)), d || c.attr({\n                stroke: e.borderColor || b.color || r.color || \"#666666\"\n              }), this.updatePosition({\n                plotX: w,\n                plotY: n,\n                negative: b.negative,\n                ttBelow: b.ttBelow,\n                h: a[2] || 0\n              });else {\n                this.hide();\n                return;\n              }\n            }\n            this.isHidden && this.label && this.label.attr({\n              opacity: 1\n            }).show();\n            this.isHidden = !1;\n          }\n          m(this, \"refresh\");\n        }\n      };\n\n      d.prototype.renderSplit = function (a, c) {\n        function l(b, g, a, l, c) {\n          void 0 === c && (c = !0);\n          a ? (g = A ? 0 : ea, b = p(b - l / 2, R.left, R.right - l - (e.outside ? E : 0))) : (g -= G, b = c ? b - l - C : b + C, b = p(b, c ? b : R.left, R.right));\n          return {\n            x: b,\n            y: g\n          };\n        }\n\n        var e = this,\n            g = e.chart,\n            b = e.chart,\n            k = b.chartWidth,\n            f = b.chartHeight,\n            r = b.plotHeight,\n            d = b.plotLeft,\n            u = b.plotTop,\n            w = b.pointer,\n            m = b.scrollablePixelsY;\n        m = void 0 === m ? 0 : m;\n        var z = b.scrollablePixelsX,\n            v = b.scrollingContainer;\n        v = void 0 === v ? {\n          scrollLeft: 0,\n          scrollTop: 0\n        } : v;\n        var h = v.scrollLeft;\n        v = v.scrollTop;\n        var q = b.styledMode,\n            C = e.distance,\n            Q = e.options,\n            D = e.options.positioner,\n            R = e.outside && \"number\" !== typeof z ? H.documentElement.getBoundingClientRect() : {\n          left: h,\n          right: h + k,\n          top: v,\n          bottom: v + f\n        },\n            L = e.getLabel(),\n            t = this.renderer || g.renderer,\n            A = !(!g.xAxis[0] || !g.xAxis[0].opposite);\n        g = w.getChartPosition();\n        var E = g.left;\n        g = g.top;\n        var G = u + v,\n            F = 0,\n            ea = r - m;\n        I(a) && (a = [!1, a]);\n        a = a.slice(0, c.length + 1).reduce(function (b, g, a) {\n          if (!1 !== g && \"\" !== g) {\n            a = c[a - 1] || {\n              isHeader: !0,\n              plotX: c[0].plotX,\n              plotY: r,\n              series: {}\n            };\n            var k = a.isHeader,\n                f = k ? e : a.series;\n            g = g.toString();\n            var x = f.tt,\n                B = a.isHeader;\n            var w = a.series;\n            var J = \"highcharts-color-\" + K(a.colorIndex, w.colorIndex, \"none\");\n            x || (x = {\n              padding: Q.padding,\n              r: Q.borderRadius\n            }, q || (x.fill = Q.backgroundColor, x[\"stroke-width\"] = Q.borderWidth), x = t.label(\"\", 0, 0, Q[B ? \"headerShape\" : \"shape\"], void 0, void 0, Q.useHTML).addClass((B ? \"highcharts-tooltip-header \" : \"\") + \"highcharts-tooltip-box \" + J).attr(x).add(L));\n            x.isActive = !0;\n            x.attr({\n              text: g\n            });\n            q || x.css(Q.style).shadow(Q.shadow).attr({\n              stroke: Q.borderColor || a.color || w.color || \"#333333\"\n            });\n            f = f.tt = x;\n            B = f.getBBox();\n            g = B.width + f.strokeWidth();\n            k && (F = B.height, ea += F, A && (G -= F));\n            w = a.plotX;\n            w = void 0 === w ? 0 : w;\n            J = a.plotY;\n            J = void 0 === J ? 0 : J;\n            x = a.series;\n\n            if (a.isHeader) {\n              w = d + w;\n              var n = u + r / 2;\n            } else {\n              var m = x.xAxis,\n                  z = x.yAxis;\n              w = m.pos + p(w, -C, m.len + C);\n              x.shouldShowTooltip(0, z.pos - u + J, {\n                ignoreX: !0\n              }) && (n = z.pos + J);\n            }\n\n            w = p(w, R.left - C, R.right + C);\n            \"number\" === typeof n ? (B = B.height + 1, J = D ? D.call(e, g, B, a) : l(w, n, k, g), b.push({\n              align: D ? 0 : void 0,\n              anchorX: w,\n              anchorY: n,\n              boxWidth: g,\n              point: a,\n              rank: K(J.rank, k ? 1 : 0),\n              size: B,\n              target: J.y,\n              tt: f,\n              x: J.x\n            })) : f.isActive = !1;\n          }\n\n          return b;\n        }, []);\n        !D && a.some(function (b) {\n          var g = (e.outside ? E : 0) + b.anchorX;\n          return g < R.left && g + b.boxWidth < R.right ? !0 : g < E - R.left + b.boxWidth && R.right - g > g;\n        }) && (a = a.map(function (b) {\n          var e = l(b.anchorX, b.anchorY, b.point.isHeader, b.boxWidth, !1);\n          return n(b, {\n            target: e.y,\n            x: e.x\n          });\n        }));\n        e.cleanSplit();\n        y(a, ea);\n        var N = E,\n            Y = E;\n        a.forEach(function (b) {\n          var g = b.x,\n              a = b.boxWidth;\n          b = b.isHeader;\n          b || (e.outside && E + g < N && (N = E + g), !b && e.outside && N + a > Y && (Y = E + g));\n        });\n        a.forEach(function (b) {\n          var g = b.x,\n              a = b.anchorX,\n              l = b.pos,\n              c = b.point.isHeader;\n          l = {\n            visibility: \"undefined\" === typeof l ? \"hidden\" : \"inherit\",\n            x: g,\n            y: l + G,\n            anchorX: a,\n            anchorY: b.anchorY\n          };\n\n          if (e.outside && g < a) {\n            var k = E - N;\n            0 < k && (c || (l.x = g + k, l.anchorX = a + k), c && (l.x = (Y - N) / 2, l.anchorX = a + k));\n          }\n\n          b.tt.attr(l);\n        });\n        a = e.container;\n        m = e.renderer;\n        e.outside && a && m && (b = L.getBBox(), m.setSize(b.width + b.x, b.height + b.y, !1), a.style.left = N + \"px\", a.style.top = g + \"px\");\n      };\n\n      d.prototype.drawTracker = function () {\n        if (this.followPointer || !this.options.stickOnContact) this.tracker && this.tracker.destroy();else {\n          var a = this.chart,\n              c = this.label,\n              l = this.shared ? a.hoverPoints : a.hoverPoint;\n\n          if (c && l) {\n            var e = {\n              x: 0,\n              y: 0,\n              width: 0,\n              height: 0\n            };\n            l = this.getAnchor(l);\n            var g = c.getBBox();\n            l[0] += a.plotLeft - c.translateX;\n            l[1] += a.plotTop - c.translateY;\n            e.x = Math.min(0, l[0]);\n            e.y = Math.min(0, l[1]);\n            e.width = 0 > l[0] ? Math.max(Math.abs(l[0]), g.width - l[0]) : Math.max(Math.abs(l[0]), g.width);\n            e.height = 0 > l[1] ? Math.max(Math.abs(l[1]), g.height - Math.abs(l[1])) : Math.max(Math.abs(l[1]), g.height);\n            this.tracker ? this.tracker.attr(e) : (this.tracker = c.renderer.rect(e).addClass(\"highcharts-tracker\").add(c), a.styledMode || this.tracker.attr({\n              fill: \"rgba(0,0,0,0)\"\n            }));\n          }\n        }\n      };\n\n      d.prototype.styledModeFormat = function (a) {\n        return a.replace('style=\"font-size: 10px\"', 'class=\"highcharts-header\"').replace(/style=\"color:{(point|series)\\.color}\"/g, 'class=\"highcharts-color-{$1.colorIndex}\"');\n      };\n\n      d.prototype.tooltipFooterHeaderFormatter = function (a, c) {\n        var l = a.series,\n            e = l.tooltipOptions,\n            g = l.xAxis,\n            b = g && g.dateTime;\n        g = {\n          isFooter: c,\n          labelConfig: a\n        };\n        var k = e.xDateFormat,\n            f = e[c ? \"footerFormat\" : \"headerFormat\"];\n        m(this, \"headerFormatter\", g, function (g) {\n          b && !k && C(a.key) && (k = b.getXDateFormat(a.key, e.dateTimeLabelFormats));\n          b && k && (a.point && a.point.tooltipDateKeys || [\"key\"]).forEach(function (b) {\n            f = f.replace(\"{point.\" + b + \"}\", \"{point.\" + b + \":\" + k + \"}\");\n          });\n          l.chart.styledMode && (f = this.styledModeFormat(f));\n          g.text = E(f, {\n            point: a,\n            series: l\n          }, this.chart);\n        });\n        return g.text;\n      };\n\n      d.prototype.update = function (a) {\n        this.destroy();\n        L(!0, this.chart.options.tooltip.userOptions, a);\n        this.init(this.chart, L(!0, this.options, a));\n      };\n\n      d.prototype.updatePosition = function (a) {\n        var c = this.chart,\n            l = this.options,\n            e = c.pointer,\n            g = this.getLabel();\n        e = e.getChartPosition();\n        var b = (l.positioner || this.getPosition).call(this, g.width, g.height, a),\n            k = a.plotX + c.plotLeft;\n        a = a.plotY + c.plotTop;\n\n        if (this.outside) {\n          l = l.borderWidth + 2 * this.distance;\n          this.renderer.setSize(g.width + l, g.height + l, !1);\n          if (1 !== e.scaleX || 1 !== e.scaleY) f(this.container, {\n            transform: \"scale(\" + e.scaleX + \", \" + e.scaleY + \")\"\n          }), k *= e.scaleX, a *= e.scaleY;\n          k += e.left - b.x;\n          a += e.top - b.y;\n        }\n\n        this.move(Math.round(b.x), Math.round(b.y || 0), k, a);\n      };\n\n      return d;\n    }();\n\n    \"\";\n    return d;\n  });\n  N(h, \"Core/Series/Point.js\", [h[\"Core/Renderer/HTML/AST.js\"], h[\"Core/Animation/AnimationUtilities.js\"], h[\"Core/DefaultOptions.js\"], h[\"Core/FormatUtilities.js\"], h[\"Core/Utilities.js\"]], function (d, h, A, F, t) {\n    var E = h.animObject,\n        H = A.defaultOptions,\n        y = F.format,\n        q = t.addEvent,\n        p = t.defined,\n        f = t.erase,\n        c = t.extend,\n        a = t.fireEvent,\n        n = t.getNestedProperty,\n        m = t.isArray,\n        D = t.isFunction,\n        C = t.isNumber,\n        I = t.isObject,\n        L = t.merge,\n        K = t.objectEach,\n        v = t.pick,\n        z = t.syncTimeout,\n        u = t.removeEvent,\n        k = t.uniqueKey;\n\n    h = function () {\n      function w() {\n        this.colorIndex = this.category = void 0;\n        this.formatPrefix = \"point\";\n        this.id = void 0;\n        this.isNull = !1;\n        this.percentage = this.options = this.name = void 0;\n        this.selected = !1;\n        this.total = this.series = void 0;\n        this.visible = !0;\n        this.x = void 0;\n      }\n\n      w.prototype.animateBeforeDestroy = function () {\n        var a = this,\n            e = {\n          x: a.startXPos,\n          opacity: 0\n        },\n            g = a.getGraphicalProps();\n        g.singular.forEach(function (b) {\n          a[b] = a[b].animate(\"dataLabel\" === b ? {\n            x: a[b].startXPos,\n            y: a[b].startYPos,\n            opacity: 0\n          } : e);\n        });\n        g.plural.forEach(function (b) {\n          a[b].forEach(function (b) {\n            b.element && b.animate(c({\n              x: a.startXPos\n            }, b.startYPos ? {\n              x: b.startXPos,\n              y: b.startYPos\n            } : {}));\n          });\n        });\n      };\n\n      w.prototype.applyOptions = function (a, e) {\n        var g = this.series,\n            b = g.options.pointValKey || g.pointValKey;\n        a = w.prototype.optionsToObject.call(this, a);\n        c(this, a);\n        this.options = this.options ? c(this.options, a) : a;\n        a.group && delete this.group;\n        a.dataLabels && delete this.dataLabels;\n        b && (this.y = w.prototype.getNestedProperty.call(this, b));\n        this.formatPrefix = (this.isNull = v(this.isValid && !this.isValid(), null === this.x || !C(this.y))) ? \"null\" : \"point\";\n        this.selected && (this.state = \"select\");\n        \"name\" in this && \"undefined\" === typeof e && g.xAxis && g.xAxis.hasNames && (this.x = g.xAxis.nameToX(this));\n        \"undefined\" === typeof this.x && g ? this.x = \"undefined\" === typeof e ? g.autoIncrement() : e : C(a.x) && g.options.relativeXValue && (this.x = g.autoIncrement(a.x));\n        return this;\n      };\n\n      w.prototype.destroy = function () {\n        function a() {\n          if (e.graphic || e.dataLabel || e.dataLabels) u(e), e.destroyElements();\n\n          for (r in e) e[r] = null;\n        }\n\n        var e = this,\n            g = e.series,\n            b = g.chart;\n        g = g.options.dataSorting;\n        var c = b.hoverPoints,\n            k = E(e.series.chart.renderer.globalAnimation),\n            r;\n        e.legendItem && b.legend.destroyItem(e);\n        c && (e.setState(), f(c, e), c.length || (b.hoverPoints = null));\n        if (e === b.hoverPoint) e.onMouseOut();\n        g && g.enabled ? (this.animateBeforeDestroy(), z(a, k.duration)) : a();\n        b.pointCount--;\n      };\n\n      w.prototype.destroyElements = function (a) {\n        var e = this;\n        a = e.getGraphicalProps(a);\n        a.singular.forEach(function (g) {\n          e[g] = e[g].destroy();\n        });\n        a.plural.forEach(function (g) {\n          e[g].forEach(function (b) {\n            b.element && b.destroy();\n          });\n          delete e[g];\n        });\n      };\n\n      w.prototype.firePointEvent = function (l, e, g) {\n        var b = this,\n            c = this.series.options;\n        (c.point.events[l] || b.options && b.options.events && b.options.events[l]) && b.importEvents();\n        \"click\" === l && c.allowPointSelect && (g = function (e) {\n          b.select && b.select(null, e.ctrlKey || e.metaKey || e.shiftKey);\n        });\n        a(b, l, e, g);\n      };\n\n      w.prototype.getClassName = function () {\n        return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (\"undefined\" !== typeof this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n      };\n\n      w.prototype.getGraphicalProps = function (a) {\n        var e = this,\n            g = [],\n            b = {\n          singular: [],\n          plural: []\n        },\n            l;\n        a = a || {\n          graphic: 1,\n          dataLabel: 1\n        };\n        a.graphic && g.push(\"graphic\", \"upperGraphic\", \"shadowGroup\");\n        a.dataLabel && g.push(\"dataLabel\", \"dataLabelUpper\", \"connector\");\n\n        for (l = g.length; l--;) {\n          var c = g[l];\n          e[c] && b.singular.push(c);\n        }\n\n        [\"dataLabel\", \"connector\"].forEach(function (g) {\n          var l = g + \"s\";\n          a[g] && e[l] && b.plural.push(l);\n        });\n        return b;\n      };\n\n      w.prototype.getLabelConfig = function () {\n        return {\n          x: this.category,\n          y: this.y,\n          color: this.color,\n          colorIndex: this.colorIndex,\n          key: this.name || this.category,\n          series: this.series,\n          point: this,\n          percentage: this.percentage,\n          total: this.total || this.stackTotal\n        };\n      };\n\n      w.prototype.getNestedProperty = function (a) {\n        if (a) return 0 === a.indexOf(\"custom.\") ? n(a, this.options) : this[a];\n      };\n\n      w.prototype.getZone = function () {\n        var a = this.series,\n            e = a.zones;\n        a = a.zoneAxis || \"y\";\n        var g,\n            b = 0;\n\n        for (g = e[b]; this[a] >= g.value;) g = e[++b];\n\n        this.nonZonedColor || (this.nonZonedColor = this.color);\n        this.color = g && g.color && !this.options.color ? g.color : this.nonZonedColor;\n        return g;\n      };\n\n      w.prototype.hasNewShapeType = function () {\n        return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;\n      };\n\n      w.prototype.init = function (c, e, g) {\n        this.series = c;\n        this.applyOptions(e, g);\n        this.id = p(this.id) ? this.id : k();\n        this.resolveColor();\n        c.chart.pointCount++;\n        a(this, \"afterInit\");\n        return this;\n      };\n\n      w.prototype.optionsToObject = function (a) {\n        var e = this.series,\n            g = e.options.keys,\n            b = g || e.pointArrayMap || [\"y\"],\n            c = b.length,\n            l = {},\n            k = 0,\n            f = 0;\n        if (C(a) || null === a) l[b[0]] = a;else if (m(a)) for (!g && a.length > c && (e = typeof a[0], \"string\" === e ? l.name = a[0] : \"number\" === e && (l.x = a[0]), k++); f < c;) g && \"undefined\" === typeof a[k] || (0 < b[f].indexOf(\".\") ? w.prototype.setNestedProperty(l, a[k], b[f]) : l[b[f]] = a[k]), k++, f++;else \"object\" === typeof a && (l = a, a.dataLabels && (e._hasPointLabels = !0), a.marker && (e._hasPointMarkers = !0));\n        return l;\n      };\n\n      w.prototype.resolveColor = function () {\n        var a = this.series,\n            e = a.chart.styledMode;\n        var g = a.chart.options.chart.colorCount;\n        delete this.nonZonedColor;\n\n        if (a.options.colorByPoint) {\n          if (!e) {\n            g = a.options.colors || a.chart.options.colors;\n            var b = g[a.colorCounter];\n            g = g.length;\n          }\n\n          e = a.colorCounter;\n          a.colorCounter++;\n          a.colorCounter === g && (a.colorCounter = 0);\n        } else e || (b = a.color), e = a.colorIndex;\n\n        this.colorIndex = v(this.options.colorIndex, e);\n        this.color = v(this.options.color, b);\n      };\n\n      w.prototype.setNestedProperty = function (a, e, g) {\n        g.split(\".\").reduce(function (b, g, a, c) {\n          b[g] = c.length - 1 === a ? e : I(b[g], !0) ? b[g] : {};\n          return b[g];\n        }, a);\n        return a;\n      };\n\n      w.prototype.tooltipFormatter = function (a) {\n        var e = this.series,\n            g = e.tooltipOptions,\n            b = v(g.valueDecimals, \"\"),\n            c = g.valuePrefix || \"\",\n            l = g.valueSuffix || \"\";\n        e.chart.styledMode && (a = e.chart.tooltip.styledModeFormat(a));\n        (e.pointArrayMap || [\"y\"]).forEach(function (e) {\n          e = \"{point.\" + e;\n          if (c || l) a = a.replace(RegExp(e + \"}\", \"g\"), c + e + \"}\" + l);\n          a = a.replace(RegExp(e + \"}\", \"g\"), e + \":,.\" + b + \"f}\");\n        });\n        return y(a, {\n          point: this,\n          series: this.series\n        }, e.chart);\n      };\n\n      w.prototype.update = function (a, e, g, b) {\n        function c() {\n          l.applyOptions(a);\n          var b = f && l.hasDummyGraphic;\n          b = null === l.y ? !b : b;\n          f && b && (l.graphic = f.destroy(), delete l.hasDummyGraphic);\n          I(a, !0) && (f && f.element && a && a.marker && \"undefined\" !== typeof a.marker.symbol && (l.graphic = f.destroy()), a && a.dataLabels && l.dataLabel && (l.dataLabel = l.dataLabel.destroy()), l.connector && (l.connector = l.connector.destroy()));\n          w = l.index;\n          k.updateParallelArrays(l, w);\n          u.data[w] = I(u.data[w], !0) || I(a, !0) ? l.options : v(a, u.data[w]);\n          k.isDirty = k.isDirtyData = !0;\n          !k.fixedBox && k.hasCartesianSeries && (d.isDirtyBox = !0);\n          \"point\" === u.legendType && (d.isDirtyLegend = !0);\n          e && d.redraw(g);\n        }\n\n        var l = this,\n            k = l.series,\n            f = l.graphic,\n            d = k.chart,\n            u = k.options,\n            w;\n        e = v(e, !0);\n        !1 === b ? c() : l.firePointEvent(\"update\", {\n          options: a\n        }, c);\n      };\n\n      w.prototype.remove = function (a, e) {\n        this.series.removePoint(this.series.data.indexOf(this), a, e);\n      };\n\n      w.prototype.select = function (a, e) {\n        var g = this,\n            b = g.series,\n            c = b.chart;\n        this.selectedStaging = a = v(a, !g.selected);\n        g.firePointEvent(a ? \"select\" : \"unselect\", {\n          accumulate: e\n        }, function () {\n          g.selected = g.options.selected = a;\n          b.options.data[b.data.indexOf(g)] = g.options;\n          g.setState(a && \"select\");\n          e || c.getSelectedPoints().forEach(function (b) {\n            var e = b.series;\n            b.selected && b !== g && (b.selected = b.options.selected = !1, e.options.data[e.data.indexOf(b)] = b.options, b.setState(c.hoverPoints && e.options.inactiveOtherPoints ? \"inactive\" : \"\"), b.firePointEvent(\"unselect\"));\n          });\n        });\n        delete this.selectedStaging;\n      };\n\n      w.prototype.onMouseOver = function (a) {\n        var e = this.series.chart,\n            g = e.pointer;\n        a = a ? g.normalize(a) : g.getChartCoordinatesFromPoint(this, e.inverted);\n        g.runPointActions(a, this);\n      };\n\n      w.prototype.onMouseOut = function () {\n        var a = this.series.chart;\n        this.firePointEvent(\"mouseOut\");\n        this.series.options.inactiveOtherPoints || (a.hoverPoints || []).forEach(function (e) {\n          e.setState();\n        });\n        a.hoverPoints = a.hoverPoint = null;\n      };\n\n      w.prototype.importEvents = function () {\n        if (!this.hasImportedEvents) {\n          var a = this,\n              e = L(a.series.options.point, a.options).events;\n          a.events = e;\n          K(e, function (e, b) {\n            D(e) && q(a, b, e);\n          });\n          this.hasImportedEvents = !0;\n        }\n      };\n\n      w.prototype.setState = function (l, e) {\n        var g = this.series,\n            b = this.state,\n            k = g.options.states[l || \"normal\"] || {},\n            f = H.plotOptions[g.type].marker && g.options.marker,\n            r = f && !1 === f.enabled,\n            x = f && f.states && f.states[l || \"normal\"] || {},\n            u = !1 === x.enabled,\n            w = this.marker || {},\n            n = g.chart,\n            m = f && g.markerAttribs,\n            z = g.halo,\n            p,\n            h = g.stateMarkerGraphic;\n        l = l || \"\";\n\n        if (!(l === this.state && !e || this.selected && \"select\" !== l || !1 === k.enabled || l && (u || r && !1 === x.enabled) || l && w.states && w.states[l] && !1 === w.states[l].enabled)) {\n          this.state = l;\n          m && (p = g.markerAttribs(this, l));\n\n          if (this.graphic && !this.hasDummyGraphic) {\n            b && this.graphic.removeClass(\"highcharts-point-\" + b);\n            l && this.graphic.addClass(\"highcharts-point-\" + l);\n\n            if (!n.styledMode) {\n              var q = g.pointAttribs(this, l);\n              var Q = v(n.options.chart.animation, k.animation);\n              g.options.inactiveOtherPoints && C(q.opacity) && ((this.dataLabels || []).forEach(function (b) {\n                b && b.animate({\n                  opacity: q.opacity\n                }, Q);\n              }), this.connector && this.connector.animate({\n                opacity: q.opacity\n              }, Q));\n              this.graphic.animate(q, Q);\n            }\n\n            p && this.graphic.animate(p, v(n.options.chart.animation, x.animation, f.animation));\n            h && h.hide();\n          } else {\n            if (l && x) {\n              b = w.symbol || g.symbol;\n              h && h.currentSymbol !== b && (h = h.destroy());\n              if (p) if (h) h[e ? \"animate\" : \"attr\"]({\n                x: p.x,\n                y: p.y\n              });else b && (g.stateMarkerGraphic = h = n.renderer.symbol(b, p.x, p.y, p.width, p.height).add(g.markerGroup), h.currentSymbol = b);\n              !n.styledMode && h && \"inactive\" !== this.state && h.attr(g.pointAttribs(this, l));\n            }\n\n            h && (h[l && this.isInside ? \"show\" : \"hide\"](), h.element.point = this, h.addClass(this.getClassName(), !0));\n          }\n\n          k = k.halo;\n          p = (h = this.graphic || h) && h.visibility || \"inherit\";\n          k && k.size && h && \"hidden\" !== p && !this.isCluster ? (z || (g.halo = z = n.renderer.path().add(h.parentGroup)), z.show()[e ? \"animate\" : \"attr\"]({\n            d: this.haloPath(k.size)\n          }), z.attr({\n            \"class\": \"highcharts-halo highcharts-color-\" + v(this.colorIndex, g.colorIndex) + (this.className ? \" \" + this.className : \"\"),\n            visibility: p,\n            zIndex: -1\n          }), z.point = this, n.styledMode || z.attr(c({\n            fill: this.color || g.color,\n            \"fill-opacity\": k.opacity\n          }, d.filterUserAttributes(k.attributes || {})))) : z && z.point && z.point.haloPath && z.animate({\n            d: z.point.haloPath(0)\n          }, null, z.hide);\n          a(this, \"afterSetState\", {\n            state: l\n          });\n        }\n      };\n\n      w.prototype.haloPath = function (a) {\n        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);\n      };\n\n      return w;\n    }();\n\n    \"\";\n    return h;\n  });\n  N(h, \"Core/Pointer.js\", [h[\"Core/Color/Color.js\"], h[\"Core/Globals.js\"], h[\"Core/Tooltip.js\"], h[\"Core/Utilities.js\"]], function (d, h, A, F) {\n    var t = d.parse,\n        E = h.charts,\n        H = h.noop,\n        y = F.addEvent,\n        q = F.attr,\n        p = F.css,\n        f = F.defined,\n        c = F.extend,\n        a = F.find,\n        n = F.fireEvent,\n        m = F.isNumber,\n        D = F.isObject,\n        C = F.objectEach,\n        I = F.offset,\n        L = F.pick,\n        K = F.splat;\n\n    d = function () {\n      function d(a, c) {\n        this.lastValidTouch = {};\n        this.pinchDown = [];\n        this.runChartClick = !1;\n        this.eventsToUnbind = [];\n        this.chart = a;\n        this.hasDragged = !1;\n        this.options = c;\n        this.init(a, c);\n      }\n\n      d.prototype.applyInactiveState = function (a) {\n        var c = [],\n            k;\n        (a || []).forEach(function (a) {\n          k = a.series;\n          c.push(k);\n          k.linkedParent && c.push(k.linkedParent);\n          k.linkedSeries && (c = c.concat(k.linkedSeries));\n          k.navigatorSeries && c.push(k.navigatorSeries);\n        });\n        this.chart.series.forEach(function (a) {\n          -1 === c.indexOf(a) ? a.setState(\"inactive\", !0) : a.options.inactiveOtherPoints && a.setAllPointsToState(\"inactive\");\n        });\n      };\n\n      d.prototype.destroy = function () {\n        var a = this;\n        this.eventsToUnbind.forEach(function (a) {\n          return a();\n        });\n        this.eventsToUnbind = [];\n        h.chartCount || (d.unbindDocumentMouseUp && (d.unbindDocumentMouseUp = d.unbindDocumentMouseUp()), d.unbindDocumentTouchEnd && (d.unbindDocumentTouchEnd = d.unbindDocumentTouchEnd()));\n        clearInterval(a.tooltipTimeout);\n        C(a, function (c, k) {\n          a[k] = void 0;\n        });\n      };\n\n      d.prototype.drag = function (a) {\n        var c = this.chart,\n            k = c.options.chart,\n            f = this.zoomHor,\n            l = this.zoomVert,\n            e = c.plotLeft,\n            g = c.plotTop,\n            b = c.plotWidth,\n            d = c.plotHeight,\n            n = this.mouseDownX || 0,\n            r = this.mouseDownY || 0,\n            x = D(k.panning) ? k.panning && k.panning.enabled : k.panning,\n            m = k.panKey && a[k.panKey + \"Key\"],\n            z = a.chartX,\n            p = a.chartY,\n            h = this.selectionMarker;\n        if (!h || !h.touch) if (z < e ? z = e : z > e + b && (z = e + b), p < g ? p = g : p > g + d && (p = g + d), this.hasDragged = Math.sqrt(Math.pow(n - z, 2) + Math.pow(r - p, 2)), 10 < this.hasDragged) {\n          var v = c.isInsidePlot(n - e, r - g, {\n            visiblePlotOnly: !0\n          });\n          !c.hasCartesianSeries && !c.mapView || !this.zoomX && !this.zoomY || !v || m || h || (this.selectionMarker = h = c.renderer.rect(e, g, f ? 1 : b, l ? 1 : d, 0).attr({\n            \"class\": \"highcharts-selection-marker\",\n            zIndex: 7\n          }).add(), c.styledMode || h.attr({\n            fill: k.selectionMarkerFill || t(\"#335cad\").setOpacity(.25).get()\n          }));\n          h && f && (f = z - n, h.attr({\n            width: Math.abs(f),\n            x: (0 < f ? 0 : f) + n\n          }));\n          h && l && (f = p - r, h.attr({\n            height: Math.abs(f),\n            y: (0 < f ? 0 : f) + r\n          }));\n          v && !h && x && c.pan(a, k.panning);\n        }\n      };\n\n      d.prototype.dragStart = function (a) {\n        var c = this.chart;\n        c.mouseIsDown = a.type;\n        c.cancelClick = !1;\n        c.mouseDownX = this.mouseDownX = a.chartX;\n        c.mouseDownY = this.mouseDownY = a.chartY;\n      };\n\n      d.prototype.drop = function (a) {\n        var d = this,\n            k = this.chart,\n            w = this.hasPinched;\n\n        if (this.selectionMarker) {\n          var l = this.selectionMarker,\n              e = l.attr ? l.attr(\"x\") : l.x,\n              g = l.attr ? l.attr(\"y\") : l.y,\n              b = l.attr ? l.attr(\"width\") : l.width,\n              B = l.attr ? l.attr(\"height\") : l.height,\n              z = {\n            originalEvent: a,\n            xAxis: [],\n            yAxis: [],\n            x: e,\n            y: g,\n            width: b,\n            height: B\n          },\n              r = !!k.mapView;\n          if (this.hasDragged || w) k.axes.forEach(function (c) {\n            if (c.zoomEnabled && f(c.min) && (w || d[{\n              xAxis: \"zoomX\",\n              yAxis: \"zoomY\"\n            }[c.coll]]) && m(e) && m(g)) {\n              var l = c.horiz,\n                  k = \"touchend\" === a.type ? c.minPixelPadding : 0,\n                  x = c.toValue((l ? e : g) + k);\n              l = c.toValue((l ? e + b : g + B) - k);\n              z[c.coll].push({\n                axis: c,\n                min: Math.min(x, l),\n                max: Math.max(x, l)\n              });\n              r = !0;\n            }\n          }), r && n(k, \"selection\", z, function (b) {\n            k.zoom(c(b, w ? {\n              animation: !1\n            } : null));\n          });\n          m(k.index) && (this.selectionMarker = this.selectionMarker.destroy());\n          w && this.scaleGroups();\n        }\n\n        k && m(k.index) && (p(k.container, {\n          cursor: k._cursor\n        }), k.cancelClick = 10 < this.hasDragged, k.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);\n      };\n\n      d.prototype.findNearestKDPoint = function (a, c, k) {\n        var f = this.chart,\n            l = f.hoverPoint;\n        f = f.tooltip;\n        if (l && f && f.isStickyOnContact()) return l;\n        var e;\n        a.forEach(function (a) {\n          var b = !(a.noSharedTooltip && c) && 0 > a.options.findNearestPointBy.indexOf(\"y\");\n          a = a.searchPoint(k, b);\n\n          if ((b = D(a, !0) && a.series) && !(b = !D(e, !0))) {\n            b = e.distX - a.distX;\n            var g = e.dist - a.dist,\n                l = (a.series.group && a.series.group.zIndex) - (e.series.group && e.series.group.zIndex);\n            b = 0 < (0 !== b && c ? b : 0 !== g ? g : 0 !== l ? l : e.series.index > a.series.index ? -1 : 1);\n          }\n\n          b && (e = a);\n        });\n        return e;\n      };\n\n      d.prototype.getChartCoordinatesFromPoint = function (a, c) {\n        var k = a.series,\n            f = k.xAxis;\n        k = k.yAxis;\n        var l = a.shapeArgs;\n\n        if (f && k) {\n          var e = L(a.clientX, a.plotX),\n              g = a.plotY || 0;\n          a.isNode && l && m(l.x) && m(l.y) && (e = l.x, g = l.y);\n          return c ? {\n            chartX: k.len + k.pos - g,\n            chartY: f.len + f.pos - e\n          } : {\n            chartX: e + f.pos,\n            chartY: g + k.pos\n          };\n        }\n\n        if (l && l.x && l.y) return {\n          chartX: l.x,\n          chartY: l.y\n        };\n      };\n\n      d.prototype.getChartPosition = function () {\n        if (this.chartPosition) return this.chartPosition;\n        var a = this.chart.container,\n            c = I(a);\n        this.chartPosition = {\n          left: c.left,\n          top: c.top,\n          scaleX: 1,\n          scaleY: 1\n        };\n        var k = a.offsetWidth;\n        a = a.offsetHeight;\n        2 < k && 2 < a && (this.chartPosition.scaleX = c.width / k, this.chartPosition.scaleY = c.height / a);\n        return this.chartPosition;\n      };\n\n      d.prototype.getCoordinates = function (a) {\n        var c = {\n          xAxis: [],\n          yAxis: []\n        };\n        this.chart.axes.forEach(function (k) {\n          c[k.isXAxis ? \"xAxis\" : \"yAxis\"].push({\n            axis: k,\n            value: k.toValue(a[k.horiz ? \"chartX\" : \"chartY\"])\n          });\n        });\n        return c;\n      };\n\n      d.prototype.getHoverData = function (c, f, k, d, l, e) {\n        var g = [];\n        d = !(!d || !c);\n        var b = {\n          chartX: e ? e.chartX : void 0,\n          chartY: e ? e.chartY : void 0,\n          shared: l\n        };\n        n(this, \"beforeGetHoverData\", b);\n        var u = f && !f.stickyTracking ? [f] : k.filter(function (e) {\n          return b.filter ? b.filter(e) : e.visible && !(!l && e.directTouch) && L(e.options.enableMouseTracking, !0) && e.stickyTracking;\n        });\n        var w = d || !e ? c : this.findNearestKDPoint(u, l, e);\n        f = w && w.series;\n        w && (l && !f.noSharedTooltip ? (u = k.filter(function (e) {\n          return b.filter ? b.filter(e) : e.visible && !(!l && e.directTouch) && L(e.options.enableMouseTracking, !0) && !e.noSharedTooltip;\n        }), u.forEach(function (b) {\n          var e = a(b.points, function (b) {\n            return b.x === w.x && !b.isNull;\n          });\n          D(e) && (b.chart.isBoosting && (e = b.getPoint(e)), g.push(e));\n        })) : g.push(w));\n        b = {\n          hoverPoint: w\n        };\n        n(this, \"afterGetHoverData\", b);\n        return {\n          hoverPoint: b.hoverPoint,\n          hoverSeries: f,\n          hoverPoints: g\n        };\n      };\n\n      d.prototype.getPointFromEvent = function (a) {\n        a = a.target;\n\n        for (var c; a && !c;) c = a.point, a = a.parentNode;\n\n        return c;\n      };\n\n      d.prototype.onTrackerMouseOut = function (a) {\n        a = a.relatedTarget || a.toElement;\n        var c = this.chart.hoverSeries;\n        this.isDirectTouch = !1;\n        if (!(!c || !a || c.stickyTracking || this.inClass(a, \"highcharts-tooltip\") || this.inClass(a, \"highcharts-series-\" + c.index) && this.inClass(a, \"highcharts-tracker\"))) c.onMouseOut();\n      };\n\n      d.prototype.inClass = function (a, c) {\n        for (var k; a;) {\n          if (k = q(a, \"class\")) {\n            if (-1 !== k.indexOf(c)) return !0;\n            if (-1 !== k.indexOf(\"highcharts-container\")) return !1;\n          }\n\n          a = a.parentNode;\n        }\n      };\n\n      d.prototype.init = function (a, c) {\n        this.options = c;\n        this.chart = a;\n        this.runChartClick = !(!c.chart.events || !c.chart.events.click);\n        this.pinchDown = [];\n        this.lastValidTouch = {};\n        A && (a.tooltip = new A(a, c.tooltip), this.followTouchMove = L(c.tooltip.followTouchMove, !0));\n        this.setDOMEvents();\n      };\n\n      d.prototype.normalize = function (a, f) {\n        var k = a.touches,\n            d = k ? k.length ? k.item(0) : L(k.changedTouches, a.changedTouches)[0] : a;\n        f || (f = this.getChartPosition());\n        k = d.pageX - f.left;\n        d = d.pageY - f.top;\n        k /= f.scaleX;\n        d /= f.scaleY;\n        return c(a, {\n          chartX: Math.round(k),\n          chartY: Math.round(d)\n        });\n      };\n\n      d.prototype.onContainerClick = function (a) {\n        var f = this.chart,\n            k = f.hoverPoint;\n        a = this.normalize(a);\n        var d = f.plotLeft,\n            l = f.plotTop;\n        f.cancelClick || (k && this.inClass(a.target, \"highcharts-tracker\") ? (n(k.series, \"click\", c(a, {\n          point: k\n        })), f.hoverPoint && k.firePointEvent(\"click\", a)) : (c(a, this.getCoordinates(a)), f.isInsidePlot(a.chartX - d, a.chartY - l, {\n          visiblePlotOnly: !0\n        }) && n(f, \"click\", a)));\n      };\n\n      d.prototype.onContainerMouseDown = function (a) {\n        var c = 1 === ((a.buttons || a.button) & 1);\n        a = this.normalize(a);\n        if (h.isFirefox && 0 !== a.button) this.onContainerMouseMove(a);\n        if (\"undefined\" === typeof a.button || c) this.zoomOption(a), c && a.preventDefault && a.preventDefault(), this.dragStart(a);\n      };\n\n      d.prototype.onContainerMouseLeave = function (a) {\n        var c = E[L(d.hoverChartIndex, -1)],\n            k = this.chart.tooltip;\n        k && k.shouldStickOnContact() && this.inClass(a.relatedTarget, \"highcharts-tooltip-container\") || (a = this.normalize(a), c && (a.relatedTarget || a.toElement) && (c.pointer.reset(), c.pointer.chartPosition = void 0), k && !k.isHidden && this.reset());\n      };\n\n      d.prototype.onContainerMouseEnter = function (a) {\n        delete this.chartPosition;\n      };\n\n      d.prototype.onContainerMouseMove = function (a) {\n        var c = this.chart;\n        a = this.normalize(a);\n        this.setHoverChartIndex();\n        a.preventDefault || (a.returnValue = !1);\n        (\"mousedown\" === c.mouseIsDown || this.touchSelect(a)) && this.drag(a);\n        c.openMenu || !this.inClass(a.target, \"highcharts-tracker\") && !c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop, {\n          visiblePlotOnly: !0\n        }) || (this.inClass(a.target, \"highcharts-no-tooltip\") ? this.reset(!1, 0) : this.runPointActions(a));\n      };\n\n      d.prototype.onDocumentTouchEnd = function (a) {\n        var c = E[L(d.hoverChartIndex, -1)];\n        c && c.pointer.drop(a);\n      };\n\n      d.prototype.onContainerTouchMove = function (a) {\n        if (this.touchSelect(a)) this.onContainerMouseMove(a);else this.touch(a);\n      };\n\n      d.prototype.onContainerTouchStart = function (a) {\n        if (this.touchSelect(a)) this.onContainerMouseDown(a);else this.zoomOption(a), this.touch(a, !0);\n      };\n\n      d.prototype.onDocumentMouseMove = function (a) {\n        var c = this.chart,\n            k = this.chartPosition;\n        a = this.normalize(a, k);\n        var f = c.tooltip;\n        !k || f && f.isStickyOnContact() || c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop, {\n          visiblePlotOnly: !0\n        }) || this.inClass(a.target, \"highcharts-tracker\") || this.reset();\n      };\n\n      d.prototype.onDocumentMouseUp = function (a) {\n        var c = E[L(d.hoverChartIndex, -1)];\n        c && c.pointer.drop(a);\n      };\n\n      d.prototype.pinch = function (a) {\n        var f = this,\n            k = f.chart,\n            d = f.pinchDown,\n            l = a.touches || [],\n            e = l.length,\n            g = f.lastValidTouch,\n            b = f.hasZoom,\n            B = {},\n            m = 1 === e && (f.inClass(a.target, \"highcharts-tracker\") && k.runTrackerClick || f.runChartClick),\n            r = {},\n            x = f.selectionMarker;\n        1 < e ? f.initiated = !0 : 1 === e && this.followTouchMove && (f.initiated = !1);\n        b && f.initiated && !m && !1 !== a.cancelable && a.preventDefault();\n        [].map.call(l, function (b) {\n          return f.normalize(b);\n        });\n        \"touchstart\" === a.type ? ([].forEach.call(l, function (b, e) {\n          d[e] = {\n            chartX: b.chartX,\n            chartY: b.chartY\n          };\n        }), g.x = [d[0].chartX, d[1] && d[1].chartX], g.y = [d[0].chartY, d[1] && d[1].chartY], k.axes.forEach(function (b) {\n          if (b.zoomEnabled) {\n            var e = k.bounds[b.horiz ? \"h\" : \"v\"],\n                a = b.minPixelPadding,\n                g = b.toPixels(Math.min(L(b.options.min, b.dataMin), b.dataMin)),\n                c = b.toPixels(Math.max(L(b.options.max, b.dataMax), b.dataMax)),\n                l = Math.max(g, c);\n            e.min = Math.min(b.pos, Math.min(g, c) - a);\n            e.max = Math.max(b.pos + b.len, l + a);\n          }\n        }), f.res = !0) : f.followTouchMove && 1 === e ? this.runPointActions(f.normalize(a)) : d.length && (n(k, \"touchpan\", {\n          originalEvent: a\n        }, function () {\n          x || (f.selectionMarker = x = c({\n            destroy: H,\n            touch: !0\n          }, k.plotBox));\n          f.pinchTranslate(d, l, B, x, r, g);\n          f.hasPinched = b;\n          f.scaleGroups(B, r);\n        }), f.res && (f.res = !1, this.reset(!1, 0)));\n      };\n\n      d.prototype.pinchTranslate = function (a, c, k, f, l, e) {\n        this.zoomHor && this.pinchTranslateDirection(!0, a, c, k, f, l, e);\n        this.zoomVert && this.pinchTranslateDirection(!1, a, c, k, f, l, e);\n      };\n\n      d.prototype.pinchTranslateDirection = function (a, c, k, f, l, e, g, b) {\n        var d = this.chart,\n            n = a ? \"x\" : \"y\",\n            r = a ? \"X\" : \"Y\",\n            x = \"chart\" + r,\n            m = a ? \"width\" : \"height\",\n            w = d[\"plot\" + (a ? \"Left\" : \"Top\")],\n            u = d.inverted,\n            p = d.bounds[a ? \"h\" : \"v\"],\n            h = 1 === c.length,\n            v = c[0][x],\n            z = !h && c[1][x];\n\n        c = function () {\n          \"number\" === typeof I && 20 < Math.abs(v - z) && (C = b || Math.abs(R - I) / Math.abs(v - z));\n          Q = (w - R) / C + v;\n          q = d[\"plot\" + (a ? \"Width\" : \"Height\")] / C;\n        };\n\n        var q,\n            Q,\n            C = b || 1,\n            R = k[0][x],\n            I = !h && k[1][x];\n        c();\n        k = Q;\n\n        if (k < p.min) {\n          k = p.min;\n          var D = !0;\n        } else k + q > p.max && (k = p.max - q, D = !0);\n\n        D ? (R -= .8 * (R - g[n][0]), \"number\" === typeof I && (I -= .8 * (I - g[n][1])), c()) : g[n] = [R, I];\n        u || (e[n] = Q - w, e[m] = q);\n        e = u ? 1 / C : C;\n        l[m] = q;\n        l[n] = k;\n        f[u ? a ? \"scaleY\" : \"scaleX\" : \"scale\" + r] = C;\n        f[\"translate\" + r] = e * w + (R - e * v);\n      };\n\n      d.prototype.reset = function (a, c) {\n        var k = this.chart,\n            f = k.hoverSeries,\n            l = k.hoverPoint,\n            e = k.hoverPoints,\n            g = k.tooltip,\n            b = g && g.shared ? e : l;\n        a && b && K(b).forEach(function (b) {\n          b.series.isCartesian && \"undefined\" === typeof b.plotX && (a = !1);\n        });\n        if (a) g && b && K(b).length && (g.refresh(b), g.shared && e ? e.forEach(function (b) {\n          b.setState(b.state, !0);\n          b.series.isCartesian && (b.series.xAxis.crosshair && b.series.xAxis.drawCrosshair(null, b), b.series.yAxis.crosshair && b.series.yAxis.drawCrosshair(null, b));\n        }) : l && (l.setState(l.state, !0), k.axes.forEach(function (b) {\n          b.crosshair && l.series[b.coll] === b && b.drawCrosshair(null, l);\n        })));else {\n          if (l) l.onMouseOut();\n          e && e.forEach(function (b) {\n            b.setState();\n          });\n          if (f) f.onMouseOut();\n          g && g.hide(c);\n          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());\n          k.axes.forEach(function (b) {\n            b.hideCrosshair();\n          });\n          this.hoverX = k.hoverPoints = k.hoverPoint = null;\n        }\n      };\n\n      d.prototype.runPointActions = function (c, f) {\n        var k = this.chart,\n            n = k.tooltip && k.tooltip.options.enabled ? k.tooltip : void 0,\n            l = n ? n.shared : !1,\n            e = f || k.hoverPoint,\n            g = e && e.series || k.hoverSeries;\n        f = this.getHoverData(e, g, k.series, (!c || \"touchmove\" !== c.type) && (!!f || g && g.directTouch && this.isDirectTouch), l, c);\n        e = f.hoverPoint;\n        g = f.hoverSeries;\n        var b = f.hoverPoints;\n        f = g && g.tooltipOptions.followPointer && !g.tooltipOptions.split;\n        l = l && g && !g.noSharedTooltip;\n\n        if (e && (e !== k.hoverPoint || n && n.isHidden)) {\n          (k.hoverPoints || []).forEach(function (a) {\n            -1 === b.indexOf(a) && a.setState();\n          });\n          if (k.hoverSeries !== g) g.onMouseOver();\n          this.applyInactiveState(b);\n          (b || []).forEach(function (b) {\n            b.setState(\"hover\");\n          });\n          k.hoverPoint && k.hoverPoint.firePointEvent(\"mouseOut\");\n          if (!e.series) return;\n          k.hoverPoints = b;\n          k.hoverPoint = e;\n          e.firePointEvent(\"mouseOver\");\n          n && n.refresh(l ? b : e, c);\n        } else f && n && !n.isHidden && (e = n.getAnchor([{}], c), k.isInsidePlot(e[0], e[1], {\n          visiblePlotOnly: !0\n        }) && n.updatePosition({\n          plotX: e[0],\n          plotY: e[1]\n        }));\n\n        this.unDocMouseMove || (this.unDocMouseMove = y(k.container.ownerDocument, \"mousemove\", function (b) {\n          var a = E[d.hoverChartIndex];\n          if (a) a.pointer.onDocumentMouseMove(b);\n        }), this.eventsToUnbind.push(this.unDocMouseMove));\n        k.axes.forEach(function (e) {\n          var g = L((e.crosshair || {}).snap, !0),\n              l;\n          g && ((l = k.hoverPoint) && l.series[e.coll] === e || (l = a(b, function (b) {\n            return b.series[e.coll] === e;\n          })));\n          l || !g ? e.drawCrosshair(c, l) : e.hideCrosshair();\n        });\n      };\n\n      d.prototype.scaleGroups = function (a, c) {\n        var k = this.chart;\n        k.series.forEach(function (f) {\n          var l = a || f.getPlotBox();\n          f.group && (f.xAxis && f.xAxis.zoomEnabled || k.mapView) && (f.group.attr(l), f.markerGroup && (f.markerGroup.attr(l), f.markerGroup.clip(c ? k.clipRect : null)), f.dataLabelsGroup && f.dataLabelsGroup.attr(l));\n        });\n        k.clipRect.attr(c || k.clipBox);\n      };\n\n      d.prototype.setDOMEvents = function () {\n        var a = this,\n            c = this.chart.container,\n            k = c.ownerDocument;\n        c.onmousedown = this.onContainerMouseDown.bind(this);\n        c.onmousemove = this.onContainerMouseMove.bind(this);\n        c.onclick = this.onContainerClick.bind(this);\n        this.eventsToUnbind.push(y(c, \"mouseenter\", this.onContainerMouseEnter.bind(this)));\n        this.eventsToUnbind.push(y(c, \"mouseleave\", this.onContainerMouseLeave.bind(this)));\n        d.unbindDocumentMouseUp || (d.unbindDocumentMouseUp = y(k, \"mouseup\", this.onDocumentMouseUp.bind(this)));\n\n        for (var f = this.chart.renderTo.parentElement; f && \"BODY\" !== f.tagName;) this.eventsToUnbind.push(y(f, \"scroll\", function () {\n          delete a.chartPosition;\n        })), f = f.parentElement;\n\n        h.hasTouch && (this.eventsToUnbind.push(y(c, \"touchstart\", this.onContainerTouchStart.bind(this), {\n          passive: !1\n        })), this.eventsToUnbind.push(y(c, \"touchmove\", this.onContainerTouchMove.bind(this), {\n          passive: !1\n        })), d.unbindDocumentTouchEnd || (d.unbindDocumentTouchEnd = y(k, \"touchend\", this.onDocumentTouchEnd.bind(this), {\n          passive: !1\n        })));\n      };\n\n      d.prototype.setHoverChartIndex = function () {\n        var a = this.chart,\n            c = h.charts[L(d.hoverChartIndex, -1)];\n        if (c && c !== a) c.pointer.onContainerMouseLeave({\n          relatedTarget: !0\n        });\n        c && c.mouseIsDown || (d.hoverChartIndex = a.index);\n      };\n\n      d.prototype.touch = function (a, c) {\n        var k = this.chart,\n            f;\n        this.setHoverChartIndex();\n        if (1 === a.touches.length) {\n          if (a = this.normalize(a), (f = k.isInsidePlot(a.chartX - k.plotLeft, a.chartY - k.plotTop, {\n            visiblePlotOnly: !0\n          })) && !k.openMenu) {\n            c && this.runPointActions(a);\n\n            if (\"touchmove\" === a.type) {\n              c = this.pinchDown;\n              var l = c[0] ? 4 <= Math.sqrt(Math.pow(c[0].chartX - a.chartX, 2) + Math.pow(c[0].chartY - a.chartY, 2)) : !1;\n            }\n\n            L(l, !0) && this.pinch(a);\n          } else c && this.reset();\n        } else 2 === a.touches.length && this.pinch(a);\n      };\n\n      d.prototype.touchSelect = function (a) {\n        return !(!this.chart.options.chart.zoomBySingleTouch || !a.touches || 1 !== a.touches.length);\n      };\n\n      d.prototype.zoomOption = function (a) {\n        var c = this.chart,\n            k = c.options.chart;\n        c = c.inverted;\n        var f = k.zoomType || \"\";\n        /touch/.test(a.type) && (f = L(k.pinchType, f));\n        this.zoomX = a = /x/.test(f);\n        this.zoomY = k = /y/.test(f);\n        this.zoomHor = a && !c || k && c;\n        this.zoomVert = k && !c || a && c;\n        this.hasZoom = a || k;\n      };\n\n      return d;\n    }();\n\n    \"\";\n    return d;\n  });\n  N(h, \"Core/MSPointer.js\", [h[\"Core/Globals.js\"], h[\"Core/Pointer.js\"], h[\"Core/Utilities.js\"]], function (d, h, A) {\n    function E() {\n      var c = [];\n\n      c.item = function (a) {\n        return this[a];\n      };\n\n      a(m, function (a) {\n        c.push({\n          pageX: a.pageX,\n          pageY: a.pageY,\n          target: a.target\n        });\n      });\n      return c;\n    }\n\n    function t(a, c, f, d) {\n      var n = H[h.hoverChartIndex || NaN];\n      \"touch\" !== a.pointerType && a.pointerType !== a.MSPOINTER_TYPE_TOUCH || !n || (n = n.pointer, d(a), n[c]({\n        type: f,\n        target: a.currentTarget,\n        preventDefault: q,\n        touches: E()\n      }));\n    }\n\n    var G = this && this.__extends || function () {\n      var a = function (c, f) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, c) {\n          a.__proto__ = c;\n        } || function (a, c) {\n          for (var f in c) c.hasOwnProperty(f) && (a[f] = c[f]);\n        };\n\n        return a(c, f);\n      };\n\n      return function (c, f) {\n        function d() {\n          this.constructor = c;\n        }\n\n        a(c, f);\n        c.prototype = null === f ? Object.create(f) : (d.prototype = f.prototype, new d());\n      };\n    }(),\n        H = d.charts,\n        y = d.doc,\n        q = d.noop,\n        p = d.win,\n        f = A.addEvent,\n        c = A.css,\n        a = A.objectEach,\n        n = A.removeEvent,\n        m = {},\n        D = !!p.PointerEvent;\n\n    return function (a) {\n      function h() {\n        return null !== a && a.apply(this, arguments) || this;\n      }\n\n      G(h, a);\n\n      h.isRequired = function () {\n        return !(d.hasTouch || !p.PointerEvent && !p.MSPointerEvent);\n      };\n\n      h.prototype.batchMSEvents = function (a) {\n        a(this.chart.container, D ? \"pointerdown\" : \"MSPointerDown\", this.onContainerPointerDown);\n        a(this.chart.container, D ? \"pointermove\" : \"MSPointerMove\", this.onContainerPointerMove);\n        a(y, D ? \"pointerup\" : \"MSPointerUp\", this.onDocumentPointerUp);\n      };\n\n      h.prototype.destroy = function () {\n        this.batchMSEvents(n);\n        a.prototype.destroy.call(this);\n      };\n\n      h.prototype.init = function (f, d) {\n        a.prototype.init.call(this, f, d);\n        this.hasZoom && c(f.container, {\n          \"-ms-touch-action\": \"none\",\n          \"touch-action\": \"none\"\n        });\n      };\n\n      h.prototype.onContainerPointerDown = function (a) {\n        t(a, \"onContainerTouchStart\", \"touchstart\", function (a) {\n          m[a.pointerId] = {\n            pageX: a.pageX,\n            pageY: a.pageY,\n            target: a.currentTarget\n          };\n        });\n      };\n\n      h.prototype.onContainerPointerMove = function (a) {\n        t(a, \"onContainerTouchMove\", \"touchmove\", function (a) {\n          m[a.pointerId] = {\n            pageX: a.pageX,\n            pageY: a.pageY\n          };\n          m[a.pointerId].target || (m[a.pointerId].target = a.currentTarget);\n        });\n      };\n\n      h.prototype.onDocumentPointerUp = function (a) {\n        t(a, \"onDocumentTouchEnd\", \"touchend\", function (a) {\n          delete m[a.pointerId];\n        });\n      };\n\n      h.prototype.setDOMEvents = function () {\n        a.prototype.setDOMEvents.call(this);\n        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(f);\n      };\n\n      return h;\n    }(h);\n  });\n  N(h, \"Core/Legend/Legend.js\", [h[\"Core/Animation/AnimationUtilities.js\"], h[\"Core/FormatUtilities.js\"], h[\"Core/Globals.js\"], h[\"Core/Series/Point.js\"], h[\"Core/Renderer/RendererUtilities.js\"], h[\"Core/Utilities.js\"]], function (d, h, A, F, t, G) {\n    var E = d.animObject,\n        y = d.setAnimation,\n        q = h.format;\n    d = A.isFirefox;\n    var p = A.marginNames;\n    A = A.win;\n    var f = t.distribute,\n        c = G.addEvent,\n        a = G.createElement,\n        n = G.css,\n        m = G.defined,\n        D = G.discardElement,\n        C = G.find,\n        I = G.fireEvent,\n        L = G.isNumber,\n        K = G.merge,\n        v = G.pick,\n        z = G.relativeLength,\n        u = G.stableSort,\n        k = G.syncTimeout;\n    t = G.wrap;\n\n    G = function () {\n      function d(a, e) {\n        this.allItems = [];\n        this.contentGroup = this.box = void 0;\n        this.display = !1;\n        this.group = void 0;\n        this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;\n        this.options = {};\n        this.padding = 0;\n        this.pages = [];\n        this.proximate = !1;\n        this.scrollGroup = void 0;\n        this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;\n        this.chart = a;\n        this.init(a, e);\n      }\n\n      d.prototype.init = function (a, e) {\n        this.chart = a;\n        this.setOptions(e);\n        e.enabled && (this.render(), c(this.chart, \"endResize\", function () {\n          this.legend.positionCheckboxes();\n        }), this.proximate ? this.unchartrender = c(this.chart, \"render\", function () {\n          this.legend.proximatePositions();\n          this.legend.positionItems();\n        }) : this.unchartrender && this.unchartrender());\n      };\n\n      d.prototype.setOptions = function (a) {\n        var e = v(a.padding, 8);\n        this.options = a;\n        this.chart.styledMode || (this.itemStyle = a.itemStyle, this.itemHiddenStyle = K(this.itemStyle, a.itemHiddenStyle));\n        this.itemMarginTop = a.itemMarginTop || 0;\n        this.itemMarginBottom = a.itemMarginBottom || 0;\n        this.padding = e;\n        this.initialItemY = e - 5;\n        this.symbolWidth = v(a.symbolWidth, 16);\n        this.pages = [];\n        this.proximate = \"proximate\" === a.layout && !this.chart.inverted;\n        this.baseline = void 0;\n      };\n\n      d.prototype.update = function (a, e) {\n        var g = this.chart;\n        this.setOptions(K(!0, this.options, a));\n        this.destroy();\n        g.isDirtyLegend = g.isDirtyBox = !0;\n        v(e, !0) && g.redraw();\n        I(this, \"afterUpdate\");\n      };\n\n      d.prototype.colorizeItem = function (a, e) {\n        a.legendGroup[e ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\");\n\n        if (!this.chart.styledMode) {\n          var g = this.options,\n              b = a.legendItem,\n              c = a.legendLine,\n              l = a.legendSymbol,\n              k = this.itemHiddenStyle.color;\n          g = e ? g.itemStyle.color : k;\n          var f = e ? a.color || k : k,\n              d = a.options && a.options.marker,\n              n = {\n            fill: f\n          };\n          b && b.css({\n            fill: g,\n            color: g\n          });\n          c && c.attr({\n            stroke: f\n          });\n          l && (d && l.isMarker && (n = a.pointAttribs(), e || (n.stroke = n.fill = k)), l.attr(n));\n        }\n\n        I(this, \"afterColorizeItem\", {\n          item: a,\n          visible: e\n        });\n      };\n\n      d.prototype.positionItems = function () {\n        this.allItems.forEach(this.positionItem, this);\n        this.chart.isResizing || this.positionCheckboxes();\n      };\n\n      d.prototype.positionItem = function (a) {\n        var e = this,\n            g = this.options,\n            b = g.symbolPadding,\n            c = !g.rtl,\n            l = a._legendItemPos;\n        g = l[0];\n        l = l[1];\n        var k = a.checkbox,\n            f = a.legendGroup;\n        f && f.element && (b = {\n          translateX: c ? g : this.legendWidth - g - 2 * b - 4,\n          translateY: l\n        }, c = function () {\n          I(e, \"afterPositionItem\", {\n            item: a\n          });\n        }, m(f.translateY) ? f.animate(b, void 0, c) : (f.attr(b), c()));\n        k && (k.x = g, k.y = l);\n      };\n\n      d.prototype.destroyItem = function (a) {\n        var e = a.checkbox;\n        [\"legendItem\", \"legendLine\", \"legendSymbol\", \"legendGroup\"].forEach(function (e) {\n          a[e] && (a[e] = a[e].destroy());\n        });\n        e && D(a.checkbox);\n      };\n\n      d.prototype.destroy = function () {\n        function a(a) {\n          this[a] && (this[a] = this[a].destroy());\n        }\n\n        this.getAllItems().forEach(function (e) {\n          [\"legendItem\", \"legendGroup\"].forEach(a, e);\n        });\n        \"clipRect up down pager nav box title group\".split(\" \").forEach(a, this);\n        this.display = null;\n      };\n\n      d.prototype.positionCheckboxes = function () {\n        var a = this.group && this.group.alignAttr,\n            e = this.clipHeight || this.legendHeight,\n            g = this.titleHeight;\n\n        if (a) {\n          var b = a.translateY;\n          this.allItems.forEach(function (c) {\n            var l = c.checkbox;\n\n            if (l) {\n              var k = b + g + l.y + (this.scrollOffset || 0) + 3;\n              n(l, {\n                left: a.translateX + c.checkboxOffset + l.x - 20 + \"px\",\n                top: k + \"px\",\n                display: this.proximate || k > b - 6 && k < b + e - 6 ? \"\" : \"none\"\n              });\n            }\n          }, this);\n        }\n      };\n\n      d.prototype.renderTitle = function () {\n        var a = this.options,\n            e = this.padding,\n            g = a.title,\n            b = 0;\n        g.text && (this.title || (this.title = this.chart.renderer.label(g.text, e - 3, e - 4, null, null, null, a.useHTML, null, \"legend-title\").attr({\n          zIndex: 1\n        }), this.chart.styledMode || this.title.css(g.style), this.title.add(this.group)), g.width || this.title.css({\n          width: this.maxLegendWidth + \"px\"\n        }), a = this.title.getBBox(), b = a.height, this.offsetWidth = a.width, this.contentGroup.attr({\n          translateY: b\n        }));\n        this.titleHeight = b;\n      };\n\n      d.prototype.setText = function (a) {\n        var e = this.options;\n        a.legendItem.attr({\n          text: e.labelFormat ? q(e.labelFormat, a, this.chart) : e.labelFormatter.call(a)\n        });\n      };\n\n      d.prototype.renderItem = function (a) {\n        var e = this.chart,\n            g = e.renderer,\n            b = this.options,\n            c = this.symbolWidth,\n            k = b.symbolPadding || 0,\n            l = this.itemStyle,\n            f = this.itemHiddenStyle,\n            d = \"horizontal\" === b.layout ? v(b.itemDistance, 20) : 0,\n            n = !b.rtl,\n            m = !a.series,\n            p = !m && a.series.drawLegendSymbol ? a.series : a,\n            h = p.options,\n            u = this.createCheckboxForItem && h && h.showCheckbox,\n            w = b.useHTML,\n            q = a.options.className,\n            Q = a.legendItem;\n        h = c + k + d + (u ? 20 : 0);\n        Q || (a.legendGroup = g.g(\"legend-item\").addClass(\"highcharts-\" + p.type + \"-series highcharts-color-\" + a.colorIndex + (q ? \" \" + q : \"\") + (m ? \" highcharts-series-\" + a.index : \"\")).attr({\n          zIndex: 1\n        }).add(this.scrollGroup), a.legendItem = Q = g.text(\"\", n ? c + k : -k, this.baseline || 0, w), e.styledMode || Q.css(K(a.visible ? l : f)), Q.attr({\n          align: n ? \"left\" : \"right\",\n          zIndex: 2\n        }).add(a.legendGroup), this.baseline || (this.fontMetrics = g.fontMetrics(e.styledMode ? 12 : l.fontSize, Q), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, Q.attr(\"y\", this.baseline), this.symbolHeight = b.symbolHeight || this.fontMetrics.f, b.squareSymbol && (this.symbolWidth = v(b.symbolWidth, Math.max(this.symbolHeight, 16)), h = this.symbolWidth + k + d + (u ? 20 : 0), n && Q.attr(\"x\", this.symbolWidth + k))), p.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, Q, w));\n        u && !a.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(a);\n        this.colorizeItem(a, a.visible);\n        !e.styledMode && l.width || Q.css({\n          width: (b.itemWidth || this.widthOption || e.spacingBox.width) - h + \"px\"\n        });\n        this.setText(a);\n        e = Q.getBBox();\n        g = this.fontMetrics && this.fontMetrics.h || 0;\n        a.itemWidth = a.checkboxOffset = b.itemWidth || a.legendItemWidth || e.width + h;\n        this.maxItemWidth = Math.max(this.maxItemWidth, a.itemWidth);\n        this.totalItemWidth += a.itemWidth;\n        this.itemHeight = a.itemHeight = Math.round(a.legendItemHeight || (e.height > 1.5 * g ? e.height : g));\n      };\n\n      d.prototype.layoutItem = function (a) {\n        var e = this.options,\n            g = this.padding,\n            b = \"horizontal\" === e.layout,\n            c = a.itemHeight,\n            k = this.itemMarginBottom,\n            l = this.itemMarginTop,\n            f = b ? v(e.itemDistance, 20) : 0,\n            d = this.maxLegendWidth;\n        e = e.alignColumns && this.totalItemWidth > d ? this.maxItemWidth : a.itemWidth;\n        b && this.itemX - g + e > d && (this.itemX = g, this.lastLineHeight && (this.itemY += l + this.lastLineHeight + k), this.lastLineHeight = 0);\n        this.lastItemY = l + this.itemY + k;\n        this.lastLineHeight = Math.max(c, this.lastLineHeight);\n        a._legendItemPos = [this.itemX, this.itemY];\n        b ? this.itemX += e : (this.itemY += l + c + k, this.lastLineHeight = c);\n        this.offsetWidth = this.widthOption || Math.max((b ? this.itemX - g - (a.checkbox ? 0 : f) : e) + g, this.offsetWidth);\n      };\n\n      d.prototype.getAllItems = function () {\n        var a = [];\n        this.chart.series.forEach(function (e) {\n          var g = e && e.options;\n          e && v(g.showInLegend, m(g.linkedTo) ? !1 : void 0, !0) && (a = a.concat(e.legendItems || (\"point\" === g.legendType ? e.data : e)));\n        });\n        I(this, \"afterGetAllItems\", {\n          allItems: a\n        });\n        return a;\n      };\n\n      d.prototype.getAlignment = function () {\n        var a = this.options;\n        return this.proximate ? a.align.charAt(0) + \"tv\" : a.floating ? \"\" : a.align.charAt(0) + a.verticalAlign.charAt(0) + a.layout.charAt(0);\n      };\n\n      d.prototype.adjustMargins = function (a, e) {\n        var g = this.chart,\n            b = this.options,\n            c = this.getAlignment();\n        c && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (k, l) {\n          k.test(c) && !m(a[l]) && (g[p[l]] = Math.max(g[p[l]], g.legend[(l + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [1, -1, -1, 1][l] * b[l % 2 ? \"x\" : \"y\"] + v(b.margin, 12) + e[l] + (g.titleOffset[l] || 0)));\n        });\n      };\n\n      d.prototype.proximatePositions = function () {\n        var a = this.chart,\n            e = [],\n            g = \"left\" === this.options.align;\n        this.allItems.forEach(function (b) {\n          var c;\n          var k = g;\n\n          if (b.yAxis) {\n            b.xAxis.options.reversed && (k = !k);\n            b.points && (c = C(k ? b.points : b.points.slice(0).reverse(), function (b) {\n              return L(b.plotY);\n            }));\n            k = this.itemMarginTop + b.legendItem.getBBox().height + this.itemMarginBottom;\n            var l = b.yAxis.top - a.plotTop;\n            b.visible ? (c = c ? c.plotY : b.yAxis.height, c += l - .3 * k) : c = l + b.yAxis.height;\n            e.push({\n              target: c,\n              size: k,\n              item: b\n            });\n          }\n        }, this);\n        f(e, a.plotHeight).forEach(function (b) {\n          b.item._legendItemPos && (b.item._legendItemPos[1] = a.plotTop - a.spacing[0] + b.pos);\n        });\n      };\n\n      d.prototype.render = function () {\n        var a = this.chart,\n            e = a.renderer,\n            g = this.options,\n            b = this.padding,\n            c = this.getAllItems(),\n            k = this.group,\n            f = this.box;\n        this.itemX = b;\n        this.itemY = this.initialItemY;\n        this.lastItemY = this.offsetWidth = 0;\n        this.widthOption = z(g.width, a.spacingBox.width - b);\n        var d = a.spacingBox.width - 2 * b - g.x;\n        -1 < [\"rm\", \"lm\"].indexOf(this.getAlignment().substring(0, 2)) && (d /= 2);\n        this.maxLegendWidth = this.widthOption || d;\n        k || (this.group = k = e.g(\"legend\").addClass(g.className || \"\").attr({\n          zIndex: 7\n        }).add(), this.contentGroup = e.g().attr({\n          zIndex: 1\n        }).add(k), this.scrollGroup = e.g().add(this.contentGroup));\n        this.renderTitle();\n        u(c, function (b, a) {\n          return (b.options && b.options.legendIndex || 0) - (a.options && a.options.legendIndex || 0);\n        });\n        g.reversed && c.reverse();\n        this.allItems = c;\n        this.display = d = !!c.length;\n        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;\n        c.forEach(this.renderItem, this);\n        c.forEach(this.layoutItem, this);\n        c = (this.widthOption || this.offsetWidth) + b;\n        var n = this.lastItemY + this.lastLineHeight + this.titleHeight;\n        n = this.handleOverflow(n);\n        n += b;\n        f || (this.box = f = e.rect().addClass(\"highcharts-legend-box\").attr({\n          r: g.borderRadius\n        }).add(k), f.isNew = !0);\n        a.styledMode || f.attr({\n          stroke: g.borderColor,\n          \"stroke-width\": g.borderWidth || 0,\n          fill: g.backgroundColor || \"none\"\n        }).shadow(g.shadow);\n        0 < c && 0 < n && (f[f.isNew ? \"attr\" : \"animate\"](f.crisp.call({}, {\n          x: 0,\n          y: 0,\n          width: c,\n          height: n\n        }, f.strokeWidth())), f.isNew = !1);\n        f[d ? \"show\" : \"hide\"]();\n        a.styledMode && \"none\" === k.getStyle(\"display\") && (c = n = 0);\n        this.legendWidth = c;\n        this.legendHeight = n;\n        d && this.align();\n        this.proximate || this.positionItems();\n        I(this, \"afterRender\");\n      };\n\n      d.prototype.align = function (a) {\n        void 0 === a && (a = this.chart.spacingBox);\n        var e = this.chart,\n            g = this.options,\n            b = a.y;\n        /(lth|ct|rth)/.test(this.getAlignment()) && 0 < e.titleOffset[0] ? b += e.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < e.titleOffset[2] && (b -= e.titleOffset[2]);\n        b !== a.y && (a = K(a, {\n          y: b\n        }));\n        this.group.align(K(g, {\n          width: this.legendWidth,\n          height: this.legendHeight,\n          verticalAlign: this.proximate ? \"top\" : g.verticalAlign\n        }), !0, a);\n      };\n\n      d.prototype.handleOverflow = function (a) {\n        var e = this,\n            g = this.chart,\n            b = g.renderer,\n            c = this.options,\n            k = c.y,\n            f = \"top\" === c.verticalAlign,\n            l = this.padding,\n            d = c.maxHeight,\n            n = c.navigation,\n            m = v(n.animation, !0),\n            p = n.arrowSize || 12,\n            h = this.pages,\n            u = this.allItems,\n            w = function (b) {\n          \"number\" === typeof b ? C.attr({\n            height: b\n          }) : C && (e.clipRect = C.destroy(), e.contentGroup.clip());\n          e.contentGroup.div && (e.contentGroup.div.style.clip = b ? \"rect(\" + l + \"px,9999px,\" + (l + b) + \"px,0)\" : \"auto\");\n        },\n            q = function (a) {\n          e[a] = b.circle(0, 0, 1.3 * p).translate(p / 2, p / 2).add(R);\n          g.styledMode || e[a].attr(\"fill\", \"rgba(0,0,0,0.0001)\");\n          return e[a];\n        },\n            Q,\n            z;\n\n        k = g.spacingBox.height + (f ? -k : k) - l;\n        var R = this.nav,\n            C = this.clipRect;\n        \"horizontal\" !== c.layout || \"middle\" === c.verticalAlign || c.floating || (k /= 2);\n        d && (k = Math.min(k, d));\n        h.length = 0;\n        a && 0 < k && a > k && !1 !== n.enabled ? (this.clipHeight = Q = Math.max(k - 20 - this.titleHeight - l, 0), this.currentPage = v(this.currentPage, 1), this.fullHeight = a, u.forEach(function (b, a) {\n          var e = b._legendItemPos[1],\n              g = Math.round(b.legendItem.getBBox().height),\n              c = h.length;\n          if (!c || e - h[c - 1] > Q && (z || e) !== h[c - 1]) h.push(z || e), c++;\n          b.pageIx = c - 1;\n          z && (u[a - 1].pageIx = c - 1);\n          a === u.length - 1 && e + g - h[c - 1] > Q && g <= Q && (h.push(e), b.pageIx = c);\n          e !== z && (z = e);\n        }), C || (C = e.clipRect = b.clipRect(0, l, 9999, 0), e.contentGroup.clip(C)), w(Q), R || (this.nav = R = b.g().attr({\n          zIndex: 1\n        }).add(this.group), this.up = b.symbol(\"triangle\", 0, 0, p, p).add(R), q(\"upTracker\").on(\"click\", function () {\n          e.scroll(-1, m);\n        }), this.pager = b.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\"), g.styledMode || this.pager.css(n.style), this.pager.add(R), this.down = b.symbol(\"triangle-down\", 0, 0, p, p).add(R), q(\"downTracker\").on(\"click\", function () {\n          e.scroll(1, m);\n        })), e.scroll(0), a = k) : R && (w(), this.nav = R.destroy(), this.scrollGroup.attr({\n          translateY: 1\n        }), this.clipHeight = 0);\n        return a;\n      };\n\n      d.prototype.scroll = function (a, e) {\n        var g = this,\n            b = this.chart,\n            c = this.pages,\n            f = c.length,\n            l = this.clipHeight,\n            d = this.options.navigation,\n            n = this.pager,\n            m = this.padding,\n            p = this.currentPage + a;\n        p > f && (p = f);\n        0 < p && (\"undefined\" !== typeof e && y(e, b), this.nav.attr({\n          translateX: m,\n          translateY: l + this.padding + 7 + this.titleHeight,\n          visibility: \"visible\"\n        }), [this.up, this.upTracker].forEach(function (b) {\n          b.attr({\n            \"class\": 1 === p ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }), n.attr({\n          text: p + \"/\" + f\n        }), [this.down, this.downTracker].forEach(function (b) {\n          b.attr({\n            x: 18 + this.pager.getBBox().width,\n            \"class\": p === f ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }, this), b.styledMode || (this.up.attr({\n          fill: 1 === p ? d.inactiveColor : d.activeColor\n        }), this.upTracker.css({\n          cursor: 1 === p ? \"default\" : \"pointer\"\n        }), this.down.attr({\n          fill: p === f ? d.inactiveColor : d.activeColor\n        }), this.downTracker.css({\n          cursor: p === f ? \"default\" : \"pointer\"\n        })), this.scrollOffset = -c[p - 1] + this.initialItemY, this.scrollGroup.animate({\n          translateY: this.scrollOffset\n        }), this.currentPage = p, this.positionCheckboxes(), a = E(v(e, b.renderer.globalAnimation, !0)), k(function () {\n          I(g, \"afterScroll\", {\n            currentPage: p\n          });\n        }, a.duration));\n      };\n\n      d.prototype.setItemEvents = function (a, e, g) {\n        var b = this,\n            c = b.chart.renderer.boxWrapper,\n            k = a instanceof F,\n            f = \"highcharts-legend-\" + (k ? \"point\" : \"series\") + \"-active\",\n            l = b.chart.styledMode,\n            d = function (e) {\n          b.allItems.forEach(function (b) {\n            a !== b && [b].concat(b.linkedSeries || []).forEach(function (b) {\n              b.setState(e, !k);\n            });\n          });\n        };\n\n        (g ? [e, a.legendSymbol] : [a.legendGroup]).forEach(function (g) {\n          if (g) g.on(\"mouseover\", function () {\n            a.visible && d(\"inactive\");\n            a.setState(\"hover\");\n            a.visible && c.addClass(f);\n            l || e.css(b.options.itemHoverStyle);\n          }).on(\"mouseout\", function () {\n            b.chart.styledMode || e.css(K(a.visible ? b.itemStyle : b.itemHiddenStyle));\n            d(\"\");\n            c.removeClass(f);\n            a.setState();\n          }).on(\"click\", function (b) {\n            var e = function () {\n              a.setVisible && a.setVisible();\n              d(a.visible ? \"inactive\" : \"\");\n            };\n\n            c.removeClass(f);\n            b = {\n              browserEvent: b\n            };\n            a.firePointEvent ? a.firePointEvent(\"legendItemClick\", b, e) : I(a, \"legendItemClick\", b, e);\n          });\n        });\n      };\n\n      d.prototype.createCheckboxForItem = function (k) {\n        k.checkbox = a(\"input\", {\n          type: \"checkbox\",\n          className: \"highcharts-legend-checkbox\",\n          checked: k.selected,\n          defaultChecked: k.selected\n        }, this.options.itemCheckboxStyle, this.chart.container);\n        c(k.checkbox, \"click\", function (a) {\n          I(k.series || k, \"checkboxClick\", {\n            checked: a.target.checked,\n            item: k\n          }, function () {\n            k.select();\n          });\n        });\n      };\n\n      return d;\n    }();\n\n    (/Trident\\/7\\.0/.test(A.navigator && A.navigator.userAgent) || d) && t(G.prototype, \"positionItem\", function (a, c) {\n      var e = this,\n          g = function () {\n        c._legendItemPos && a.call(e, c);\n      };\n\n      g();\n      e.bubbleLegend || setTimeout(g);\n    });\n    \"\";\n    return G;\n  });\n  N(h, \"Core/Series/SeriesRegistry.js\", [h[\"Core/Globals.js\"], h[\"Core/DefaultOptions.js\"], h[\"Core/Series/Point.js\"], h[\"Core/Utilities.js\"]], function (d, h, A, F) {\n    var t = h.defaultOptions,\n        E = F.error,\n        H = F.extendClass,\n        y = F.merge,\n        q;\n\n    (function (p) {\n      function f(c, a) {\n        var f = t.plotOptions || {},\n            d = a.defaultOptions;\n        a.prototype.pointClass || (a.prototype.pointClass = A);\n        a.prototype.type = c;\n        d && (f[c] = d);\n        p.seriesTypes[c] = a;\n      }\n\n      p.seriesTypes = d.seriesTypes;\n\n      p.getSeries = function (c, a) {\n        void 0 === a && (a = {});\n        var f = c.options.chart;\n        f = a.type || f.type || f.defaultSeriesType || \"\";\n        var d = p.seriesTypes[f];\n        p || E(17, !0, c, {\n          missingModuleFor: f\n        });\n        f = new d();\n        \"function\" === typeof f.init && f.init(c, a);\n        return f;\n      };\n\n      p.registerSeriesType = f;\n\n      p.seriesType = function (c, a, d, m, h) {\n        var n = t.plotOptions || {};\n        a = a || \"\";\n        n[c] = y(n[a], d);\n        f(c, H(p.seriesTypes[a] || function () {}, m));\n        p.seriesTypes[c].prototype.type = c;\n        h && (p.seriesTypes[c].prototype.pointClass = H(A, h));\n        return p.seriesTypes[c];\n      };\n    })(q || (q = {}));\n\n    return q;\n  });\n  N(h, \"Core/Chart/Chart.js\", [h[\"Core/Animation/AnimationUtilities.js\"], h[\"Core/Axis/Axis.js\"], h[\"Core/FormatUtilities.js\"], h[\"Core/Foundation.js\"], h[\"Core/Globals.js\"], h[\"Core/Legend/Legend.js\"], h[\"Core/MSPointer.js\"], h[\"Core/DefaultOptions.js\"], h[\"Core/Pointer.js\"], h[\"Core/Renderer/RendererRegistry.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Renderer/SVG/SVGRenderer.js\"], h[\"Core/Time.js\"], h[\"Core/Utilities.js\"], h[\"Core/Renderer/HTML/AST.js\"]], function (d, h, A, F, t, G, H, y, q, p, f, c, a, n, m) {\n    var D = d.animate,\n        C = d.animObject,\n        I = d.setAnimation,\n        L = A.numberFormat,\n        K = F.registerEventOptions,\n        v = t.charts,\n        z = t.doc,\n        u = t.marginNames,\n        k = t.svg,\n        w = t.win,\n        l = y.defaultOptions,\n        e = y.defaultTime,\n        g = f.seriesTypes,\n        b = n.addEvent,\n        B = n.attr,\n        J = n.cleanRecursively,\n        r = n.createElement,\n        x = n.css,\n        M = n.defined,\n        X = n.discardElement,\n        P = n.erase,\n        O = n.error,\n        W = n.extend,\n        Z = n.find,\n        E = n.fireEvent,\n        aa = n.getStyle,\n        Q = n.isArray,\n        ba = n.isNumber,\n        R = n.isObject,\n        ca = n.isString,\n        T = n.merge,\n        U = n.objectEach,\n        S = n.pick,\n        da = n.pInt,\n        ia = n.relativeLength,\n        N = n.removeEvent,\n        fa = n.splat,\n        Y = n.syncTimeout,\n        ja = n.uniqueKey;\n\n    d = function () {\n      function f(b, a, e) {\n        this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.legend = this.labelCollectors = this.isResizing = this.index = this.eventOptions = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;\n        this.sharedClips = {};\n        this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = void 0;\n        this.getArgs(b, a, e);\n      }\n\n      f.chart = function (b, a, e) {\n        return new f(b, a, e);\n      };\n\n      f.prototype.getArgs = function (b, a, e) {\n        ca(b) || b.nodeName ? (this.renderTo = b, this.init(a, e)) : this.init(b, a);\n      };\n\n      f.prototype.init = function (b, e) {\n        var g = b.plotOptions || {};\n        E(this, \"init\", {\n          args: arguments\n        }, function () {\n          var c = T(l, b),\n              f = c.chart;\n          U(c.plotOptions, function (b, a) {\n            R(b) && (b.tooltip = g[a] && T(g[a].tooltip) || void 0);\n          });\n          c.tooltip.userOptions = b.chart && b.chart.forExport && b.tooltip.userOptions || b.tooltip;\n          this.userOptions = b;\n          this.margin = [];\n          this.spacing = [];\n          this.bounds = {\n            h: {},\n            v: {}\n          };\n          this.labelCollectors = [];\n          this.callback = e;\n          this.isResizing = 0;\n          this.options = c;\n          this.axes = [];\n          this.series = [];\n          this.time = b.time && Object.keys(b.time).length ? new a(b.time) : t.time;\n          this.numberFormatter = f.numberFormatter || L;\n          this.styledMode = f.styledMode;\n          this.hasCartesianSeries = f.showAxes;\n          this.index = v.length;\n          v.push(this);\n          t.chartCount++;\n          K(this, f);\n          this.xAxis = [];\n          this.yAxis = [];\n          this.pointCount = this.colorCounter = this.symbolCounter = 0;\n          E(this, \"afterInit\");\n          this.firstRender();\n        });\n      };\n\n      f.prototype.initSeries = function (b) {\n        var a = this.options.chart;\n        a = b.type || a.type || a.defaultSeriesType;\n        var e = g[a];\n        e || O(17, !0, this, {\n          missingModuleFor: a\n        });\n        a = new e();\n        \"function\" === typeof a.init && a.init(this, b);\n        return a;\n      };\n\n      f.prototype.setSeriesData = function () {\n        this.getSeriesOrderByLinks().forEach(function (b) {\n          b.points || b.data || !b.enabledDataSorting || b.setData(b.options.data, !1);\n        });\n      };\n\n      f.prototype.getSeriesOrderByLinks = function () {\n        return this.series.concat().sort(function (b, a) {\n          return b.linkedSeries.length || a.linkedSeries.length ? a.linkedSeries.length - b.linkedSeries.length : 0;\n        });\n      };\n\n      f.prototype.orderSeries = function (b) {\n        var a = this.series;\n        b = b || 0;\n\n        for (var e = a.length; b < e; ++b) a[b] && (a[b].index = b, a[b].name = a[b].getName());\n      };\n\n      f.prototype.isInsidePlot = function (b, a, e) {\n        void 0 === e && (e = {});\n        var g = this.inverted,\n            c = this.plotBox,\n            f = this.plotLeft,\n            k = this.plotTop,\n            l = this.scrollablePlotBox,\n            d = 0;\n        var r = 0;\n        e.visiblePlotOnly && this.scrollingContainer && (r = this.scrollingContainer, d = r.scrollLeft, r = r.scrollTop);\n        var x = e.series;\n        c = e.visiblePlotOnly && l || c;\n        l = e.inverted ? a : b;\n        a = e.inverted ? b : a;\n        b = {\n          x: l,\n          y: a,\n          isInsidePlot: !0\n        };\n\n        if (!e.ignoreX) {\n          var n = x && (g ? x.yAxis : x.xAxis) || {\n            pos: f,\n            len: Infinity\n          };\n          l = e.paneCoordinates ? n.pos + l : f + l;\n          l >= Math.max(d + f, n.pos) && l <= Math.min(d + f + c.width, n.pos + n.len) || (b.isInsidePlot = !1);\n        }\n\n        !e.ignoreY && b.isInsidePlot && (g = x && (g ? x.xAxis : x.yAxis) || {\n          pos: k,\n          len: Infinity\n        }, e = e.paneCoordinates ? g.pos + a : k + a, e >= Math.max(r + k, g.pos) && e <= Math.min(r + k + c.height, g.pos + g.len) || (b.isInsidePlot = !1));\n        E(this, \"afterIsInsidePlot\", b);\n        return b.isInsidePlot;\n      };\n\n      f.prototype.redraw = function (b) {\n        E(this, \"beforeRedraw\");\n        var a = this.hasCartesianSeries ? this.axes : this.colorAxis || [],\n            e = this.series,\n            g = this.pointer,\n            c = this.legend,\n            f = this.userOptions.legend,\n            k = this.renderer,\n            l = k.isHidden(),\n            d = [],\n            r = this.isDirtyBox,\n            x = this.isDirtyLegend;\n        this.setResponsive && this.setResponsive(!1);\n        I(this.hasRendered ? b : !1, this);\n        l && this.temporaryDisplay();\n        this.layOutTitles();\n\n        for (b = e.length; b--;) {\n          var n = e[b];\n\n          if (n.options.stacking || n.options.centerInCategory) {\n            var m = !0;\n\n            if (n.isDirty) {\n              var p = !0;\n              break;\n            }\n          }\n        }\n\n        if (p) for (b = e.length; b--;) n = e[b], n.options.stacking && (n.isDirty = !0);\n        e.forEach(function (b) {\n          b.isDirty && (\"point\" === b.options.legendType ? (\"function\" === typeof b.updateTotals && b.updateTotals(), x = !0) : f && (f.labelFormatter || f.labelFormat) && (x = !0));\n          b.isDirtyData && E(b, \"updatedData\");\n        });\n        x && c && c.options.enabled && (c.render(), this.isDirtyLegend = !1);\n        m && this.getStacks();\n        a.forEach(function (b) {\n          b.updateNames();\n          b.setScale();\n        });\n        this.getMargins();\n        a.forEach(function (b) {\n          b.isDirty && (r = !0);\n        });\n        a.forEach(function (b) {\n          var a = b.min + \",\" + b.max;\n          b.extKey !== a && (b.extKey = a, d.push(function () {\n            E(b, \"afterSetExtremes\", W(b.eventArgs, b.getExtremes()));\n            delete b.eventArgs;\n          }));\n          (r || m) && b.redraw();\n        });\n        r && this.drawChartBox();\n        E(this, \"predraw\");\n        e.forEach(function (b) {\n          (r || b.isDirty) && b.visible && b.redraw();\n          b.isDirtyData = !1;\n        });\n        g && g.reset(!0);\n        k.draw();\n        E(this, \"redraw\");\n        E(this, \"render\");\n        l && this.temporaryDisplay(!0);\n        d.forEach(function (b) {\n          b.call();\n        });\n      };\n\n      f.prototype.get = function (b) {\n        function a(a) {\n          return a.id === b || a.options && a.options.id === b;\n        }\n\n        for (var e = this.series, g = Z(this.axes, a) || Z(this.series, a), c = 0; !g && c < e.length; c++) g = Z(e[c].points || [], a);\n\n        return g;\n      };\n\n      f.prototype.getAxes = function () {\n        var b = this,\n            a = this.options,\n            e = a.xAxis = fa(a.xAxis || {});\n        a = a.yAxis = fa(a.yAxis || {});\n        E(this, \"getAxes\");\n        e.forEach(function (b, a) {\n          b.index = a;\n          b.isX = !0;\n        });\n        a.forEach(function (b, a) {\n          b.index = a;\n        });\n        e.concat(a).forEach(function (a) {\n          new h(b, a);\n        });\n        E(this, \"afterGetAxes\");\n      };\n\n      f.prototype.getSelectedPoints = function () {\n        return this.series.reduce(function (b, a) {\n          a.getPointsCollection().forEach(function (a) {\n            S(a.selectedStaging, a.selected) && b.push(a);\n          });\n          return b;\n        }, []);\n      };\n\n      f.prototype.getSelectedSeries = function () {\n        return this.series.filter(function (b) {\n          return b.selected;\n        });\n      };\n\n      f.prototype.setTitle = function (b, a, e) {\n        this.applyDescription(\"title\", b);\n        this.applyDescription(\"subtitle\", a);\n        this.applyDescription(\"caption\", void 0);\n        this.layOutTitles(e);\n      };\n\n      f.prototype.applyDescription = function (b, a) {\n        var e = this,\n            g = \"title\" === b ? {\n          color: \"#333333\",\n          fontSize: this.options.isStock ? \"16px\" : \"18px\"\n        } : {\n          color: \"#666666\"\n        };\n        g = this.options[b] = T(!this.styledMode && {\n          style: g\n        }, this.options[b], a);\n        var c = this[b];\n        c && a && (this[b] = c = c.destroy());\n        g && !c && (c = this.renderer.text(g.text, 0, 0, g.useHTML).attr({\n          align: g.align,\n          \"class\": \"highcharts-\" + b,\n          zIndex: g.zIndex || 4\n        }).add(), c.update = function (a) {\n          e[{\n            title: \"setTitle\",\n            subtitle: \"setSubtitle\",\n            caption: \"setCaption\"\n          }[b]](a);\n        }, this.styledMode || c.css(g.style), this[b] = c);\n      };\n\n      f.prototype.layOutTitles = function (b) {\n        var a = [0, 0, 0],\n            e = this.renderer,\n            g = this.spacingBox;\n        [\"title\", \"subtitle\", \"caption\"].forEach(function (b) {\n          var c = this[b],\n              f = this.options[b],\n              k = f.verticalAlign || \"top\";\n          b = \"title\" === b ? \"top\" === k ? -3 : 0 : \"top\" === k ? a[0] + 2 : 0;\n          var l;\n\n          if (c) {\n            this.styledMode || (l = f.style && f.style.fontSize);\n            l = e.fontMetrics(l, c).b;\n            c.css({\n              width: (f.width || g.width + (f.widthAdjust || 0)) + \"px\"\n            });\n            var d = Math.round(c.getBBox(f.useHTML).height);\n            c.align(W({\n              y: \"bottom\" === k ? l : b + l,\n              height: d\n            }, f), !1, \"spacingBox\");\n            f.floating || (\"top\" === k ? a[0] = Math.ceil(a[0] + d) : \"bottom\" === k && (a[2] = Math.ceil(a[2] + d)));\n          }\n        }, this);\n        a[0] && \"top\" === (this.options.title.verticalAlign || \"top\") && (a[0] += this.options.title.margin);\n        a[2] && \"bottom\" === this.options.caption.verticalAlign && (a[2] += this.options.caption.margin);\n        var c = !this.titleOffset || this.titleOffset.join(\",\") !== a.join(\",\");\n        this.titleOffset = a;\n        E(this, \"afterLayOutTitles\");\n        !this.isDirtyBox && c && (this.isDirtyBox = this.isDirtyLegend = c, this.hasRendered && S(b, !0) && this.isDirtyBox && this.redraw());\n      };\n\n      f.prototype.getChartSize = function () {\n        var b = this.options.chart,\n            a = b.width;\n        b = b.height;\n        var e = this.renderTo;\n        M(a) || (this.containerWidth = aa(e, \"width\"));\n        M(b) || (this.containerHeight = aa(e, \"height\"));\n        this.chartWidth = Math.max(0, a || this.containerWidth || 600);\n        this.chartHeight = Math.max(0, ia(b, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));\n      };\n\n      f.prototype.temporaryDisplay = function (b) {\n        var a = this.renderTo;\n        if (b) for (; a && a.style;) a.hcOrigStyle && (x(a, a.hcOrigStyle), delete a.hcOrigStyle), a.hcOrigDetached && (z.body.removeChild(a), a.hcOrigDetached = !1), a = a.parentNode;else for (; a && a.style;) {\n          z.body.contains(a) || a.parentNode || (a.hcOrigDetached = !0, z.body.appendChild(a));\n          if (\"none\" === aa(a, \"display\", !1) || a.hcOricDetached) a.hcOrigStyle = {\n            display: a.style.display,\n            height: a.style.height,\n            overflow: a.style.overflow\n          }, b = {\n            display: \"block\",\n            overflow: \"hidden\"\n          }, a !== this.renderTo && (b.height = 0), x(a, b), a.offsetWidth || a.style.setProperty(\"display\", \"block\", \"important\");\n          a = a.parentNode;\n          if (a === z.body) break;\n        }\n      };\n\n      f.prototype.setClassName = function (b) {\n        this.container.className = \"highcharts-container \" + (b || \"\");\n      };\n\n      f.prototype.getContainer = function () {\n        var b = this.options,\n            a = b.chart,\n            e = ja(),\n            g,\n            f = this.renderTo;\n        f || (this.renderTo = f = a.renderTo);\n        ca(f) && (this.renderTo = f = z.getElementById(f));\n        f || O(13, !0, this);\n        var l = da(B(f, \"data-highcharts-chart\"));\n        ba(l) && v[l] && v[l].hasRendered && v[l].destroy();\n        B(f, \"data-highcharts-chart\", this.index);\n        f.innerHTML = m.emptyHTML;\n        a.skipClone || f.offsetWidth || this.temporaryDisplay();\n        this.getChartSize();\n        l = this.chartWidth;\n        var d = this.chartHeight;\n        x(f, {\n          overflow: \"hidden\"\n        });\n        this.styledMode || (g = W({\n          position: \"relative\",\n          overflow: \"hidden\",\n          width: l + \"px\",\n          height: d + \"px\",\n          textAlign: \"left\",\n          lineHeight: \"normal\",\n          zIndex: 0,\n          \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\",\n          userSelect: \"none\",\n          \"touch-action\": \"manipulation\",\n          outline: \"none\"\n        }, a.style || {}));\n        this.container = e = r(\"div\", {\n          id: e\n        }, g, f);\n        this._cursor = e.style.cursor;\n        this.renderer = new (a.renderer || !k ? p.getRendererType(a.renderer) : c)(e, l, d, void 0, a.forExport, b.exporting && b.exporting.allowHTML, this.styledMode);\n        I(void 0, this);\n        this.setClassName(a.className);\n        if (this.styledMode) for (var n in b.defs) this.renderer.definition(b.defs[n]);else this.renderer.setStyle(a.style);\n        this.renderer.chartIndex = this.index;\n        E(this, \"afterGetContainer\");\n      };\n\n      f.prototype.getMargins = function (b) {\n        var a = this.spacing,\n            e = this.margin,\n            g = this.titleOffset;\n        this.resetMargins();\n        g[0] && !M(e[0]) && (this.plotTop = Math.max(this.plotTop, g[0] + a[0]));\n        g[2] && !M(e[2]) && (this.marginBottom = Math.max(this.marginBottom, g[2] + a[2]));\n        this.legend && this.legend.display && this.legend.adjustMargins(e, a);\n        E(this, \"getMargins\");\n        b || this.getAxisMargins();\n      };\n\n      f.prototype.getAxisMargins = function () {\n        var b = this,\n            a = b.axisOffset = [0, 0, 0, 0],\n            e = b.colorAxis,\n            g = b.margin,\n            c = function (b) {\n          b.forEach(function (b) {\n            b.visible && b.getOffset();\n          });\n        };\n\n        b.hasCartesianSeries ? c(b.axes) : e && e.length && c(e);\n        u.forEach(function (e, c) {\n          M(g[c]) || (b[e] += a[c]);\n        });\n        b.setChartSize();\n      };\n\n      f.prototype.reflow = function (b) {\n        var a = this,\n            e = a.options.chart,\n            g = a.renderTo,\n            c = M(e.width) && M(e.height),\n            f = e.width || aa(g, \"width\");\n        e = e.height || aa(g, \"height\");\n        g = b ? b.target : w;\n        delete a.pointer.chartPosition;\n\n        if (!c && !a.isPrinting && f && e && (g === w || g === z)) {\n          if (f !== a.containerWidth || e !== a.containerHeight) n.clearTimeout(a.reflowTimeout), a.reflowTimeout = Y(function () {\n            a.container && a.setSize(void 0, void 0, !1);\n          }, b ? 100 : 0);\n          a.containerWidth = f;\n          a.containerHeight = e;\n        }\n      };\n\n      f.prototype.setReflow = function (a) {\n        var e = this;\n        !1 === a || this.unbindReflow ? !1 === a && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = b(w, \"resize\", function (b) {\n          e.options && e.reflow(b);\n        }), b(this, \"destroy\", this.unbindReflow));\n      };\n\n      f.prototype.setSize = function (b, a, e) {\n        var g = this,\n            c = g.renderer;\n        g.isResizing += 1;\n        I(e, g);\n        e = c.globalAnimation;\n        g.oldChartHeight = g.chartHeight;\n        g.oldChartWidth = g.chartWidth;\n        \"undefined\" !== typeof b && (g.options.chart.width = b);\n        \"undefined\" !== typeof a && (g.options.chart.height = a);\n        g.getChartSize();\n        g.styledMode || (e ? D : x)(g.container, {\n          width: g.chartWidth + \"px\",\n          height: g.chartHeight + \"px\"\n        }, e);\n        g.setChartSize(!0);\n        c.setSize(g.chartWidth, g.chartHeight, e);\n        g.axes.forEach(function (b) {\n          b.isDirty = !0;\n          b.setScale();\n        });\n        g.isDirtyLegend = !0;\n        g.isDirtyBox = !0;\n        g.layOutTitles();\n        g.getMargins();\n        g.redraw(e);\n        g.oldChartHeight = null;\n        E(g, \"resize\");\n        Y(function () {\n          g && E(g, \"endResize\", null, function () {\n            --g.isResizing;\n          });\n        }, C(e).duration);\n      };\n\n      f.prototype.setChartSize = function (b) {\n        var a = this.inverted,\n            e = this.renderer,\n            g = this.chartWidth,\n            c = this.chartHeight,\n            f = this.options.chart,\n            k = this.spacing,\n            l = this.clipOffset,\n            d,\n            r,\n            x,\n            n;\n        this.plotLeft = d = Math.round(this.plotLeft);\n        this.plotTop = r = Math.round(this.plotTop);\n        this.plotWidth = x = Math.max(0, Math.round(g - d - this.marginRight));\n        this.plotHeight = n = Math.max(0, Math.round(c - r - this.marginBottom));\n        this.plotSizeX = a ? n : x;\n        this.plotSizeY = a ? x : n;\n        this.plotBorderWidth = f.plotBorderWidth || 0;\n        this.spacingBox = e.spacingBox = {\n          x: k[3],\n          y: k[0],\n          width: g - k[3] - k[1],\n          height: c - k[0] - k[2]\n        };\n        this.plotBox = e.plotBox = {\n          x: d,\n          y: r,\n          width: x,\n          height: n\n        };\n        a = 2 * Math.floor(this.plotBorderWidth / 2);\n        g = Math.ceil(Math.max(a, l[3]) / 2);\n        c = Math.ceil(Math.max(a, l[0]) / 2);\n        this.clipBox = {\n          x: g,\n          y: c,\n          width: Math.floor(this.plotSizeX - Math.max(a, l[1]) / 2 - g),\n          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(a, l[2]) / 2 - c))\n        };\n        b || (this.axes.forEach(function (b) {\n          b.setAxisSize();\n          b.setAxisTranslation();\n        }), e.alignElements());\n        E(this, \"afterSetChartSize\", {\n          skipAxes: b\n        });\n      };\n\n      f.prototype.resetMargins = function () {\n        E(this, \"resetMargins\");\n        var b = this,\n            a = b.options.chart;\n        [\"margin\", \"spacing\"].forEach(function (e) {\n          var g = a[e],\n              c = R(g) ? g : [g, g, g, g];\n          [\"Top\", \"Right\", \"Bottom\", \"Left\"].forEach(function (g, f) {\n            b[e][f] = S(a[e + g], c[f]);\n          });\n        });\n        u.forEach(function (a, e) {\n          b[a] = S(b.margin[e], b.spacing[e]);\n        });\n        b.axisOffset = [0, 0, 0, 0];\n        b.clipOffset = [0, 0, 0, 0];\n      };\n\n      f.prototype.drawChartBox = function () {\n        var b = this.options.chart,\n            a = this.renderer,\n            e = this.chartWidth,\n            g = this.chartHeight,\n            c = this.styledMode,\n            f = this.plotBGImage,\n            k = b.backgroundColor,\n            l = b.plotBackgroundColor,\n            d = b.plotBackgroundImage,\n            r = this.plotLeft,\n            x = this.plotTop,\n            n = this.plotWidth,\n            m = this.plotHeight,\n            p = this.plotBox,\n            h = this.clipRect,\n            B = this.clipBox,\n            u = this.chartBackground,\n            w = this.plotBackground,\n            J = this.plotBorder,\n            v,\n            q = \"animate\";\n        u || (this.chartBackground = u = a.rect().addClass(\"highcharts-background\").add(), q = \"attr\");\n        if (c) var Q = v = u.strokeWidth();else {\n          Q = b.borderWidth || 0;\n          v = Q + (b.shadow ? 8 : 0);\n          k = {\n            fill: k || \"none\"\n          };\n          if (Q || u[\"stroke-width\"]) k.stroke = b.borderColor, k[\"stroke-width\"] = Q;\n          u.attr(k).shadow(b.shadow);\n        }\n        u[q]({\n          x: v / 2,\n          y: v / 2,\n          width: e - v - Q % 2,\n          height: g - v - Q % 2,\n          r: b.borderRadius\n        });\n        q = \"animate\";\n        w || (q = \"attr\", this.plotBackground = w = a.rect().addClass(\"highcharts-plot-background\").add());\n        w[q](p);\n        c || (w.attr({\n          fill: l || \"none\"\n        }).shadow(b.plotShadow), d && (f ? (d !== f.attr(\"href\") && f.attr(\"href\", d), f.animate(p)) : this.plotBGImage = a.image(d, r, x, n, m).add()));\n        h ? h.animate({\n          width: B.width,\n          height: B.height\n        }) : this.clipRect = a.clipRect(B);\n        q = \"animate\";\n        J || (q = \"attr\", this.plotBorder = J = a.rect().addClass(\"highcharts-plot-border\").attr({\n          zIndex: 1\n        }).add());\n        c || J.attr({\n          stroke: b.plotBorderColor,\n          \"stroke-width\": b.plotBorderWidth || 0,\n          fill: \"none\"\n        });\n        J[q](J.crisp({\n          x: r,\n          y: x,\n          width: n,\n          height: m\n        }, -J.strokeWidth()));\n        this.isDirtyBox = !1;\n        E(this, \"afterDrawChartBox\");\n      };\n\n      f.prototype.propFromSeries = function () {\n        var b = this,\n            a = b.options.chart,\n            e = b.options.series,\n            c,\n            f,\n            k;\n        [\"inverted\", \"angular\", \"polar\"].forEach(function (l) {\n          f = g[a.type || a.defaultSeriesType];\n          k = a[l] || f && f.prototype[l];\n\n          for (c = e && e.length; !k && c--;) (f = g[e[c].type]) && f.prototype[l] && (k = !0);\n\n          b[l] = k;\n        });\n      };\n\n      f.prototype.linkSeries = function () {\n        var b = this,\n            a = b.series;\n        a.forEach(function (b) {\n          b.linkedSeries.length = 0;\n        });\n        a.forEach(function (a) {\n          var e = a.options.linkedTo;\n          ca(e) && (e = \":previous\" === e ? b.series[a.index - 1] : b.get(e)) && e.linkedParent !== a && (e.linkedSeries.push(a), a.linkedParent = e, e.enabledDataSorting && a.setDataSortingOptions(), a.visible = S(a.options.visible, e.options.visible, a.visible));\n        });\n        E(this, \"afterLinkSeries\");\n      };\n\n      f.prototype.renderSeries = function () {\n        this.series.forEach(function (b) {\n          b.translate();\n          b.render();\n        });\n      };\n\n      f.prototype.renderLabels = function () {\n        var b = this,\n            a = b.options.labels;\n        a.items && a.items.forEach(function (e) {\n          var g = W(a.style, e.style),\n              c = da(g.left) + b.plotLeft,\n              f = da(g.top) + b.plotTop + 12;\n          delete g.left;\n          delete g.top;\n          b.renderer.text(e.html, c, f).attr({\n            zIndex: 2\n          }).css(g).add();\n        });\n      };\n\n      f.prototype.render = function () {\n        var b = this.axes,\n            a = this.colorAxis,\n            e = this.renderer,\n            g = this.options,\n            c = function (b) {\n          b.forEach(function (b) {\n            b.visible && b.render();\n          });\n        },\n            f = 0;\n\n        this.setTitle();\n        this.legend = new G(this, g.legend);\n        this.getStacks && this.getStacks();\n        this.getMargins(!0);\n        this.setChartSize();\n        g = this.plotWidth;\n        b.some(function (b) {\n          if (b.horiz && b.visible && b.options.labels.enabled && b.series.length) return f = 21, !0;\n        });\n        var k = this.plotHeight = Math.max(this.plotHeight - f, 0);\n        b.forEach(function (b) {\n          b.setScale();\n        });\n        this.getAxisMargins();\n        var l = 1.1 < g / this.plotWidth,\n            d = 1.05 < k / this.plotHeight;\n        if (l || d) b.forEach(function (b) {\n          (b.horiz && l || !b.horiz && d) && b.setTickInterval(!0);\n        }), this.getMargins();\n        this.drawChartBox();\n        this.hasCartesianSeries ? c(b) : a && a.length && c(a);\n        this.seriesGroup || (this.seriesGroup = e.g(\"series-group\").attr({\n          zIndex: 3\n        }).add());\n        this.renderSeries();\n        this.renderLabels();\n        this.addCredits();\n        this.setResponsive && this.setResponsive();\n        this.hasRendered = !0;\n      };\n\n      f.prototype.addCredits = function (b) {\n        var a = this,\n            e = T(!0, this.options.credits, b);\n        e.enabled && !this.credits && (this.credits = this.renderer.text(e.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function () {\n          e.href && (w.location.href = e.href);\n        }).attr({\n          align: e.position.align,\n          zIndex: 8\n        }), a.styledMode || this.credits.css(e.style), this.credits.add().align(e.position), this.credits.update = function (b) {\n          a.credits = a.credits.destroy();\n          a.addCredits(b);\n        });\n      };\n\n      f.prototype.destroy = function () {\n        var b = this,\n            a = b.axes,\n            e = b.series,\n            g = b.container,\n            c = g && g.parentNode,\n            f;\n        E(b, \"destroy\");\n        b.renderer.forExport ? P(v, b) : v[b.index] = void 0;\n        t.chartCount--;\n        b.renderTo.removeAttribute(\"data-highcharts-chart\");\n        N(b);\n\n        for (f = a.length; f--;) a[f] = a[f].destroy();\n\n        this.scroller && this.scroller.destroy && this.scroller.destroy();\n\n        for (f = e.length; f--;) e[f] = e[f].destroy();\n\n        \"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer\".split(\" \").forEach(function (a) {\n          var e = b[a];\n          e && e.destroy && (b[a] = e.destroy());\n        });\n        g && (g.innerHTML = m.emptyHTML, N(g), c && X(g));\n        U(b, function (a, e) {\n          delete b[e];\n        });\n      };\n\n      f.prototype.firstRender = function () {\n        var b = this,\n            a = b.options;\n\n        if (!b.isReadyToRender || b.isReadyToRender()) {\n          b.getContainer();\n          b.resetMargins();\n          b.setChartSize();\n          b.propFromSeries();\n          b.getAxes();\n          (Q(a.series) ? a.series : []).forEach(function (a) {\n            b.initSeries(a);\n          });\n          b.linkSeries();\n          b.setSeriesData();\n          E(b, \"beforeRender\");\n          q && (H.isRequired() ? b.pointer = new H(b, a) : b.pointer = new q(b, a));\n          b.render();\n          b.pointer.getChartPosition();\n          if (!b.renderer.imgCount && !b.hasLoaded) b.onload();\n          b.temporaryDisplay(!0);\n        }\n      };\n\n      f.prototype.onload = function () {\n        this.callbacks.concat([this.callback]).forEach(function (b) {\n          b && \"undefined\" !== typeof this.index && b.apply(this, [this]);\n        }, this);\n        E(this, \"load\");\n        E(this, \"render\");\n        M(this.index) && this.setReflow(this.options.chart.reflow);\n        this.hasLoaded = !0;\n      };\n\n      f.prototype.addSeries = function (b, a, e) {\n        var g = this,\n            c;\n        b && (a = S(a, !0), E(g, \"addSeries\", {\n          options: b\n        }, function () {\n          c = g.initSeries(b);\n          g.isDirtyLegend = !0;\n          g.linkSeries();\n          c.enabledDataSorting && c.setData(b.data, !1);\n          E(g, \"afterAddSeries\", {\n            series: c\n          });\n          a && g.redraw(e);\n        }));\n        return c;\n      };\n\n      f.prototype.addAxis = function (b, a, e, g) {\n        return this.createAxis(a ? \"xAxis\" : \"yAxis\", {\n          axis: b,\n          redraw: e,\n          animation: g\n        });\n      };\n\n      f.prototype.addColorAxis = function (b, a, e) {\n        return this.createAxis(\"colorAxis\", {\n          axis: b,\n          redraw: a,\n          animation: e\n        });\n      };\n\n      f.prototype.createAxis = function (b, a) {\n        b = new h(this, T(a.axis, {\n          index: this[b].length,\n          isX: \"xAxis\" === b\n        }));\n        S(a.redraw, !0) && this.redraw(a.animation);\n        return b;\n      };\n\n      f.prototype.showLoading = function (a) {\n        var e = this,\n            g = e.options,\n            c = g.loading,\n            f = function () {\n          k && x(k, {\n            left: e.plotLeft + \"px\",\n            top: e.plotTop + \"px\",\n            width: e.plotWidth + \"px\",\n            height: e.plotHeight + \"px\"\n          });\n        },\n            k = e.loadingDiv,\n            l = e.loadingSpan;\n\n        k || (e.loadingDiv = k = r(\"div\", {\n          className: \"highcharts-loading highcharts-loading-hidden\"\n        }, null, e.container));\n        l || (e.loadingSpan = l = r(\"span\", {\n          className: \"highcharts-loading-inner\"\n        }, null, k), b(e, \"redraw\", f));\n        k.className = \"highcharts-loading\";\n        m.setElementHTML(l, S(a, g.lang.loading, \"\"));\n        e.styledMode || (x(k, W(c.style, {\n          zIndex: 10\n        })), x(l, c.labelStyle), e.loadingShown || (x(k, {\n          opacity: 0,\n          display: \"\"\n        }), D(k, {\n          opacity: c.style.opacity || .5\n        }, {\n          duration: c.showDuration || 0\n        })));\n        e.loadingShown = !0;\n        f();\n      };\n\n      f.prototype.hideLoading = function () {\n        var b = this.options,\n            a = this.loadingDiv;\n        a && (a.className = \"highcharts-loading highcharts-loading-hidden\", this.styledMode || D(a, {\n          opacity: 0\n        }, {\n          duration: b.loading.hideDuration || 100,\n          complete: function () {\n            x(a, {\n              display: \"none\"\n            });\n          }\n        }));\n        this.loadingShown = !1;\n      };\n\n      f.prototype.update = function (b, g, c, f) {\n        var k = this,\n            l = {\n          credits: \"addCredits\",\n          title: \"setTitle\",\n          subtitle: \"setSubtitle\",\n          caption: \"setCaption\"\n        },\n            d = b.isResponsiveOptions,\n            r = [],\n            x,\n            n;\n        E(k, \"update\", {\n          options: b\n        });\n        d || k.setResponsive(!1, !0);\n        b = J(b, k.options);\n        k.userOptions = T(k.userOptions, b);\n        var m = b.chart;\n\n        if (m) {\n          T(!0, k.options.chart, m);\n          \"className\" in m && k.setClassName(m.className);\n          \"reflow\" in m && k.setReflow(m.reflow);\n\n          if (\"inverted\" in m || \"polar\" in m || \"type\" in m) {\n            k.propFromSeries();\n            var p = !0;\n          }\n\n          \"alignTicks\" in m && (p = !0);\n          \"events\" in m && K(this, m);\n          U(m, function (b, a) {\n            -1 !== k.propsRequireUpdateSeries.indexOf(\"chart.\" + a) && (x = !0);\n            -1 !== k.propsRequireDirtyBox.indexOf(a) && (k.isDirtyBox = !0);\n            -1 !== k.propsRequireReflow.indexOf(a) && (d ? k.isDirtyBox = !0 : n = !0);\n          });\n          !k.styledMode && m.style && k.renderer.setStyle(k.options.chart.style || {});\n        }\n\n        !k.styledMode && b.colors && (this.options.colors = b.colors);\n        b.time && (this.time === e && (this.time = new a(b.time)), T(!0, k.options.time, b.time));\n        U(b, function (a, e) {\n          if (k[e] && \"function\" === typeof k[e].update) k[e].update(a, !1);else if (\"function\" === typeof k[l[e]]) k[l[e]](a);else \"colors\" !== e && -1 === k.collectionsWithUpdate.indexOf(e) && T(!0, k.options[e], b[e]);\n          \"chart\" !== e && -1 !== k.propsRequireUpdateSeries.indexOf(e) && (x = !0);\n        });\n        this.collectionsWithUpdate.forEach(function (a) {\n          if (b[a]) {\n            var e = [];\n            k[a].forEach(function (b, a) {\n              b.options.isInternal || e.push(S(b.options.index, a));\n            });\n            fa(b[a]).forEach(function (b, g) {\n              var f = M(b.id),\n                  l;\n              f && (l = k.get(b.id));\n              !l && k[a] && (l = k[a][e ? e[g] : g]) && f && M(l.options.id) && (l = void 0);\n              l && l.coll === a && (l.update(b, !1), c && (l.touched = !0));\n              !l && c && k.collectionsWithInit[a] && (k.collectionsWithInit[a][0].apply(k, [b].concat(k.collectionsWithInit[a][1] || []).concat([!1])).touched = !0);\n            });\n            c && k[a].forEach(function (b) {\n              b.touched || b.options.isInternal ? delete b.touched : r.push(b);\n            });\n          }\n        });\n        r.forEach(function (b) {\n          b.chart && b.remove && b.remove(!1);\n        });\n        p && k.axes.forEach(function (b) {\n          b.update({}, !1);\n        });\n        x && k.getSeriesOrderByLinks().forEach(function (b) {\n          b.chart && b.update({}, !1);\n        }, this);\n        p = m && m.width;\n        m = m && (ca(m.height) ? ia(m.height, p || k.chartWidth) : m.height);\n        n || ba(p) && p !== k.chartWidth || ba(m) && m !== k.chartHeight ? k.setSize(p, m, f) : S(g, !0) && k.redraw(f);\n        E(k, \"afterUpdate\", {\n          options: b,\n          redraw: g,\n          animation: f\n        });\n      };\n\n      f.prototype.setSubtitle = function (b, a) {\n        this.applyDescription(\"subtitle\", b);\n        this.layOutTitles(a);\n      };\n\n      f.prototype.setCaption = function (b, a) {\n        this.applyDescription(\"caption\", b);\n        this.layOutTitles(a);\n      };\n\n      f.prototype.showResetZoom = function () {\n        function b() {\n          a.zoomOut();\n        }\n\n        var a = this,\n            e = l.lang,\n            g = a.options.chart.resetZoomButton,\n            c = g.theme,\n            f = c.states,\n            k = \"chart\" === g.relativeTo || \"spacingBox\" === g.relativeTo ? null : \"scrollablePlotBox\";\n        E(this, \"beforeShowResetZoom\", null, function () {\n          a.resetZoomButton = a.renderer.button(e.resetZoom, null, null, b, c, f && f.hover).attr({\n            align: g.position.align,\n            title: e.resetZoomTitle\n          }).addClass(\"highcharts-reset-zoom\").add().align(g.position, !1, k);\n        });\n        E(this, \"afterShowResetZoom\");\n      };\n\n      f.prototype.zoomOut = function () {\n        E(this, \"selection\", {\n          resetSelection: !0\n        }, this.zoom);\n      };\n\n      f.prototype.zoom = function (b) {\n        var a = this,\n            e = a.pointer,\n            g = a.inverted ? e.mouseDownX : e.mouseDownY,\n            c = !1,\n            f;\n        !b || b.resetSelection ? (a.axes.forEach(function (b) {\n          f = b.zoom();\n        }), e.initiated = !1) : b.xAxis.concat(b.yAxis).forEach(function (b) {\n          var k = b.axis,\n              l = a.inverted ? k.left : k.top,\n              d = a.inverted ? l + k.width : l + k.height,\n              r = k.isXAxis,\n              x = !1;\n          if (!r && g >= l && g <= d || r || !M(g)) x = !0;\n          e[r ? \"zoomX\" : \"zoomY\"] && x && (f = k.zoom(b.min, b.max), k.displayBtn && (c = !0));\n        });\n        var k = a.resetZoomButton;\n        c && !k ? a.showResetZoom() : !c && R(k) && (a.resetZoomButton = k.destroy());\n        f && a.redraw(S(a.options.chart.animation, b && b.animation, 100 > a.pointCount));\n      };\n\n      f.prototype.pan = function (b, a) {\n        var e = this,\n            g = e.hoverPoints;\n        a = \"object\" === typeof a ? a : {\n          enabled: a,\n          type: \"x\"\n        };\n        var c = e.options.chart,\n            f = e.options.mapNavigation && e.options.mapNavigation.enabled;\n        c && c.panning && (c.panning = a);\n        var k = a.type,\n            l;\n        E(this, \"pan\", {\n          originalEvent: b\n        }, function () {\n          g && g.forEach(function (b) {\n            b.setState();\n          });\n          var a = e.xAxis;\n          \"xy\" === k ? a = a.concat(e.yAxis) : \"y\" === k && (a = e.yAxis);\n          var c = {};\n          a.forEach(function (a) {\n            if (a.options.panningEnabled && !a.options.isInternal) {\n              var g = a.horiz,\n                  d = b[g ? \"chartX\" : \"chartY\"];\n              g = g ? \"mouseDownX\" : \"mouseDownY\";\n              var r = e[g],\n                  x = a.minPointOffset || 0,\n                  n = a.reversed && !e.inverted || !a.reversed && e.inverted ? -1 : 1,\n                  m = a.getExtremes(),\n                  p = a.toValue(r - d, !0) + x * n,\n                  h = a.toValue(r + a.len - d, !0) - (x * n || a.isXAxis && a.pointRangePadding || 0),\n                  u = h < p;\n              n = a.hasVerticalPanning();\n              r = u ? h : p;\n              p = u ? p : h;\n              var B = a.panningState;\n              !n || a.isXAxis || B && !B.isDirty || a.series.forEach(function (b) {\n                var a = b.getProcessedData(!0);\n                a = b.getExtremes(a.yData, !0);\n                B || (B = {\n                  startMin: Number.MAX_VALUE,\n                  startMax: -Number.MAX_VALUE\n                });\n                ba(a.dataMin) && ba(a.dataMax) && (B.startMin = Math.min(S(b.options.threshold, Infinity), a.dataMin, B.startMin), B.startMax = Math.max(S(b.options.threshold, -Infinity), a.dataMax, B.startMax));\n              });\n              n = Math.min(S(B && B.startMin, m.dataMin), x ? m.min : a.toValue(a.toPixels(m.min) - a.minPixelPadding));\n              h = Math.max(S(B && B.startMax, m.dataMax), x ? m.max : a.toValue(a.toPixels(m.max) + a.minPixelPadding));\n              a.panningState = B;\n              a.isOrdinal || (x = n - r, 0 < x && (p += x, r = n), x = p - h, 0 < x && (p = h, r -= x), a.series.length && r !== m.min && p !== m.max && r >= n && p <= h && (a.setExtremes(r, p, !1, !1, {\n                trigger: \"pan\"\n              }), e.resetZoomButton || f || r === n || p === h || !k.match(\"y\") || (e.showResetZoom(), a.displayBtn = !1), l = !0), c[g] = d);\n            }\n          });\n          U(c, function (b, a) {\n            e[a] = b;\n          });\n          l && e.redraw(!1);\n          x(e.container, {\n            cursor: \"move\"\n          });\n        });\n      };\n\n      return f;\n    }();\n\n    W(d.prototype, {\n      callbacks: [],\n      collectionsWithInit: {\n        xAxis: [d.prototype.addAxis, [!0]],\n        yAxis: [d.prototype.addAxis, [!1]],\n        series: [d.prototype.addSeries]\n      },\n      collectionsWithUpdate: [\"xAxis\", \"yAxis\", \"series\"],\n      propsRequireDirtyBox: \"backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow\".split(\" \"),\n      propsRequireReflow: \"margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft\".split(\" \"),\n      propsRequireUpdateSeries: \"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip\".split(\" \")\n    });\n    \"\";\n    return d;\n  });\n  N(h, \"Core/Legend/LegendSymbol.js\", [h[\"Core/Utilities.js\"]], function (d) {\n    var h = d.merge,\n        A = d.pick,\n        F;\n\n    (function (d) {\n      d.drawLineMarker = function (d) {\n        var t = this.options,\n            y = d.symbolWidth,\n            q = d.symbolHeight,\n            p = q / 2,\n            f = this.chart.renderer,\n            c = this.legendGroup;\n        d = d.baseline - Math.round(.3 * d.fontMetrics.b);\n        var a = {},\n            n = t.marker;\n        this.chart.styledMode || (a = {\n          \"stroke-width\": t.lineWidth || 0\n        }, t.dashStyle && (a.dashstyle = t.dashStyle));\n        this.legendLine = f.path([[\"M\", 0, d], [\"L\", y, d]]).addClass(\"highcharts-graph\").attr(a).add(c);\n        n && !1 !== n.enabled && y && (t = Math.min(A(n.radius, p), p), 0 === this.symbol.indexOf(\"url\") && (n = h(n, {\n          width: q,\n          height: q\n        }), t = 0), this.legendSymbol = y = f.symbol(this.symbol, y / 2 - t, d - t, 2 * t, 2 * t, n).addClass(\"highcharts-point\").add(c), y.isMarker = !0);\n      };\n\n      d.drawRectangle = function (d, h) {\n        var t = d.symbolHeight,\n            q = d.options.squareSymbol;\n        h.legendSymbol = this.chart.renderer.rect(q ? (d.symbolWidth - t) / 2 : 0, d.baseline - t + 1, q ? t : d.symbolWidth, t, A(d.options.symbolRadius, t / 2)).addClass(\"highcharts-point\").attr({\n          zIndex: 3\n        }).add(h.legendGroup);\n      };\n    })(F || (F = {}));\n\n    return F;\n  });\n  N(h, \"Core/Series/SeriesDefaults.js\", [], function () {\n    return {\n      lineWidth: 2,\n      allowPointSelect: !1,\n      crisp: !0,\n      showCheckbox: !1,\n      animation: {\n        duration: 1E3\n      },\n      events: {},\n      marker: {\n        enabledThreshold: 2,\n        lineColor: \"#ffffff\",\n        lineWidth: 0,\n        radius: 4,\n        states: {\n          normal: {\n            animation: !0\n          },\n          hover: {\n            animation: {\n              duration: 50\n            },\n            enabled: !0,\n            radiusPlus: 2,\n            lineWidthPlus: 1\n          },\n          select: {\n            fillColor: \"#cccccc\",\n            lineColor: \"#000000\",\n            lineWidth: 2\n          }\n        }\n      },\n      point: {\n        events: {}\n      },\n      dataLabels: {\n        animation: {},\n        align: \"center\",\n        defer: !0,\n        formatter: function () {\n          var d = this.series.chart.numberFormatter;\n          return \"number\" !== typeof this.y ? \"\" : d(this.y, -1);\n        },\n        padding: 5,\n        style: {\n          fontSize: \"11px\",\n          fontWeight: \"bold\",\n          color: \"contrast\",\n          textOutline: \"1px contrast\"\n        },\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0\n      },\n      cropThreshold: 300,\n      opacity: 1,\n      pointRange: 0,\n      softThreshold: !0,\n      states: {\n        normal: {\n          animation: !0\n        },\n        hover: {\n          animation: {\n            duration: 50\n          },\n          lineWidthPlus: 1,\n          marker: {},\n          halo: {\n            size: 10,\n            opacity: .25\n          }\n        },\n        select: {\n          animation: {\n            duration: 0\n          }\n        },\n        inactive: {\n          animation: {\n            duration: 50\n          },\n          opacity: .2\n        }\n      },\n      stickyTracking: !0,\n      turboThreshold: 1E3,\n      findNearestPointBy: \"x\"\n    };\n  });\n  N(h, \"Core/Series/Series.js\", [h[\"Core/Animation/AnimationUtilities.js\"], h[\"Core/DefaultOptions.js\"], h[\"Core/Foundation.js\"], h[\"Core/Globals.js\"], h[\"Core/Legend/LegendSymbol.js\"], h[\"Core/Series/Point.js\"], h[\"Core/Series/SeriesDefaults.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Renderer/SVG/SVGElement.js\"], h[\"Core/Utilities.js\"]], function (d, h, A, F, t, G, H, y, q, p) {\n    var f = d.animObject,\n        c = d.setAnimation,\n        a = h.defaultOptions,\n        n = A.registerEventOptions,\n        m = F.hasTouch,\n        D = F.svg,\n        C = F.win,\n        I = y.seriesTypes,\n        L = p.addEvent,\n        K = p.arrayMax,\n        v = p.arrayMin,\n        z = p.clamp,\n        u = p.cleanRecursively,\n        k = p.correctFloat,\n        w = p.defined,\n        l = p.erase,\n        e = p.error,\n        g = p.extend,\n        b = p.find,\n        B = p.fireEvent,\n        J = p.getNestedProperty,\n        r = p.isArray,\n        x = p.isNumber,\n        M = p.isString,\n        E = p.merge,\n        P = p.objectEach,\n        O = p.pick,\n        W = p.removeEvent,\n        Z = p.splat,\n        ha = p.syncTimeout;\n\n    d = function () {\n      function d() {\n        this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;\n      }\n\n      d.prototype.init = function (b, a) {\n        B(this, \"init\", {\n          options: a\n        });\n        var e = this,\n            c = b.series;\n        this.eventsToUnbind = [];\n        e.chart = b;\n        e.options = e.setOptions(a);\n        a = e.options;\n        e.linkedSeries = [];\n        e.bindAxes();\n        g(e, {\n          name: a.name,\n          state: \"\",\n          visible: !1 !== a.visible,\n          selected: !0 === a.selected\n        });\n        n(this, a);\n        var f = a.events;\n        if (f && f.click || a.point && a.point.events && a.point.events.click || a.allowPointSelect) b.runTrackerClick = !0;\n        e.getColor();\n        e.getSymbol();\n        e.parallelArrays.forEach(function (b) {\n          e[b + \"Data\"] || (e[b + \"Data\"] = []);\n        });\n        e.isCartesian && (b.hasCartesianSeries = !0);\n        var k;\n        c.length && (k = c[c.length - 1]);\n        e._i = O(k && k._i, -1) + 1;\n        e.opacity = e.options.opacity;\n        b.orderSeries(this.insert(c));\n        a.dataSorting && a.dataSorting.enabled ? e.setDataSortingOptions() : e.points || e.data || e.setData(a.data, !1);\n        B(this, \"afterInit\");\n      };\n\n      d.prototype.is = function (b) {\n        return I[b] && this instanceof I[b];\n      };\n\n      d.prototype.insert = function (b) {\n        var a = this.options.index,\n            e;\n\n        if (x(a)) {\n          for (e = b.length; e--;) if (a >= O(b[e].options.index, b[e]._i)) {\n            b.splice(e + 1, 0, this);\n            break;\n          }\n\n          -1 === e && b.unshift(this);\n          e += 1;\n        } else b.push(this);\n\n        return O(e, b.length - 1);\n      };\n\n      d.prototype.bindAxes = function () {\n        var b = this,\n            a = b.options,\n            g = b.chart,\n            c;\n        B(this, \"bindAxes\", null, function () {\n          (b.axisTypes || []).forEach(function (f) {\n            var k = 0;\n            g[f].forEach(function (e) {\n              c = e.options;\n              if (a[f] === k && !c.isInternal || \"undefined\" !== typeof a[f] && a[f] === c.id || \"undefined\" === typeof a[f] && 0 === c.index) b.insert(e.series), b[f] = e, e.isDirty = !0;\n              c.isInternal || k++;\n            });\n            b[f] || b.optionalAxis === f || e(18, !0, g);\n          });\n        });\n        B(this, \"afterBindAxes\");\n      };\n\n      d.prototype.updateParallelArrays = function (b, a) {\n        var e = b.series,\n            g = arguments,\n            c = x(a) ? function (g) {\n          var c = \"y\" === g && e.toYData ? e.toYData(b) : b[g];\n          e[g + \"Data\"][a] = c;\n        } : function (b) {\n          Array.prototype[a].apply(e[b + \"Data\"], Array.prototype.slice.call(g, 2));\n        };\n        e.parallelArrays.forEach(c);\n      };\n\n      d.prototype.hasData = function () {\n        return this.visible && \"undefined\" !== typeof this.dataMax && \"undefined\" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;\n      };\n\n      d.prototype.autoIncrement = function (b) {\n        var a = this.options,\n            e = a.pointIntervalUnit,\n            g = a.relativeXValue,\n            c = this.chart.time,\n            f = this.xIncrement,\n            k;\n        f = O(f, a.pointStart, 0);\n        this.pointInterval = k = O(this.pointInterval, a.pointInterval, 1);\n        g && x(b) && (k *= b);\n        e && (a = new c.Date(f), \"day\" === e ? c.set(\"Date\", a, c.get(\"Date\", a) + k) : \"month\" === e ? c.set(\"Month\", a, c.get(\"Month\", a) + k) : \"year\" === e && c.set(\"FullYear\", a, c.get(\"FullYear\", a) + k), k = a.getTime() - f);\n        if (g && x(b)) return f + k;\n        this.xIncrement = f + k;\n        return f;\n      };\n\n      d.prototype.setDataSortingOptions = function () {\n        var b = this.options;\n        g(this, {\n          requireSorting: !1,\n          sorted: !1,\n          enabledDataSorting: !0,\n          allowDG: !1\n        });\n        w(b.pointRange) || (b.pointRange = 1);\n      };\n\n      d.prototype.setOptions = function (b) {\n        var e = this.chart,\n            g = e.options,\n            c = g.plotOptions,\n            f = e.userOptions || {};\n        b = E(b);\n        e = e.styledMode;\n        var k = {\n          plotOptions: c,\n          userOptions: b\n        };\n        B(this, \"setOptions\", k);\n        var d = k.plotOptions[this.type],\n            l = f.plotOptions || {};\n        this.userOptions = k.userOptions;\n        f = E(d, c.series, f.plotOptions && f.plotOptions[this.type], b);\n        this.tooltipOptions = E(a.tooltip, a.plotOptions.series && a.plotOptions.series.tooltip, a.plotOptions[this.type].tooltip, g.tooltip.userOptions, c.series && c.series.tooltip, c[this.type].tooltip, b.tooltip);\n        this.stickyTracking = O(b.stickyTracking, l[this.type] && l[this.type].stickyTracking, l.series && l.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : f.stickyTracking);\n        null === d.marker && delete f.marker;\n        this.zoneAxis = f.zoneAxis;\n        c = this.zones = (f.zones || []).slice();\n        !f.negativeColor && !f.negativeFillColor || f.zones || (g = {\n          value: f[this.zoneAxis + \"Threshold\"] || f.threshold || 0,\n          className: \"highcharts-negative\"\n        }, e || (g.color = f.negativeColor, g.fillColor = f.negativeFillColor), c.push(g));\n        c.length && w(c[c.length - 1].value) && c.push(e ? {} : {\n          color: this.color,\n          fillColor: this.fillColor\n        });\n        B(this, \"afterSetOptions\", {\n          options: f\n        });\n        return f;\n      };\n\n      d.prototype.getName = function () {\n        return O(this.options.name, \"Series \" + (this.index + 1));\n      };\n\n      d.prototype.getCyclic = function (b, a, e) {\n        var g = this.chart,\n            c = this.userOptions,\n            f = b + \"Index\",\n            k = b + \"Counter\",\n            d = e ? e.length : O(g.options.chart[b + \"Count\"], g[b + \"Count\"]);\n\n        if (!a) {\n          var l = O(c[f], c[\"_\" + f]);\n          w(l) || (g.series.length || (g[k] = 0), c[\"_\" + f] = l = g[k] % d, g[k] += 1);\n          e && (a = e[l]);\n        }\n\n        \"undefined\" !== typeof l && (this[f] = l);\n        this[b] = a;\n      };\n\n      d.prototype.getColor = function () {\n        this.chart.styledMode ? this.getCyclic(\"color\") : this.options.colorByPoint ? this.color = \"#cccccc\" : this.getCyclic(\"color\", this.options.color || a.plotOptions[this.type].color, this.chart.options.colors);\n      };\n\n      d.prototype.getPointsCollection = function () {\n        return (this.hasGroupedData ? this.points : this.data) || [];\n      };\n\n      d.prototype.getSymbol = function () {\n        this.getCyclic(\"symbol\", this.options.marker.symbol, this.chart.options.symbols);\n      };\n\n      d.prototype.findPointIndex = function (a, e) {\n        var g = a.id,\n            c = a.x,\n            f = this.points,\n            k = this.options.dataSorting,\n            d,\n            l;\n        if (g) k = this.chart.get(g), k instanceof G && (d = k);else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) if (d = function (b) {\n          return !b.touched && b.index === a.index;\n        }, k && k.matchByName ? d = function (b) {\n          return !b.touched && b.name === a.name;\n        } : this.options.relativeXValue && (d = function (b) {\n          return !b.touched && b.options.x === a.x;\n        }), d = b(f, d), !d) return;\n\n        if (d) {\n          var r = d && d.index;\n          \"undefined\" !== typeof r && (l = !0);\n        }\n\n        \"undefined\" === typeof r && x(c) && (r = this.xData.indexOf(c, e));\n        -1 !== r && \"undefined\" !== typeof r && this.cropped && (r = r >= this.cropStart ? r - this.cropStart : r);\n        !l && x(r) && f[r] && f[r].touched && (r = void 0);\n        return r;\n      };\n\n      d.prototype.updateData = function (b, a) {\n        var e = this.options,\n            g = e.dataSorting,\n            c = this.points,\n            f = [],\n            k = this.requireSorting,\n            d = b.length === c.length,\n            l,\n            r,\n            n,\n            m = !0;\n        this.xIncrement = null;\n        b.forEach(function (b, a) {\n          var r = w(b) && this.pointClass.prototype.optionsToObject.call({\n            series: this\n          }, b) || {},\n              m = r.x;\n\n          if (r.id || x(m)) {\n            if (r = this.findPointIndex(r, n), -1 === r || \"undefined\" === typeof r ? f.push(b) : c[r] && b !== e.data[r] ? (c[r].update(b, !1, null, !1), c[r].touched = !0, k && (n = r + 1)) : c[r] && (c[r].touched = !0), !d || a !== r || g && g.enabled || this.hasDerivedData) l = !0;\n          } else f.push(b);\n        }, this);\n        if (l) for (b = c.length; b--;) (r = c[b]) && !r.touched && r.remove && r.remove(!1, a);else !d || g && g.enabled ? m = !1 : (b.forEach(function (b, a) {\n          b !== c[a].y && c[a].update && c[a].update(b, !1, null, !1);\n        }), f.length = 0);\n        c.forEach(function (b) {\n          b && (b.touched = !1);\n        });\n        if (!m) return !1;\n        f.forEach(function (b) {\n          this.addPoint(b, !1, null, null, !1);\n        }, this);\n        null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = K(this.xData), this.autoIncrement());\n        return !0;\n      };\n\n      d.prototype.setData = function (b, a, g, c) {\n        var f = this,\n            k = f.points,\n            d = k && k.length || 0,\n            l = f.options,\n            n = f.chart,\n            m = l.dataSorting,\n            p = f.xAxis,\n            h = l.turboThreshold,\n            B = this.xData,\n            u = this.yData,\n            w = f.pointArrayMap;\n        w = w && w.length;\n        var J = l.keys,\n            v,\n            q = 0,\n            z = 1,\n            Q = null;\n        b = b || [];\n        var C = b.length;\n        a = O(a, !0);\n        m && m.enabled && (b = this.sortData(b));\n        !1 !== c && C && d && !f.cropped && !f.hasGroupedData && f.visible && !f.isSeriesBoosting && (v = this.updateData(b, g));\n\n        if (!v) {\n          f.xIncrement = null;\n          f.colorCounter = 0;\n          this.parallelArrays.forEach(function (b) {\n            f[b + \"Data\"].length = 0;\n          });\n          if (h && C > h) {\n            if (Q = f.getFirstValidPoint(b), x(Q)) for (g = 0; g < C; g++) B[g] = this.autoIncrement(), u[g] = b[g];else if (r(Q)) {\n              if (w) {\n                if (Q.length === w) for (g = 0; g < C; g++) B[g] = this.autoIncrement(), u[g] = b[g];else for (g = 0; g < C; g++) c = b[g], B[g] = c[0], u[g] = c.slice(1, w + 1);\n              } else if (J && (q = J.indexOf(\"x\"), z = J.indexOf(\"y\"), q = 0 <= q ? q : 0, z = 0 <= z ? z : 1), 1 === Q.length && (z = 0), q === z) for (g = 0; g < C; g++) B[g] = this.autoIncrement(), u[g] = b[g][z];else for (g = 0; g < C; g++) c = b[g], B[g] = c[q], u[g] = c[z];\n            } else e(12, !1, n);\n          } else for (g = 0; g < C; g++) \"undefined\" !== typeof b[g] && (c = {\n            series: f\n          }, f.pointClass.prototype.applyOptions.apply(c, [b[g]]), f.updateParallelArrays(c, g));\n          u && M(u[0]) && e(14, !0, n);\n          f.data = [];\n          f.options.data = f.userOptions.data = b;\n\n          for (g = d; g--;) k[g] && k[g].destroy && k[g].destroy();\n\n          p && (p.minRange = p.userMinRange);\n          f.isDirty = n.isDirtyBox = !0;\n          f.isDirtyData = !!k;\n          g = !1;\n        }\n\n        \"point\" === l.legendType && (this.processData(), this.generatePoints());\n        a && n.redraw(g);\n      };\n\n      d.prototype.sortData = function (b) {\n        var a = this,\n            e = a.options.dataSorting.sortKey || \"y\",\n            g = function (b, a) {\n          return w(a) && b.pointClass.prototype.optionsToObject.call({\n            series: b\n          }, a) || {};\n        };\n\n        b.forEach(function (e, c) {\n          b[c] = g(a, e);\n          b[c].index = c;\n        }, this);\n        b.concat().sort(function (b, a) {\n          b = J(e, b);\n          a = J(e, a);\n          return a < b ? -1 : a > b ? 1 : 0;\n        }).forEach(function (b, a) {\n          b.x = a;\n        }, this);\n        a.linkedSeries && a.linkedSeries.forEach(function (a) {\n          var e = a.options,\n              c = e.data;\n          e.dataSorting && e.dataSorting.enabled || !c || (c.forEach(function (e, f) {\n            c[f] = g(a, e);\n            b[f] && (c[f].x = b[f].x, c[f].index = f);\n          }), a.setData(c, !1));\n        });\n        return b;\n      };\n\n      d.prototype.getProcessedData = function (b) {\n        var a = this.xAxis,\n            g = this.options,\n            c = g.cropThreshold,\n            f = b || this.getExtremesFromAll || g.getExtremesFromAll,\n            k = this.isCartesian;\n        b = a && a.val2lin;\n        g = !(!a || !a.logarithmic);\n        var d = 0,\n            l = this.xData,\n            r = this.yData,\n            x = this.requireSorting;\n        var n = !1;\n        var m = l.length;\n\n        if (a) {\n          n = a.getExtremes();\n          var p = n.min;\n          var h = n.max;\n          n = a.categories && !a.names.length;\n        }\n\n        if (k && this.sorted && !f && (!c || m > c || this.forceCrop)) if (l[m - 1] < p || l[0] > h) l = [], r = [];else if (this.yData && (l[0] < p || l[m - 1] > h)) {\n          var B = this.cropData(this.xData, this.yData, p, h);\n          l = B.xData;\n          r = B.yData;\n          d = B.start;\n          B = !0;\n        }\n\n        for (c = l.length || 1; --c;) if (a = g ? b(l[c]) - b(l[c - 1]) : l[c] - l[c - 1], 0 < a && (\"undefined\" === typeof u || a < u)) var u = a;else 0 > a && x && !n && (e(15, !1, this.chart), x = !1);\n\n        return {\n          xData: l,\n          yData: r,\n          cropped: B,\n          cropStart: d,\n          closestPointRange: u\n        };\n      };\n\n      d.prototype.processData = function (b) {\n        var a = this.xAxis;\n        if (this.isCartesian && !this.isDirty && !a.isDirty && !this.yAxis.isDirty && !b) return !1;\n        b = this.getProcessedData();\n        this.cropped = b.cropped;\n        this.cropStart = b.cropStart;\n        this.processedXData = b.xData;\n        this.processedYData = b.yData;\n        this.closestPointRange = this.basePointRange = b.closestPointRange;\n        B(this, \"afterProcessData\");\n      };\n\n      d.prototype.cropData = function (b, a, e, g, c) {\n        var f = b.length,\n            k,\n            d = 0,\n            l = f;\n        c = O(c, this.cropShoulder);\n\n        for (k = 0; k < f; k++) if (b[k] >= e) {\n          d = Math.max(0, k - c);\n          break;\n        }\n\n        for (e = k; e < f; e++) if (b[e] > g) {\n          l = e + c;\n          break;\n        }\n\n        return {\n          xData: b.slice(d, l),\n          yData: a.slice(d, l),\n          start: d,\n          end: l\n        };\n      };\n\n      d.prototype.generatePoints = function () {\n        var b = this.options,\n            a = b.data,\n            e = this.processedXData,\n            c = this.processedYData,\n            f = this.pointClass,\n            k = e.length,\n            d = this.cropStart || 0,\n            l = this.hasGroupedData,\n            r = b.keys,\n            n = [];\n        b = b.dataGrouping && b.dataGrouping.groupAll ? d : 0;\n        var x,\n            m,\n            p = this.data;\n\n        if (!p && !l) {\n          var h = [];\n          h.length = a.length;\n          p = this.data = h;\n        }\n\n        r && l && (this.options.keys = !1);\n\n        for (m = 0; m < k; m++) {\n          h = d + m;\n\n          if (l) {\n            var u = new f().init(this, [e[m]].concat(Z(c[m])));\n            u.dataGroup = this.groupMap[b + m];\n            u.dataGroup.options && (u.options = u.dataGroup.options, g(u, u.dataGroup.options), delete u.dataLabels);\n          } else (u = p[h]) || \"undefined\" === typeof a[h] || (p[h] = u = new f().init(this, a[h], e[m]));\n\n          u && (u.index = l ? b + m : h, n[m] = u);\n        }\n\n        this.options.keys = r;\n        if (p && (k !== (x = p.length) || l)) for (m = 0; m < x; m++) m !== d || l || (m += k), p[m] && (p[m].destroyElements(), p[m].plotX = void 0);\n        this.data = p;\n        this.points = n;\n        B(this, \"afterGeneratePoints\");\n      };\n\n      d.prototype.getXExtremes = function (b) {\n        return {\n          min: v(b),\n          max: K(b)\n        };\n      };\n\n      d.prototype.getExtremes = function (b, a) {\n        var e = this.xAxis,\n            g = this.yAxis,\n            c = this.processedXData || this.xData,\n            f = [],\n            k = this.requireSorting ? this.cropShoulder : 0;\n        g = g ? g.positiveValuesOnly : !1;\n        var d,\n            l = 0,\n            n = 0,\n            m = 0;\n        b = b || this.stackedYData || this.processedYData || [];\n        var p = b.length;\n\n        if (e) {\n          var h = e.getExtremes();\n          l = h.min;\n          n = h.max;\n        }\n\n        for (d = 0; d < p; d++) {\n          var u = c[d];\n          h = b[d];\n          var w = (x(h) || r(h)) && (h.length || 0 < h || !g);\n          u = a || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !e || (c[d + k] || u) >= l && (c[d - k] || u) <= n;\n          if (w && u) if (w = h.length) for (; w--;) x(h[w]) && (f[m++] = h[w]);else f[m++] = h;\n        }\n\n        b = {\n          activeYData: f,\n          dataMin: v(f),\n          dataMax: K(f)\n        };\n        B(this, \"afterGetExtremes\", {\n          dataExtremes: b\n        });\n        return b;\n      };\n\n      d.prototype.applyExtremes = function () {\n        var b = this.getExtremes();\n        this.dataMin = b.dataMin;\n        this.dataMax = b.dataMax;\n        return b;\n      };\n\n      d.prototype.getFirstValidPoint = function (b) {\n        for (var a = b.length, e = 0, g = null; null === g && e < a;) g = b[e], e++;\n\n        return g;\n      };\n\n      d.prototype.translate = function () {\n        this.processedXData || this.processData();\n        this.generatePoints();\n        var b = this.options,\n            a = b.stacking,\n            e = this.xAxis,\n            g = e.categories,\n            c = this.enabledDataSorting,\n            f = this.yAxis,\n            d = this.points,\n            l = d.length,\n            n = this.pointPlacementToXValue(),\n            m = !!n,\n            p = b.threshold,\n            h = b.startFromThreshold ? p : 0,\n            u = this.zoneAxis || \"y\",\n            J,\n            v,\n            q = Number.MAX_VALUE;\n\n        for (J = 0; J < l; J++) {\n          var M = d[J],\n              C = M.x,\n              D = void 0,\n              I = void 0,\n              L = M.y,\n              K = M.low,\n              t = a && f.stacking && f.stacking.stacks[(this.negStacks && L < (h ? 0 : p) ? \"-\" : \"\") + this.stackKey];\n          if (f.positiveValuesOnly && !f.validatePositiveValue(L) || e.positiveValuesOnly && !e.validatePositiveValue(C)) M.isNull = !0;\n          M.plotX = v = k(z(e.translate(C, 0, 0, 0, 1, n, \"flags\" === this.type), -1E5, 1E5));\n\n          if (a && this.visible && t && t[C]) {\n            var y = this.getStackIndicator(y, C, this.index);\n            M.isNull || (D = t[C], I = D.points[y.key]);\n          }\n\n          r(I) && (K = I[0], L = I[1], K === h && y.key === t[C].base && (K = O(x(p) && p, f.min)), f.positiveValuesOnly && 0 >= K && (K = null), M.total = M.stackTotal = D.total, M.percentage = D.total && M.y / D.total * 100, M.stackY = L, this.irregularWidths || D.setOffset(this.pointXOffset || 0, this.barW || 0));\n          M.yBottom = w(K) ? z(f.translate(K, 0, 1, 0, 1), -1E5, 1E5) : null;\n          this.dataModify && (L = this.dataModify.modifyValue(L, J));\n          M.plotY = void 0;\n          x(L) && (D = f.translate(L, !1, !0, !1, !0), \"undefined\" !== typeof D && (M.plotY = z(D, -1E5, 1E5)));\n          M.isInside = this.isPointInside(M);\n          M.clientX = m ? k(e.translate(C, 0, 0, 0, 1, n)) : v;\n          M.negative = M[u] < (b[u + \"Threshold\"] || p || 0);\n          M.category = g && \"undefined\" !== typeof g[M.x] ? g[M.x] : M.x;\n\n          if (!M.isNull && !1 !== M.visible) {\n            \"undefined\" !== typeof P && (q = Math.min(q, Math.abs(v - P)));\n            var P = v;\n          }\n\n          M.zone = this.zones.length ? M.getZone() : void 0;\n          !M.graphic && this.group && c && (M.isNew = !0);\n        }\n\n        this.closestPointRangePx = q;\n        B(this, \"afterTranslate\");\n      };\n\n      d.prototype.getValidPoints = function (b, a, e) {\n        var g = this.chart;\n        return (b || this.points || []).filter(function (b) {\n          return a && !g.isInsidePlot(b.plotX, b.plotY, {\n            inverted: g.inverted\n          }) ? !1 : !1 !== b.visible && (e || !b.isNull);\n        });\n      };\n\n      d.prototype.getClipBox = function () {\n        var b = this.chart,\n            a = this.xAxis,\n            e = this.yAxis,\n            g = E(b.clipBox);\n        a && a.len !== b.plotSizeX && (g.width = a.len);\n        e && e.len !== b.plotSizeY && (g.height = e.len);\n        return g;\n      };\n\n      d.prototype.getSharedClipKey = function () {\n        return this.sharedClipKey = (this.options.xAxis || 0) + \",\" + (this.options.yAxis || 0);\n      };\n\n      d.prototype.setClip = function () {\n        var b = this.chart,\n            a = this.group,\n            e = this.markerGroup,\n            g = b.sharedClips;\n        b = b.renderer;\n        var c = this.getClipBox(),\n            f = this.getSharedClipKey(),\n            k = g[f];\n        k ? k.animate(c) : g[f] = k = b.clipRect(c);\n        a && a.clip(!1 === this.options.clip ? void 0 : k);\n        e && e.clip();\n      };\n\n      d.prototype.animate = function (b) {\n        var a = this.chart,\n            e = this.group,\n            g = this.markerGroup,\n            c = a.inverted,\n            k = f(this.options.animation),\n            d = [this.getSharedClipKey(), k.duration, k.easing, k.defer].join(),\n            l = a.sharedClips[d],\n            r = a.sharedClips[d + \"m\"];\n        if (b && e) k = this.getClipBox(), l ? l.attr(\"height\", k.height) : (k.width = 0, c && (k.x = a.plotHeight), l = a.renderer.clipRect(k), a.sharedClips[d] = l, r = a.renderer.clipRect({\n          x: c ? (a.plotSizeX || 0) + 99 : -99,\n          y: c ? -a.plotLeft : -a.plotTop,\n          width: 99,\n          height: c ? a.chartWidth : a.chartHeight\n        }), a.sharedClips[d + \"m\"] = r), e.clip(l), g && g.clip(r);else if (l && !l.hasClass(\"highcharts-animating\")) {\n          a = this.getClipBox();\n          var n = k.step;\n          g && g.element.childNodes.length && (k.step = function (b, a) {\n            n && n.apply(a, arguments);\n            r && r.element && r.attr(a.prop, \"width\" === a.prop ? b + 99 : b);\n          });\n          l.addClass(\"highcharts-animating\").animate(a, k);\n        }\n      };\n\n      d.prototype.afterAnimate = function () {\n        var b = this;\n        this.setClip();\n        P(this.chart.sharedClips, function (a, e, g) {\n          a && !b.chart.container.querySelector('[clip-path=\"url(#' + a.id + ')\"]') && (a.destroy(), delete g[e]);\n        });\n        this.finishedAnimating = !0;\n        B(this, \"afterAnimate\");\n      };\n\n      d.prototype.drawPoints = function () {\n        var b = this.points,\n            a = this.chart,\n            e = this.options.marker,\n            g = this[this.specialGroup] || this.markerGroup,\n            c = this.xAxis,\n            f = O(e.enabled, !c || c.isRadial ? !0 : null, this.closestPointRangePx >= e.enabledThreshold * e.radius),\n            k,\n            d;\n        if (!1 !== e.enabled || this._hasPointMarkers) for (k = 0; k < b.length; k++) {\n          var l = b[k];\n          var r = (d = l.graphic) ? \"animate\" : \"attr\";\n          var n = l.marker || {};\n          var x = !!l.marker;\n\n          if ((f && \"undefined\" === typeof n.enabled || n.enabled) && !l.isNull && !1 !== l.visible) {\n            var m = O(n.symbol, this.symbol, \"rect\");\n            var p = this.markerAttribs(l, l.selected && \"select\");\n            this.enabledDataSorting && (l.startXPos = c.reversed ? -(p.width || 0) : c.width);\n            var h = !1 !== l.isInside;\n            d ? d[h ? \"show\" : \"hide\"](h).animate(p) : h && (0 < (p.width || 0) || l.hasImage) && (l.graphic = d = a.renderer.symbol(m, p.x, p.y, p.width, p.height, x ? n : e).add(g), this.enabledDataSorting && a.hasRendered && (d.attr({\n              x: l.startXPos\n            }), r = \"animate\"));\n            d && \"animate\" === r && d[h ? \"show\" : \"hide\"](h).animate(p);\n            if (d && !a.styledMode) d[r](this.pointAttribs(l, l.selected && \"select\"));\n            d && d.addClass(l.getClassName(), !0);\n          } else d && (l.graphic = d.destroy());\n        }\n      };\n\n      d.prototype.markerAttribs = function (b, a) {\n        var e = this.options,\n            g = e.marker,\n            c = b.marker || {},\n            f = c.symbol || g.symbol,\n            k = O(c.radius, g.radius);\n        a && (g = g.states[a], a = c.states && c.states[a], k = O(a && a.radius, g && g.radius, k + (g && g.radiusPlus || 0)));\n        b.hasImage = f && 0 === f.indexOf(\"url\");\n        b.hasImage && (k = 0);\n        b = {\n          x: e.crisp ? Math.floor(b.plotX - k) : b.plotX - k,\n          y: b.plotY - k\n        };\n        k && (b.width = b.height = 2 * k);\n        return b;\n      };\n\n      d.prototype.pointAttribs = function (b, a) {\n        var e = this.options.marker,\n            g = b && b.options,\n            c = g && g.marker || {},\n            f = g && g.color,\n            k = b && b.color,\n            d = b && b.zone && b.zone.color,\n            l = this.color;\n        b = O(c.lineWidth, e.lineWidth);\n        g = 1;\n        l = f || d || k || l;\n        f = c.fillColor || e.fillColor || l;\n        k = c.lineColor || e.lineColor || l;\n        a = a || \"normal\";\n        e = e.states[a] || {};\n        a = c.states && c.states[a] || {};\n        b = O(a.lineWidth, e.lineWidth, b + O(a.lineWidthPlus, e.lineWidthPlus, 0));\n        f = a.fillColor || e.fillColor || f;\n        k = a.lineColor || e.lineColor || k;\n        g = O(a.opacity, e.opacity, g);\n        return {\n          stroke: k,\n          \"stroke-width\": b,\n          fill: f,\n          opacity: g\n        };\n      };\n\n      d.prototype.destroy = function (b) {\n        var a = this,\n            e = a.chart,\n            g = /AppleWebKit\\/533/.test(C.navigator.userAgent),\n            c = a.data || [],\n            f,\n            k,\n            d,\n            r;\n        B(a, \"destroy\");\n        this.removeEvents(b);\n        (a.axisTypes || []).forEach(function (b) {\n          (r = a[b]) && r.series && (l(r.series, a), r.isDirty = r.forceRedraw = !0);\n        });\n        a.legendItem && a.chart.legend.destroyItem(a);\n\n        for (k = c.length; k--;) (d = c[k]) && d.destroy && d.destroy();\n\n        a.clips && a.clips.forEach(function (b) {\n          return b.destroy();\n        });\n        p.clearTimeout(a.animationTimeout);\n        P(a, function (b, a) {\n          b instanceof q && !b.survive && (f = g && \"group\" === a ? \"hide\" : \"destroy\", b[f]());\n        });\n        e.hoverSeries === a && (e.hoverSeries = void 0);\n        l(e.series, a);\n        e.orderSeries();\n        P(a, function (e, g) {\n          b && \"hcEvents\" === g || delete a[g];\n        });\n      };\n\n      d.prototype.applyZones = function () {\n        var b = this,\n            a = this.chart,\n            e = a.renderer,\n            g = this.zones,\n            c = this.clips || [],\n            f = this.graph,\n            k = this.area,\n            d = Math.max(a.chartWidth, a.chartHeight),\n            l = this[(this.zoneAxis || \"y\") + \"Axis\"],\n            r = a.inverted,\n            n,\n            x,\n            m,\n            p,\n            h,\n            u,\n            B,\n            w,\n            J = !1;\n\n        if (g.length && (f || k) && l && \"undefined\" !== typeof l.min) {\n          var v = l.reversed;\n          var q = l.horiz;\n          f && !this.showLine && f.hide();\n          k && k.hide();\n          var M = l.getExtremes();\n          g.forEach(function (g, C) {\n            n = v ? q ? a.plotWidth : 0 : q ? 0 : l.toPixels(M.min) || 0;\n            n = z(O(x, n), 0, d);\n            x = z(Math.round(l.toPixels(O(g.value, M.max), !0) || 0), 0, d);\n            J && (n = x = l.toPixels(M.max));\n            p = Math.abs(n - x);\n            h = Math.min(n, x);\n            u = Math.max(n, x);\n            l.isXAxis ? (m = {\n              x: r ? u : h,\n              y: 0,\n              width: p,\n              height: d\n            }, q || (m.x = a.plotHeight - m.x)) : (m = {\n              x: 0,\n              y: r ? u : h,\n              width: d,\n              height: p\n            }, q && (m.y = a.plotWidth - m.y));\n            r && e.isVML && (m = l.isXAxis ? {\n              x: 0,\n              y: v ? h : u,\n              height: m.width,\n              width: a.chartWidth\n            } : {\n              x: m.y - a.plotLeft - a.spacingBox.x,\n              y: 0,\n              width: m.height,\n              height: a.chartHeight\n            });\n            c[C] ? c[C].animate(m) : c[C] = e.clipRect(m);\n            B = b[\"zone-area-\" + C];\n            w = b[\"zone-graph-\" + C];\n            f && w && w.clip(c[C]);\n            k && B && B.clip(c[C]);\n            J = g.value > M.max;\n            b.resetZones && 0 === x && (x = void 0);\n          });\n          this.clips = c;\n        } else b.visible && (f && f.show(!0), k && k.show(!0));\n      };\n\n      d.prototype.invertGroups = function (b) {\n        function a() {\n          [\"group\", \"markerGroup\"].forEach(function (a) {\n            e[a] && (g.renderer.isVML && e[a].attr({\n              width: e.yAxis.len,\n              height: e.xAxis.len\n            }), e[a].width = e.yAxis.len, e[a].height = e.xAxis.len, e[a].invert(e.isRadialSeries ? !1 : b));\n          });\n        }\n\n        var e = this,\n            g = e.chart;\n        e.xAxis && (e.eventsToUnbind.push(L(g, \"resize\", a)), a(), e.invertGroups = a);\n      };\n\n      d.prototype.plotGroup = function (b, a, e, g, c) {\n        var f = this[b],\n            k = !f;\n        e = {\n          visibility: e,\n          zIndex: g || .1\n        };\n        \"undefined\" === typeof this.opacity || this.chart.styledMode || \"inactive\" === this.state || (e.opacity = this.opacity);\n        k && (this[b] = f = this.chart.renderer.g().add(c));\n        f.addClass(\"highcharts-\" + a + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series \" + (w(this.colorIndex) ? \"highcharts-color-\" + this.colorIndex + \" \" : \"\") + (this.options.className || \"\") + (f.hasClass(\"highcharts-tracker\") ? \" highcharts-tracker\" : \"\"), !0);\n        f.attr(e)[k ? \"attr\" : \"animate\"](this.getPlotBox());\n        return f;\n      };\n\n      d.prototype.getPlotBox = function () {\n        var b = this.chart,\n            a = this.xAxis,\n            e = this.yAxis;\n        b.inverted && (a = e, e = this.xAxis);\n        return {\n          translateX: a ? a.left : b.plotLeft,\n          translateY: e ? e.top : b.plotTop,\n          scaleX: 1,\n          scaleY: 1\n        };\n      };\n\n      d.prototype.removeEvents = function (b) {\n        b || W(this);\n        this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (b) {\n          b();\n        }), this.eventsToUnbind.length = 0);\n      };\n\n      d.prototype.render = function () {\n        var b = this,\n            a = b.chart,\n            e = b.options,\n            g = f(e.animation),\n            c = b.visible ? \"inherit\" : \"hidden\",\n            k = e.zIndex,\n            d = b.hasRendered,\n            l = a.seriesGroup,\n            r = a.inverted;\n        a = !b.finishedAnimating && a.renderer.isSVG ? g.duration : 0;\n        B(this, \"render\");\n        var n = b.plotGroup(\"group\", \"series\", c, k, l);\n        b.markerGroup = b.plotGroup(\"markerGroup\", \"markers\", c, k, l);\n        !1 !== e.clip && b.setClip();\n        b.animate && a && b.animate(!0);\n        n.inverted = O(b.invertible, b.isCartesian) ? r : !1;\n        b.drawGraph && (b.drawGraph(), b.applyZones());\n        b.visible && b.drawPoints();\n        b.drawDataLabels && b.drawDataLabels();\n        b.redrawPoints && b.redrawPoints();\n        b.drawTracker && !1 !== b.options.enableMouseTracking && b.drawTracker();\n        b.invertGroups(r);\n        b.animate && a && b.animate();\n        d || (a && g.defer && (a += g.defer), b.animationTimeout = ha(function () {\n          b.afterAnimate();\n        }, a || 0));\n        b.isDirty = !1;\n        b.hasRendered = !0;\n        B(b, \"afterRender\");\n      };\n\n      d.prototype.redraw = function () {\n        var b = this.chart,\n            a = this.isDirty || this.isDirtyData,\n            e = this.group,\n            g = this.xAxis,\n            c = this.yAxis;\n        e && (b.inverted && e.attr({\n          width: b.plotWidth,\n          height: b.plotHeight\n        }), e.animate({\n          translateX: O(g && g.left, b.plotLeft),\n          translateY: O(c && c.top, b.plotTop)\n        }));\n        this.translate();\n        this.render();\n        a && delete this.kdTree;\n      };\n\n      d.prototype.searchPoint = function (b, a) {\n        var e = this.xAxis,\n            g = this.yAxis,\n            c = this.chart.inverted;\n        return this.searchKDTree({\n          clientX: c ? e.len - b.chartY + e.pos : b.chartX - e.pos,\n          plotY: c ? g.len - b.chartX + g.pos : b.chartY - g.pos\n        }, a, b);\n      };\n\n      d.prototype.buildKDTree = function (b) {\n        function a(b, g, c) {\n          var f = b && b.length;\n\n          if (f) {\n            var k = e.kdAxisArray[g % c];\n            b.sort(function (b, a) {\n              return b[k] - a[k];\n            });\n            f = Math.floor(f / 2);\n            return {\n              point: b[f],\n              left: a(b.slice(0, f), g + 1, c),\n              right: a(b.slice(f + 1), g + 1, c)\n            };\n          }\n        }\n\n        this.buildingKdTree = !0;\n        var e = this,\n            g = -1 < e.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        delete e.kdTree;\n        ha(function () {\n          e.kdTree = a(e.getValidPoints(null, !e.directTouch), g, g);\n          e.buildingKdTree = !1;\n        }, e.options.kdNow || b && \"touchstart\" === b.type ? 0 : 1);\n      };\n\n      d.prototype.searchKDTree = function (b, a, e) {\n        function g(b, a, e, l) {\n          var r = a.point,\n              n = c.kdAxisArray[e % l],\n              x = r,\n              m = w(b[f]) && w(r[f]) ? Math.pow(b[f] - r[f], 2) : null;\n          var p = w(b[k]) && w(r[k]) ? Math.pow(b[k] - r[k], 2) : null;\n          p = (m || 0) + (p || 0);\n          r.dist = w(p) ? Math.sqrt(p) : Number.MAX_VALUE;\n          r.distX = w(m) ? Math.sqrt(m) : Number.MAX_VALUE;\n          n = b[n] - r[n];\n          p = 0 > n ? \"left\" : \"right\";\n          m = 0 > n ? \"right\" : \"left\";\n          a[p] && (p = g(b, a[p], e + 1, l), x = p[d] < x[d] ? p : r);\n          a[m] && Math.sqrt(n * n) < x[d] && (b = g(b, a[m], e + 1, l), x = b[d] < x[d] ? b : x);\n          return x;\n        }\n\n        var c = this,\n            f = this.kdAxisArray[0],\n            k = this.kdAxisArray[1],\n            d = a ? \"distX\" : \"dist\";\n        a = -1 < c.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        this.kdTree || this.buildingKdTree || this.buildKDTree(e);\n        if (this.kdTree) return g(b, this.kdTree, a, a);\n      };\n\n      d.prototype.pointPlacementToXValue = function () {\n        var b = this.options,\n            a = b.pointRange,\n            e = this.xAxis;\n        b = b.pointPlacement;\n        \"between\" === b && (b = e.reversed ? -.5 : .5);\n        return x(b) ? b * (a || e.pointRange) : 0;\n      };\n\n      d.prototype.isPointInside = function (b) {\n        var a = this.chart,\n            e = this.xAxis,\n            g = this.yAxis;\n        return \"undefined\" !== typeof b.plotY && \"undefined\" !== typeof b.plotX && 0 <= b.plotY && b.plotY <= (g ? g.len : a.plotHeight) && 0 <= b.plotX && b.plotX <= (e ? e.len : a.plotWidth);\n      };\n\n      d.prototype.drawTracker = function () {\n        var b = this,\n            a = b.options,\n            e = a.trackByArea,\n            g = [].concat(e ? b.areaPath : b.graphPath),\n            c = b.chart,\n            f = c.pointer,\n            k = c.renderer,\n            d = c.options.tooltip.snap,\n            l = b.tracker,\n            r = function (a) {\n          if (c.hoverSeries !== b) b.onMouseOver();\n        },\n            n = \"rgba(192,192,192,\" + (D ? .0001 : .002) + \")\";\n\n        l ? l.attr({\n          d: g\n        }) : b.graph && (b.tracker = k.path(g).attr({\n          visibility: b.visible ? \"visible\" : \"hidden\",\n          zIndex: 2\n        }).addClass(e ? \"highcharts-tracker-area\" : \"highcharts-tracker-line\").add(b.group), c.styledMode || b.tracker.attr({\n          \"stroke-linecap\": \"round\",\n          \"stroke-linejoin\": \"round\",\n          stroke: n,\n          fill: e ? n : \"none\",\n          \"stroke-width\": b.graph.strokeWidth() + (e ? 0 : 2 * d)\n        }), [b.tracker, b.markerGroup, b.dataLabelsGroup].forEach(function (b) {\n          if (b && (b.addClass(\"highcharts-tracker\").on(\"mouseover\", r).on(\"mouseout\", function (b) {\n            f.onTrackerMouseOut(b);\n          }), a.cursor && !c.styledMode && b.css({\n            cursor: a.cursor\n          }), m)) b.on(\"touchstart\", r);\n        }));\n        B(this, \"afterDrawTracker\");\n      };\n\n      d.prototype.addPoint = function (b, a, e, g, c) {\n        var f = this.options,\n            k = this.data,\n            d = this.chart,\n            l = this.xAxis;\n        l = l && l.hasNames && l.names;\n        var r = f.data,\n            n = this.xData,\n            x;\n        a = O(a, !0);\n        var m = {\n          series: this\n        };\n        this.pointClass.prototype.applyOptions.apply(m, [b]);\n        var p = m.x;\n        var h = n.length;\n        if (this.requireSorting && p < n[h - 1]) for (x = !0; h && n[h - 1] > p;) h--;\n        this.updateParallelArrays(m, \"splice\", h, 0, 0);\n        this.updateParallelArrays(m, h);\n        l && m.name && (l[p] = m.name);\n        r.splice(h, 0, b);\n        x && (this.data.splice(h, 0, null), this.processData());\n        \"point\" === f.legendType && this.generatePoints();\n        e && (k[0] && k[0].remove ? k[0].remove(!1) : (k.shift(), this.updateParallelArrays(m, \"shift\"), r.shift()));\n        !1 !== c && B(this, \"addPoint\", {\n          point: m\n        });\n        this.isDirtyData = this.isDirty = !0;\n        a && d.redraw(g);\n      };\n\n      d.prototype.removePoint = function (b, a, e) {\n        var g = this,\n            f = g.data,\n            k = f[b],\n            d = g.points,\n            l = g.chart,\n            r = function () {\n          d && d.length === f.length && d.splice(b, 1);\n          f.splice(b, 1);\n          g.options.data.splice(b, 1);\n          g.updateParallelArrays(k || {\n            series: g\n          }, \"splice\", b, 1);\n          k && k.destroy();\n          g.isDirty = !0;\n          g.isDirtyData = !0;\n          a && l.redraw();\n        };\n\n        c(e, l);\n        a = O(a, !0);\n        k ? k.firePointEvent(\"remove\", null, r) : r();\n      };\n\n      d.prototype.remove = function (b, a, e, g) {\n        function c() {\n          f.destroy(g);\n          k.isDirtyLegend = k.isDirtyBox = !0;\n          k.linkSeries();\n          O(b, !0) && k.redraw(a);\n        }\n\n        var f = this,\n            k = f.chart;\n        !1 !== e ? B(f, \"remove\", null, c) : c();\n      };\n\n      d.prototype.update = function (b, a) {\n        b = u(b, this.userOptions);\n        B(this, \"update\", {\n          options: b\n        });\n        var c = this,\n            f = c.chart,\n            k = c.userOptions,\n            d = c.initialType || c.type,\n            l = f.options.plotOptions,\n            r = I[d].prototype,\n            n = c.finishedAnimating && {\n          animation: !1\n        },\n            x = {},\n            m,\n            p = [\"eventOptions\", \"navigatorSeries\", \"baseSeries\"],\n            h = b.type || k.type || f.options.chart.type,\n            w = !(this.hasDerivedData || h && h !== this.type || \"undefined\" !== typeof b.pointStart || \"undefined\" !== typeof b.pointInterval || \"undefined\" !== typeof b.relativeXValue || c.hasOptionChanged(\"dataGrouping\") || c.hasOptionChanged(\"pointStart\") || c.hasOptionChanged(\"pointInterval\") || c.hasOptionChanged(\"pointIntervalUnit\") || c.hasOptionChanged(\"keys\"));\n        h = h || d;\n        w && (p.push(\"data\", \"isDirtyData\", \"points\", \"processedXData\", \"processedYData\", \"xIncrement\", \"cropped\", \"_hasPointMarkers\", \"_hasPointLabels\", \"clips\", \"nodes\", \"layout\", \"mapMap\", \"mapData\", \"minY\", \"maxY\", \"minX\", \"maxX\"), !1 !== b.visible && p.push(\"area\", \"graph\"), c.parallelArrays.forEach(function (b) {\n          p.push(b + \"Data\");\n        }), b.data && (b.dataSorting && g(c.options.dataSorting, b.dataSorting), this.setData(b.data, !1)));\n        b = E(k, n, {\n          index: \"undefined\" === typeof k.index ? c.index : k.index,\n          pointStart: O(l && l.series && l.series.pointStart, k.pointStart, c.xData[0])\n        }, !w && {\n          data: c.options.data\n        }, b);\n        w && b.data && (b.data = c.options.data);\n        p = [\"group\", \"markerGroup\", \"dataLabelsGroup\", \"transformGroup\"].concat(p);\n        p.forEach(function (b) {\n          p[b] = c[b];\n          delete c[b];\n        });\n        l = !1;\n\n        if (I[h]) {\n          if (l = h !== c.type, c.remove(!1, !1, !1, !0), l) if (Object.setPrototypeOf) Object.setPrototypeOf(c, I[h].prototype);else {\n            n = Object.hasOwnProperty.call(c, \"hcEvents\") && c.hcEvents;\n\n            for (m in r) c[m] = void 0;\n\n            g(c, I[h].prototype);\n            n ? c.hcEvents = n : delete c.hcEvents;\n          }\n        } else e(17, !0, f, {\n          missingModuleFor: h\n        });\n\n        p.forEach(function (b) {\n          c[b] = p[b];\n        });\n        c.init(f, b);\n\n        if (w && this.points) {\n          var J = c.options;\n          !1 === J.visible ? (x.graphic = 1, x.dataLabel = 1) : c._hasPointLabels || (b = J.marker, r = J.dataLabels, !b || !1 !== b.enabled && (k.marker && k.marker.symbol) === b.symbol || (x.graphic = 1), r && !1 === r.enabled && (x.dataLabel = 1));\n          this.points.forEach(function (b) {\n            b && b.series && (b.resolveColor(), Object.keys(x).length && b.destroyElements(x), !1 === J.showInLegend && b.legendItem && f.legend.destroyItem(b));\n          }, this);\n        }\n\n        c.initialType = d;\n        f.linkSeries();\n        l && c.linkedSeries.length && (c.isDirtyData = !0);\n        B(this, \"afterUpdate\");\n        O(a, !0) && f.redraw(w ? void 0 : !1);\n      };\n\n      d.prototype.setName = function (b) {\n        this.name = this.options.name = this.userOptions.name = b;\n        this.chart.isDirtyLegend = !0;\n      };\n\n      d.prototype.hasOptionChanged = function (b) {\n        var a = this.options[b],\n            e = this.chart.options.plotOptions,\n            g = this.userOptions[b];\n        return g ? a !== g : a !== O(e && e[this.type] && e[this.type][b], e && e.series && e.series[b], a);\n      };\n\n      d.prototype.onMouseOver = function () {\n        var b = this.chart,\n            a = b.hoverSeries;\n        b.pointer.setHoverChartIndex();\n        if (a && a !== this) a.onMouseOut();\n        this.options.events.mouseOver && B(this, \"mouseOver\");\n        this.setState(\"hover\");\n        b.hoverSeries = this;\n      };\n\n      d.prototype.onMouseOut = function () {\n        var b = this.options,\n            a = this.chart,\n            e = a.tooltip,\n            g = a.hoverPoint;\n        a.hoverSeries = null;\n        if (g) g.onMouseOut();\n        this && b.events.mouseOut && B(this, \"mouseOut\");\n        !e || this.stickyTracking || e.shared && !this.noSharedTooltip || e.hide();\n        a.series.forEach(function (b) {\n          b.setState(\"\", !0);\n        });\n      };\n\n      d.prototype.setState = function (b, a) {\n        var e = this,\n            g = e.options,\n            c = e.graph,\n            f = g.inactiveOtherPoints,\n            k = g.states,\n            d = O(k[b || \"normal\"] && k[b || \"normal\"].animation, e.chart.options.chart.animation),\n            l = g.lineWidth,\n            r = 0,\n            n = g.opacity;\n        b = b || \"\";\n\n        if (e.state !== b && ([e.group, e.markerGroup, e.dataLabelsGroup].forEach(function (a) {\n          a && (e.state && a.removeClass(\"highcharts-series-\" + e.state), b && a.addClass(\"highcharts-series-\" + b));\n        }), e.state = b, !e.chart.styledMode)) {\n          if (k[b] && !1 === k[b].enabled) return;\n          b && (l = k[b].lineWidth || l + (k[b].lineWidthPlus || 0), n = O(k[b].opacity, n));\n          if (c && !c.dashstyle) for (g = {\n            \"stroke-width\": l\n          }, c.animate(g, d); e[\"zone-graph-\" + r];) e[\"zone-graph-\" + r].animate(g, d), r += 1;\n          f || [e.group, e.markerGroup, e.dataLabelsGroup, e.labelBySeries].forEach(function (b) {\n            b && b.animate({\n              opacity: n\n            }, d);\n          });\n        }\n\n        a && f && e.points && e.setAllPointsToState(b || void 0);\n      };\n\n      d.prototype.setAllPointsToState = function (b) {\n        this.points.forEach(function (a) {\n          a.setState && a.setState(b);\n        });\n      };\n\n      d.prototype.setVisible = function (b, a) {\n        var e = this,\n            g = e.chart,\n            c = e.legendItem,\n            f = g.options.chart.ignoreHiddenSeries,\n            k = e.visible,\n            d = (e.visible = b = e.options.visible = e.userOptions.visible = \"undefined\" === typeof b ? !k : b) ? \"show\" : \"hide\";\n        [\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"].forEach(function (b) {\n          if (e[b]) e[b][d]();\n        });\n        if (g.hoverSeries === e || (g.hoverPoint && g.hoverPoint.series) === e) e.onMouseOut();\n        c && g.legend.colorizeItem(e, b);\n        e.isDirty = !0;\n        e.options.stacking && g.series.forEach(function (b) {\n          b.options.stacking && b.visible && (b.isDirty = !0);\n        });\n        e.linkedSeries.forEach(function (a) {\n          a.setVisible(b, !1);\n        });\n        f && (g.isDirtyBox = !0);\n        B(e, d);\n        !1 !== a && g.redraw();\n      };\n\n      d.prototype.show = function () {\n        this.setVisible(!0);\n      };\n\n      d.prototype.hide = function () {\n        this.setVisible(!1);\n      };\n\n      d.prototype.select = function (b) {\n        this.selected = b = this.options.selected = \"undefined\" === typeof b ? !this.selected : b;\n        this.checkbox && (this.checkbox.checked = b);\n        B(this, b ? \"select\" : \"unselect\");\n      };\n\n      d.prototype.shouldShowTooltip = function (b, a, e) {\n        void 0 === e && (e = {});\n        e.series = this;\n        e.visiblePlotOnly = !0;\n        return this.chart.isInsidePlot(b, a, e);\n      };\n\n      d.defaultOptions = H;\n      return d;\n    }();\n\n    g(d.prototype, {\n      axisTypes: [\"xAxis\", \"yAxis\"],\n      coll: \"series\",\n      colorCounter: 0,\n      cropShoulder: 1,\n      directTouch: !1,\n      drawLegendSymbol: t.drawLineMarker,\n      isCartesian: !0,\n      kdAxisArray: [\"clientX\", \"plotY\"],\n      parallelArrays: [\"x\", \"y\"],\n      pointClass: G,\n      requireSorting: !0,\n      sorted: !0\n    });\n    y.series = d;\n    \"\";\n    \"\";\n    return d;\n  });\n  N(h, \"Extensions/ScrollablePlotArea.js\", [h[\"Core/Animation/AnimationUtilities.js\"], h[\"Core/Axis/Axis.js\"], h[\"Core/Chart/Chart.js\"], h[\"Core/Series/Series.js\"], h[\"Core/Renderer/RendererRegistry.js\"], h[\"Core/Utilities.js\"]], function (d, h, A, F, t, G) {\n    var E = d.stop,\n        y = G.addEvent,\n        q = G.createElement,\n        p = G.merge,\n        f = G.pick;\n    y(A, \"afterSetChartSize\", function (c) {\n      var a = this.options.chart.scrollablePlotArea,\n          f = a && a.minWidth;\n      a = a && a.minHeight;\n\n      if (!this.renderer.forExport) {\n        if (f) {\n          if (this.scrollablePixelsX = f = Math.max(0, f - this.chartWidth)) {\n            this.scrollablePlotBox = this.renderer.scrollablePlotBox = p(this.plotBox);\n            this.plotBox.width = this.plotWidth += f;\n            this.inverted ? this.clipBox.height += f : this.clipBox.width += f;\n            var d = {\n              1: {\n                name: \"right\",\n                value: f\n              }\n            };\n          }\n        } else a && (this.scrollablePixelsY = f = Math.max(0, a - this.chartHeight)) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = p(this.plotBox), this.plotBox.height = this.plotHeight += f, this.inverted ? this.clipBox.width += f : this.clipBox.height += f, d = {\n          2: {\n            name: \"bottom\",\n            value: f\n          }\n        });\n\n        d && !c.skipAxes && this.axes.forEach(function (a) {\n          d[a.side] ? a.getPlotLinePath = function () {\n            var c = d[a.side].name,\n                f = this[c];\n            this[c] = f - d[a.side].value;\n            var n = h.prototype.getPlotLinePath.apply(this, arguments);\n            this[c] = f;\n            return n;\n          } : (a.setAxisSize(), a.setAxisTranslation());\n        });\n      }\n    });\n    y(A, \"render\", function () {\n      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();\n    });\n\n    A.prototype.setUpScrolling = function () {\n      var c = this,\n          a = {\n        WebkitOverflowScrolling: \"touch\",\n        overflowX: \"hidden\",\n        overflowY: \"hidden\"\n      };\n      this.scrollablePixelsX && (a.overflowX = \"auto\");\n      this.scrollablePixelsY && (a.overflowY = \"auto\");\n      this.scrollingParent = q(\"div\", {\n        className: \"highcharts-scrolling-parent\"\n      }, {\n        position: \"relative\"\n      }, this.renderTo);\n      this.scrollingContainer = q(\"div\", {\n        className: \"highcharts-scrolling\"\n      }, a, this.scrollingParent);\n      y(this.scrollingContainer, \"scroll\", function () {\n        c.pointer && delete c.pointer.chartPosition;\n      });\n      this.innerContainer = q(\"div\", {\n        className: \"highcharts-inner-container\"\n      }, null, this.scrollingContainer);\n      this.innerContainer.appendChild(this.container);\n      this.setUpScrolling = null;\n    };\n\n    A.prototype.moveFixedElements = function () {\n      var c = this.container,\n          a = this.fixedRenderer,\n          f = \".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title\".split(\" \"),\n          d;\n      this.scrollablePixelsX && !this.inverted ? d = \".highcharts-yaxis\" : this.scrollablePixelsX && this.inverted ? d = \".highcharts-xaxis\" : this.scrollablePixelsY && !this.inverted ? d = \".highcharts-xaxis\" : this.scrollablePixelsY && this.inverted && (d = \".highcharts-yaxis\");\n      d && f.push(d + \":not(.highcharts-radial-axis)\", d + \"-labels:not(.highcharts-radial-axis-labels)\");\n      f.forEach(function (f) {\n        [].forEach.call(c.querySelectorAll(f), function (c) {\n          (c.namespaceURI === a.SVG_NS ? a.box : a.box.parentNode).appendChild(c);\n          c.style.pointerEvents = \"auto\";\n        });\n      });\n    };\n\n    A.prototype.applyFixed = function () {\n      var c = !this.fixedDiv,\n          a = this.options.chart,\n          d = a.scrollablePlotArea,\n          m = t.getRendererType();\n      c ? (this.fixedDiv = q(\"div\", {\n        className: \"highcharts-fixed\"\n      }, {\n        position: \"absolute\",\n        overflow: \"hidden\",\n        pointerEvents: \"none\",\n        zIndex: (a.style && a.style.zIndex || 0) + 2,\n        top: 0\n      }, null, !0), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = \"visible\", this.fixedRenderer = a = new m(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style), this.scrollableMask = a.path().attr({\n        fill: this.options.chart.backgroundColor || \"#fff\",\n        \"fill-opacity\": f(d.opacity, .85),\n        zIndex: -1\n      }).addClass(\"highcharts-scrollable-mask\").add(), y(this, \"afterShowResetZoom\", this.moveFixedElements), y(this, \"afterDrilldown\", this.moveFixedElements), y(this, \"afterLayOutTitles\", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);\n      if (this.scrollableDirty || c) this.scrollableDirty = !1, this.moveFixedElements();\n      a = this.chartWidth + (this.scrollablePixelsX || 0);\n      m = this.chartHeight + (this.scrollablePixelsY || 0);\n      E(this.container);\n      this.container.style.width = a + \"px\";\n      this.container.style.height = m + \"px\";\n      this.renderer.boxWrapper.attr({\n        width: a,\n        height: m,\n        viewBox: [0, 0, a, m].join(\" \")\n      });\n      this.chartBackground.attr({\n        width: a,\n        height: m\n      });\n      this.scrollingContainer.style.height = this.chartHeight + \"px\";\n      c && (d.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * d.scrollPositionX), d.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * d.scrollPositionY));\n      m = this.axisOffset;\n      c = this.plotTop - m[0] - 1;\n      d = this.plotLeft - m[3] - 1;\n      a = this.plotTop + this.plotHeight + m[2] + 1;\n      m = this.plotLeft + this.plotWidth + m[1] + 1;\n      var p = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),\n          h = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);\n      c = this.scrollablePixelsX ? [[\"M\", 0, c], [\"L\", this.plotLeft - 1, c], [\"L\", this.plotLeft - 1, a], [\"L\", 0, a], [\"Z\"], [\"M\", p, c], [\"L\", this.chartWidth, c], [\"L\", this.chartWidth, a], [\"L\", p, a], [\"Z\"]] : this.scrollablePixelsY ? [[\"M\", d, 0], [\"L\", d, this.plotTop - 1], [\"L\", m, this.plotTop - 1], [\"L\", m, 0], [\"Z\"], [\"M\", d, h], [\"L\", d, this.chartHeight], [\"L\", m, this.chartHeight], [\"L\", m, h], [\"Z\"]] : [[\"M\", 0, 0]];\n      \"adjustHeight\" !== this.redrawTrigger && this.scrollableMask.attr({\n        d: c\n      });\n    };\n\n    y(h, \"afterInit\", function () {\n      this.chart.scrollableDirty = !0;\n    });\n    y(F, \"show\", function () {\n      this.chart.scrollableDirty = !0;\n    });\n    \"\";\n  });\n  N(h, \"Core/Axis/StackingAxis.js\", [h[\"Core/Animation/AnimationUtilities.js\"], h[\"Core/Axis/Axis.js\"], h[\"Core/Utilities.js\"]], function (d, h, A) {\n    var E = d.getDeferredAnimation,\n        t = A.addEvent,\n        G = A.destroyObjectProperties,\n        H = A.fireEvent,\n        y = A.isNumber,\n        q = A.objectEach,\n        p;\n\n    (function (f) {\n      function c() {\n        var a = this.stacking;\n\n        if (a) {\n          var c = a.stacks;\n          q(c, function (a, f) {\n            G(a);\n            c[f] = null;\n          });\n          a && a.stackTotalGroup && a.stackTotalGroup.destroy();\n        }\n      }\n\n      function a() {\n        this.stacking || (this.stacking = new m(this));\n      }\n\n      var d = [];\n\n      f.compose = function (f) {\n        -1 === d.indexOf(f) && (d.push(f), t(f, \"init\", a), t(f, \"destroy\", c));\n        return f;\n      };\n\n      var m = function () {\n        function a(a) {\n          this.oldStacks = {};\n          this.stacks = {};\n          this.stacksTouched = 0;\n          this.axis = a;\n        }\n\n        a.prototype.buildStacks = function () {\n          var a = this.axis,\n              c = a.series,\n              f = a.options.reversedStacks,\n              d = c.length,\n              n;\n\n          if (!a.isXAxis) {\n            this.usePercentage = !1;\n\n            for (n = d; n--;) {\n              var m = c[f ? n : d - n - 1];\n              m.setStackedPoints();\n              m.setGroupedPoints();\n            }\n\n            for (n = 0; n < d; n++) c[n].modifyStacks();\n\n            H(a, \"afterBuildStacks\");\n          }\n        };\n\n        a.prototype.cleanStacks = function () {\n          if (!this.axis.isXAxis) {\n            if (this.oldStacks) var a = this.stacks = this.oldStacks;\n            q(a, function (a) {\n              q(a, function (a) {\n                a.cumulative = a.total;\n              });\n            });\n          }\n        };\n\n        a.prototype.resetStacks = function () {\n          var a = this,\n              c = a.stacks;\n          a.axis.isXAxis || q(c, function (c) {\n            q(c, function (f, d) {\n              y(f.touched) && f.touched < a.stacksTouched ? (f.destroy(), delete c[d]) : (f.total = null, f.cumulative = null);\n            });\n          });\n        };\n\n        a.prototype.renderStackTotals = function () {\n          var a = this.axis,\n              c = a.chart,\n              f = c.renderer,\n              d = this.stacks;\n          a = E(c, a.options.stackLabels && a.options.stackLabels.animation || !1);\n          var n = this.stackTotalGroup = this.stackTotalGroup || f.g(\"stack-labels\").attr({\n            visibility: \"visible\",\n            zIndex: 6,\n            opacity: 0\n          }).add();\n          n.translate(c.plotLeft, c.plotTop);\n          q(d, function (a) {\n            q(a, function (a) {\n              a.render(n);\n            });\n          });\n          n.animate({\n            opacity: 1\n          }, a);\n        };\n\n        return a;\n      }();\n\n      f.Additions = m;\n    })(p || (p = {}));\n\n    return p;\n  });\n  N(h, \"Extensions/Stacking.js\", [h[\"Core/Axis/Axis.js\"], h[\"Core/Chart/Chart.js\"], h[\"Core/FormatUtilities.js\"], h[\"Core/Globals.js\"], h[\"Core/Series/Series.js\"], h[\"Core/Axis/StackingAxis.js\"], h[\"Core/Utilities.js\"]], function (d, h, A, F, t, G, H) {\n    var y = A.format,\n        q = H.correctFloat,\n        p = H.defined,\n        f = H.destroyObjectProperties,\n        c = H.isArray,\n        a = H.isNumber,\n        n = H.objectEach,\n        m = H.pick,\n        D = function () {\n      function c(a, c, f, d, n) {\n        var m = a.chart.inverted;\n        this.axis = a;\n        this.isNegative = f;\n        this.options = c = c || {};\n        this.x = d;\n        this.total = null;\n        this.points = {};\n        this.hasValidPoints = !1;\n        this.stack = n;\n        this.rightCliff = this.leftCliff = 0;\n        this.alignOptions = {\n          align: c.align || (m ? f ? \"left\" : \"right\" : \"center\"),\n          verticalAlign: c.verticalAlign || (m ? \"middle\" : f ? \"bottom\" : \"top\"),\n          y: c.y,\n          x: c.x\n        };\n        this.textAlign = c.textAlign || (m ? f ? \"right\" : \"left\" : \"center\");\n      }\n\n      c.prototype.destroy = function () {\n        f(this, this.axis);\n      };\n\n      c.prototype.render = function (a) {\n        var c = this.axis.chart,\n            f = this.options,\n            d = f.format;\n        d = d ? y(d, this, c) : f.formatter.call(this);\n        this.label ? this.label.attr({\n          text: d,\n          visibility: \"hidden\"\n        }) : (this.label = c.renderer.label(d, null, null, f.shape, null, null, f.useHTML, !1, \"stack-labels\"), d = {\n          r: f.borderRadius || 0,\n          text: d,\n          rotation: f.rotation,\n          padding: m(f.padding, 5),\n          visibility: \"hidden\"\n        }, c.styledMode || (d.fill = f.backgroundColor, d.stroke = f.borderColor, d[\"stroke-width\"] = f.borderWidth, this.label.css(f.style)), this.label.attr(d), this.label.added || this.label.add(a));\n        this.label.labelrank = c.plotSizeY;\n      };\n\n      c.prototype.setOffset = function (c, f, d, n, h) {\n        var u = this.axis,\n            k = u.chart;\n        n = u.translate(u.stacking.usePercentage ? 100 : n ? n : this.total, 0, 0, 0, 1);\n        d = u.translate(d ? d : 0);\n        d = p(n) && Math.abs(n - d);\n        c = m(h, k.xAxis[0].translate(this.x)) + c;\n        u = p(n) && this.getStackBox(k, this, c, n, f, d, u);\n        f = this.label;\n        d = this.isNegative;\n        c = \"justify\" === m(this.options.overflow, \"justify\");\n        var w = this.textAlign;\n        f && u && (h = f.getBBox(), n = f.padding, w = \"left\" === w ? k.inverted ? -n : n : \"right\" === w ? h.width : k.inverted && \"center\" === w ? h.width / 2 : k.inverted ? d ? h.width + n : -n : h.width / 2, d = k.inverted ? h.height / 2 : d ? -n : h.height, this.alignOptions.x = m(this.options.x, 0), this.alignOptions.y = m(this.options.y, 0), u.x -= w, u.y -= d, f.align(this.alignOptions, null, u), k.isInsidePlot(f.alignAttr.x + w - this.alignOptions.x, f.alignAttr.y + d - this.alignOptions.y) ? f.show() : (f.alignAttr.y = -9999, c = !1), c && t.prototype.justifyDataLabel.call(this.axis, f, this.alignOptions, f.alignAttr, h, u), f.attr({\n          x: f.alignAttr.x,\n          y: f.alignAttr.y\n        }), m(!c && this.options.crop, !0) && ((k = a(f.x) && a(f.y) && k.isInsidePlot(f.x - n + f.width, f.y) && k.isInsidePlot(f.x + n, f.y)) || f.hide()));\n      };\n\n      c.prototype.getStackBox = function (a, c, f, d, n, m, k) {\n        var p = c.axis.reversed,\n            l = a.inverted,\n            e = k.height + k.pos - (l ? a.plotLeft : a.plotTop);\n        c = c.isNegative && !p || !c.isNegative && p;\n        return {\n          x: l ? c ? d - k.right : d - m + k.pos - a.plotLeft : f + a.xAxis[0].transB - a.plotLeft,\n          y: l ? k.height - f - n : c ? e - d - m : e - d,\n          width: l ? m : n,\n          height: l ? n : m\n        };\n      };\n\n      return c;\n    }();\n\n    h.prototype.getStacks = function () {\n      var a = this,\n          c = a.inverted;\n      a.yAxis.forEach(function (a) {\n        a.stacking && a.stacking.stacks && a.hasVisibleSeries && (a.stacking.oldStacks = a.stacking.stacks);\n      });\n      a.series.forEach(function (f) {\n        var d = f.xAxis && f.xAxis.options || {};\n        !f.options.stacking || !0 !== f.visible && !1 !== a.options.chart.ignoreHiddenSeries || (f.stackKey = [f.type, m(f.options.stack, \"\"), c ? d.top : d.left, c ? d.height : d.width].join());\n      });\n    };\n\n    G.compose(d);\n\n    t.prototype.setGroupedPoints = function () {\n      var a = this.yAxis.stacking;\n      this.options.centerInCategory && (this.is(\"column\") || this.is(\"columnrange\")) && !this.options.stacking && 1 < this.chart.series.length ? t.prototype.setStackedPoints.call(this, \"group\") : a && n(a.stacks, function (c, f) {\n        \"group\" === f.slice(-5) && (n(c, function (a) {\n          return a.destroy();\n        }), delete a.stacks[f]);\n      });\n    };\n\n    t.prototype.setStackedPoints = function (a) {\n      var f = a || this.options.stacking;\n\n      if (f && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {\n        var d = this.processedXData,\n            n = this.processedYData,\n            h = [],\n            z = n.length,\n            u = this.options,\n            k = u.threshold,\n            w = m(u.startFromThreshold && k, 0);\n        u = u.stack;\n        a = a ? this.type + \",\" + f : this.stackKey;\n        var l = \"-\" + a,\n            e = this.negStacks,\n            g = this.yAxis,\n            b = g.stacking.stacks,\n            B = g.stacking.oldStacks,\n            J,\n            r;\n        g.stacking.stacksTouched += 1;\n\n        for (r = 0; r < z; r++) {\n          var x = d[r];\n          var M = n[r];\n          var C = this.getStackIndicator(C, x, this.index);\n          var t = C.key;\n          var O = (J = e && M < (w ? 0 : k)) ? l : a;\n          b[O] || (b[O] = {});\n          b[O][x] || (B[O] && B[O][x] ? (b[O][x] = B[O][x], b[O][x].total = null) : b[O][x] = new D(g, g.options.stackLabels, J, x, u));\n          O = b[O][x];\n          null !== M ? (O.points[t] = O.points[this.index] = [m(O.cumulative, w)], p(O.cumulative) || (O.base = t), O.touched = g.stacking.stacksTouched, 0 < C.index && !1 === this.singleStacks && (O.points[t][0] = O.points[this.index + \",\" + x + \",0\"][0])) : O.points[t] = O.points[this.index] = null;\n          \"percent\" === f ? (J = J ? a : l, e && b[J] && b[J][x] ? (J = b[J][x], O.total = J.total = Math.max(J.total, O.total) + Math.abs(M) || 0) : O.total = q(O.total + (Math.abs(M) || 0))) : \"group\" === f ? (c(M) && (M = M[0]), null !== M && (O.total = (O.total || 0) + 1)) : O.total = q(O.total + (M || 0));\n          O.cumulative = \"group\" === f ? (O.total || 1) - 1 : m(O.cumulative, w) + (M || 0);\n          null !== M && (O.points[t].push(O.cumulative), h[r] = O.cumulative, O.hasValidPoints = !0);\n        }\n\n        \"percent\" === f && (g.stacking.usePercentage = !0);\n        \"group\" !== f && (this.stackedYData = h);\n        g.stacking.oldStacks = {};\n      }\n    };\n\n    t.prototype.modifyStacks = function () {\n      var a = this,\n          c = a.stackKey,\n          f = a.yAxis.stacking.stacks,\n          d = a.processedXData,\n          n,\n          m = a.options.stacking;\n      a[m + \"Stacker\"] && [c, \"-\" + c].forEach(function (c) {\n        for (var k = d.length, p, l; k--;) if (p = d[k], n = a.getStackIndicator(n, p, a.index, c), l = (p = f[c] && f[c][p]) && p.points[n.key]) a[m + \"Stacker\"](l, p, k);\n      });\n    };\n\n    t.prototype.percentStacker = function (a, c, f) {\n      c = c.total ? 100 / c.total : 0;\n      a[0] = q(a[0] * c);\n      a[1] = q(a[1] * c);\n      this.stackedYData[f] = a[1];\n    };\n\n    t.prototype.getStackIndicator = function (a, c, f, d) {\n      !p(a) || a.x !== c || d && a.key !== d ? a = {\n        x: c,\n        index: 0,\n        key: d\n      } : a.index++;\n      a.key = [f, c, a.index].join();\n      return a;\n    };\n\n    F.StackItem = D;\n    \"\";\n    return F.StackItem;\n  });\n  N(h, \"Series/Line/LineSeries.js\", [h[\"Core/Series/Series.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"]], function (d, h, A) {\n    var E = this && this.__extends || function () {\n      var d = function (h, q) {\n        d = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, f) {\n          d.__proto__ = f;\n        } || function (d, f) {\n          for (var c in f) f.hasOwnProperty(c) && (d[c] = f[c]);\n        };\n\n        return d(h, q);\n      };\n\n      return function (h, q) {\n        function p() {\n          this.constructor = h;\n        }\n\n        d(h, q);\n        h.prototype = null === q ? Object.create(q) : (p.prototype = q.prototype, new p());\n      };\n    }(),\n        t = A.defined,\n        G = A.merge;\n\n    A = function (h) {\n      function y() {\n        var d = null !== h && h.apply(this, arguments) || this;\n        d.data = void 0;\n        d.options = void 0;\n        d.points = void 0;\n        return d;\n      }\n\n      E(y, h);\n\n      y.prototype.drawGraph = function () {\n        var d = this,\n            p = this.options,\n            f = (this.gappedPath || this.getGraphPath).call(this),\n            c = this.chart.styledMode,\n            a = [[\"graph\", \"highcharts-graph\"]];\n        c || a[0].push(p.lineColor || this.color || \"#cccccc\", p.dashStyle);\n        a = d.getZonesGraphs(a);\n        a.forEach(function (a, m) {\n          var n = a[0],\n              h = d[n],\n              q = h ? \"animate\" : \"attr\";\n          h ? (h.endX = d.preventGraphAnimation ? null : f.xMap, h.animate({\n            d: f\n          })) : f.length && (d[n] = h = d.chart.renderer.path(f).addClass(a[1]).attr({\n            zIndex: 1\n          }).add(d.group));\n          h && !c && (n = {\n            stroke: a[2],\n            \"stroke-width\": p.lineWidth,\n            fill: d.fillGraph && d.color || \"none\"\n          }, a[3] ? n.dashstyle = a[3] : \"square\" !== p.linecap && (n[\"stroke-linecap\"] = n[\"stroke-linejoin\"] = \"round\"), h[q](n).shadow(2 > m && p.shadow));\n          h && (h.startX = f.xMap, h.isArea = f.isArea);\n        });\n      };\n\n      y.prototype.getGraphPath = function (d, p, f) {\n        var c = this,\n            a = c.options,\n            n = [],\n            m = [],\n            h,\n            q = a.step;\n        d = d || c.points;\n        var I = d.reversed;\n        I && d.reverse();\n        (q = {\n          right: 1,\n          center: 2\n        }[q] || q && 3) && I && (q = 4 - q);\n        d = this.getValidPoints(d, !1, !(a.connectNulls && !p && !f));\n        d.forEach(function (D, C) {\n          var v = D.plotX,\n              z = D.plotY,\n              u = d[C - 1];\n          (D.leftCliff || u && u.rightCliff) && !f && (h = !0);\n          D.isNull && !t(p) && 0 < C ? h = !a.connectNulls : D.isNull && !p ? h = !0 : (0 === C || h ? C = [[\"M\", D.plotX, D.plotY]] : c.getPointSpline ? C = [c.getPointSpline(d, D, C)] : q ? (C = 1 === q ? [[\"L\", u.plotX, z]] : 2 === q ? [[\"L\", (u.plotX + v) / 2, u.plotY], [\"L\", (u.plotX + v) / 2, z]] : [[\"L\", v, u.plotY]], C.push([\"L\", v, z])) : C = [[\"L\", v, z]], m.push(D.x), q && (m.push(D.x), 2 === q && m.push(D.x)), n.push.apply(n, C), h = !1);\n        });\n        n.xMap = m;\n        return c.graphPath = n;\n      };\n\n      y.prototype.getZonesGraphs = function (d) {\n        this.zones.forEach(function (h, f) {\n          f = [\"zone-graph-\" + f, \"highcharts-graph highcharts-zone-graph-\" + f + \" \" + (h.className || \"\")];\n          this.chart.styledMode || f.push(h.color || this.color, h.dashStyle || this.options.dashStyle);\n          d.push(f);\n        }, this);\n        return d;\n      };\n\n      y.defaultOptions = G(d.defaultOptions, {});\n      return y;\n    }(d);\n\n    h.registerSeriesType(\"line\", A);\n    \"\";\n    return A;\n  });\n  N(h, \"Series/Area/AreaSeries.js\", [h[\"Core/Color/Color.js\"], h[\"Core/Legend/LegendSymbol.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"]], function (d, h, A, F) {\n    var t = this && this.__extends || function () {\n      var f = function (c, a) {\n        f = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, c) {\n          a.__proto__ = c;\n        } || function (a, c) {\n          for (var f in c) c.hasOwnProperty(f) && (a[f] = c[f]);\n        };\n\n        return f(c, a);\n      };\n\n      return function (c, a) {\n        function d() {\n          this.constructor = c;\n        }\n\n        f(c, a);\n        c.prototype = null === a ? Object.create(a) : (d.prototype = a.prototype, new d());\n      };\n    }(),\n        E = d.parse,\n        H = A.seriesTypes.line;\n\n    d = F.extend;\n    var y = F.merge,\n        q = F.objectEach,\n        p = F.pick;\n\n    F = function (f) {\n      function c() {\n        var a = null !== f && f.apply(this, arguments) || this;\n        a.data = void 0;\n        a.options = void 0;\n        a.points = void 0;\n        return a;\n      }\n\n      t(c, f);\n\n      c.prototype.drawGraph = function () {\n        this.areaPath = [];\n        f.prototype.drawGraph.apply(this);\n        var a = this,\n            c = this.areaPath,\n            d = this.options,\n            h = [[\"area\", \"highcharts-area\", this.color, d.fillColor]];\n        this.zones.forEach(function (c, f) {\n          h.push([\"zone-area-\" + f, \"highcharts-area highcharts-zone-area-\" + f + \" \" + c.className, c.color || a.color, c.fillColor || d.fillColor]);\n        });\n        h.forEach(function (f) {\n          var n = f[0],\n              m = a[n],\n              h = m ? \"animate\" : \"attr\",\n              q = {};\n          m ? (m.endX = a.preventGraphAnimation ? null : c.xMap, m.animate({\n            d: c\n          })) : (q.zIndex = 0, m = a[n] = a.chart.renderer.path(c).addClass(f[1]).add(a.group), m.isArea = !0);\n          a.chart.styledMode || (q.fill = p(f[3], E(f[2]).setOpacity(p(d.fillOpacity, .75)).get()));\n          m[h](q);\n          m.startX = c.xMap;\n          m.shiftUnit = d.step ? 2 : 1;\n        });\n      };\n\n      c.prototype.getGraphPath = function (a) {\n        var c = H.prototype.getGraphPath,\n            f = this.options,\n            d = f.stacking,\n            h = this.yAxis,\n            q,\n            t = [],\n            y = [],\n            v = this.index,\n            z = h.stacking.stacks[this.stackKey],\n            u = f.threshold,\n            k = Math.round(h.getThreshold(f.threshold));\n        f = p(f.connectNulls, \"percent\" === d);\n\n        var w = function (b, g, c) {\n          var f = a[b];\n          b = d && z[f.x].points[v];\n          var l = f[c + \"Null\"] || 0;\n          c = f[c + \"Cliff\"] || 0;\n          f = !0;\n\n          if (c || l) {\n            var n = (l ? b[0] : b[1]) + c;\n            var m = b[0] + c;\n            f = !!l;\n          } else !d && a[g] && a[g].isNull && (n = m = u);\n\n          \"undefined\" !== typeof n && (y.push({\n            plotX: e,\n            plotY: null === n ? k : h.getThreshold(n),\n            isNull: f,\n            isCliff: !0\n          }), t.push({\n            plotX: e,\n            plotY: null === m ? k : h.getThreshold(m),\n            doCurve: !1\n          }));\n        };\n\n        a = a || this.points;\n        d && (a = this.getStackPoints(a));\n\n        for (q = 0; q < a.length; q++) {\n          d || (a[q].leftCliff = a[q].rightCliff = a[q].leftNull = a[q].rightNull = void 0);\n          var l = a[q].isNull;\n          var e = p(a[q].rectPlotX, a[q].plotX);\n          var g = d ? p(a[q].yBottom, k) : k;\n          if (!l || f) f || w(q, q - 1, \"left\"), l && !d && f || (y.push(a[q]), t.push({\n            x: q,\n            plotX: e,\n            plotY: g\n          })), f || w(q, q + 1, \"right\");\n        }\n\n        q = c.call(this, y, !0, !0);\n        t.reversed = !0;\n        l = c.call(this, t, !0, !0);\n        (g = l[0]) && \"M\" === g[0] && (l[0] = [\"L\", g[1], g[2]]);\n        l = q.concat(l);\n        l.length && l.push([\"Z\"]);\n        c = c.call(this, y, !1, f);\n        l.xMap = q.xMap;\n        this.areaPath = l;\n        return c;\n      };\n\n      c.prototype.getStackPoints = function (a) {\n        var c = this,\n            f = [],\n            d = [],\n            h = this.xAxis,\n            t = this.yAxis,\n            y = t.stacking.stacks[this.stackKey],\n            E = {},\n            v = t.series,\n            z = v.length,\n            u = t.options.reversedStacks ? 1 : -1,\n            k = v.indexOf(c);\n        a = a || this.points;\n\n        if (this.options.stacking) {\n          for (var w = 0; w < a.length; w++) a[w].leftNull = a[w].rightNull = void 0, E[a[w].x] = a[w];\n\n          q(y, function (a, g) {\n            null !== a.total && d.push(g);\n          });\n          d.sort(function (a, g) {\n            return a - g;\n          });\n          var l = v.map(function (a) {\n            return a.visible;\n          });\n          d.forEach(function (a, g) {\n            var b = 0,\n                e,\n                n;\n            if (E[a] && !E[a].isNull) f.push(E[a]), [-1, 1].forEach(function (b) {\n              var f = 1 === b ? \"rightNull\" : \"leftNull\",\n                  r = 0,\n                  x = y[d[g + b]];\n              if (x) for (var h = k; 0 <= h && h < z;) {\n                var m = v[h].index;\n                e = x.points[m];\n                e || (m === c.index ? E[a][f] = !0 : l[h] && (n = y[a].points[m]) && (r -= n[1] - n[0]));\n                h += u;\n              }\n              E[a][1 === b ? \"rightCliff\" : \"leftCliff\"] = r;\n            });else {\n              for (var r = k; 0 <= r && r < z;) {\n                if (e = y[a].points[v[r].index]) {\n                  b = e[1];\n                  break;\n                }\n\n                r += u;\n              }\n\n              b = p(b, 0);\n              b = t.translate(b, 0, 1, 0, 1);\n              f.push({\n                isNull: !0,\n                plotX: h.translate(a, 0, 0, 0, 1),\n                x: a,\n                plotY: b,\n                yBottom: b\n              });\n            }\n          });\n        }\n\n        return f;\n      };\n\n      c.defaultOptions = y(H.defaultOptions, {\n        threshold: 0\n      });\n      return c;\n    }(H);\n\n    d(F.prototype, {\n      singleStacks: !1,\n      drawLegendSymbol: h.drawRectangle\n    });\n    A.registerSeriesType(\"area\", F);\n    \"\";\n    return F;\n  });\n  N(h, \"Series/Spline/SplineSeries.js\", [h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"]], function (d, h) {\n    var E = this && this.__extends || function () {\n      var d = function (h, q) {\n        d = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, f) {\n          d.__proto__ = f;\n        } || function (d, f) {\n          for (var c in f) f.hasOwnProperty(c) && (d[c] = f[c]);\n        };\n\n        return d(h, q);\n      };\n\n      return function (h, q) {\n        function p() {\n          this.constructor = h;\n        }\n\n        d(h, q);\n        h.prototype = null === q ? Object.create(q) : (p.prototype = q.prototype, new p());\n      };\n    }(),\n        F = d.seriesTypes.line,\n        t = h.merge,\n        G = h.pick;\n\n    h = function (d) {\n      function h() {\n        var h = null !== d && d.apply(this, arguments) || this;\n        h.data = void 0;\n        h.options = void 0;\n        h.points = void 0;\n        return h;\n      }\n\n      E(h, d);\n\n      h.prototype.getPointSpline = function (d, h, f) {\n        var c = h.plotX || 0,\n            a = h.plotY || 0,\n            n = d[f - 1];\n        f = d[f + 1];\n\n        if (n && !n.isNull && !1 !== n.doCurve && !h.isCliff && f && !f.isNull && !1 !== f.doCurve && !h.isCliff) {\n          d = n.plotY || 0;\n          var m = f.plotX || 0;\n          f = f.plotY || 0;\n          var p = 0;\n          var q = (1.5 * c + (n.plotX || 0)) / 2.5;\n          var t = (1.5 * a + d) / 2.5;\n          m = (1.5 * c + m) / 2.5;\n          var y = (1.5 * a + f) / 2.5;\n          m !== q && (p = (y - t) * (m - c) / (m - q) + a - y);\n          t += p;\n          y += p;\n          t > d && t > a ? (t = Math.max(d, a), y = 2 * a - t) : t < d && t < a && (t = Math.min(d, a), y = 2 * a - t);\n          y > f && y > a ? (y = Math.max(f, a), t = 2 * a - y) : y < f && y < a && (y = Math.min(f, a), t = 2 * a - y);\n          h.rightContX = m;\n          h.rightContY = y;\n        }\n\n        h = [\"C\", G(n.rightContX, n.plotX, 0), G(n.rightContY, n.plotY, 0), G(q, c, 0), G(t, a, 0), c, a];\n        n.rightContX = n.rightContY = void 0;\n        return h;\n      };\n\n      h.defaultOptions = t(F.defaultOptions);\n      return h;\n    }(F);\n\n    d.registerSeriesType(\"spline\", h);\n    \"\";\n    return h;\n  });\n  N(h, \"Series/AreaSpline/AreaSplineSeries.js\", [h[\"Series/Area/AreaSeries.js\"], h[\"Series/Spline/SplineSeries.js\"], h[\"Core/Legend/LegendSymbol.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"]], function (d, h, A, F, t) {\n    var E = this && this.__extends || function () {\n      var d = function (f, c) {\n        d = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, c) {\n          a.__proto__ = c;\n        } || function (a, c) {\n          for (var f in c) c.hasOwnProperty(f) && (a[f] = c[f]);\n        };\n\n        return d(f, c);\n      };\n\n      return function (f, c) {\n        function a() {\n          this.constructor = f;\n        }\n\n        d(f, c);\n        f.prototype = null === c ? Object.create(c) : (a.prototype = c.prototype, new a());\n      };\n    }(),\n        H = d.prototype,\n        y = t.extend,\n        q = t.merge;\n\n    t = function (p) {\n      function f() {\n        var c = null !== p && p.apply(this, arguments) || this;\n        c.data = void 0;\n        c.points = void 0;\n        c.options = void 0;\n        return c;\n      }\n\n      E(f, p);\n      f.defaultOptions = q(h.defaultOptions, d.defaultOptions);\n      return f;\n    }(h);\n\n    y(t.prototype, {\n      getGraphPath: H.getGraphPath,\n      getStackPoints: H.getStackPoints,\n      drawGraph: H.drawGraph,\n      drawLegendSymbol: A.drawRectangle\n    });\n    F.registerSeriesType(\"areaspline\", t);\n    \"\";\n    return t;\n  });\n  N(h, \"Series/Column/ColumnSeries.js\", [h[\"Core/Animation/AnimationUtilities.js\"], h[\"Core/Color/Color.js\"], h[\"Core/Globals.js\"], h[\"Core/Legend/LegendSymbol.js\"], h[\"Core/Series/Series.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"]], function (d, h, A, F, t, G, H) {\n    var y = this && this.__extends || function () {\n      var a = function (c, f) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, c) {\n          a.__proto__ = c;\n        } || function (a, c) {\n          for (var e in c) c.hasOwnProperty(e) && (a[e] = c[e]);\n        };\n\n        return a(c, f);\n      };\n\n      return function (c, f) {\n        function d() {\n          this.constructor = c;\n        }\n\n        a(c, f);\n        c.prototype = null === f ? Object.create(f) : (d.prototype = f.prototype, new d());\n      };\n    }(),\n        q = d.animObject,\n        p = h.parse,\n        f = A.hasTouch;\n\n    d = A.noop;\n    var c = H.clamp,\n        a = H.css,\n        n = H.defined,\n        m = H.extend,\n        D = H.fireEvent,\n        C = H.isArray,\n        I = H.isNumber,\n        E = H.merge,\n        K = H.pick,\n        v = H.objectEach;\n\n    H = function (d) {\n      function h() {\n        var a = null !== d && d.apply(this, arguments) || this;\n        a.borderWidth = void 0;\n        a.data = void 0;\n        a.group = void 0;\n        a.options = void 0;\n        a.points = void 0;\n        return a;\n      }\n\n      y(h, d);\n\n      h.prototype.animate = function (a) {\n        var f = this,\n            d = this.yAxis,\n            e = f.options,\n            g = this.chart.inverted,\n            b = {},\n            k = g ? \"translateX\" : \"translateY\";\n        if (a) b.scaleY = .001, a = c(d.toPixels(e.threshold), d.pos, d.pos + d.len), g ? b.translateX = a - d.len : b.translateY = a, f.clipBox && f.setClip(), f.group.attr(b);else {\n          var h = Number(f.group.attr(k));\n          f.group.animate({\n            scaleY: 1\n          }, m(q(f.options.animation), {\n            step: function (a, e) {\n              f.group && (b[k] = h + e.pos * (d.pos - h), f.group.attr(b));\n            }\n          }));\n        }\n      };\n\n      h.prototype.init = function (a, c) {\n        d.prototype.init.apply(this, arguments);\n        var f = this;\n        a = f.chart;\n        a.hasRendered && a.series.forEach(function (a) {\n          a.type === f.type && (a.isDirty = !0);\n        });\n      };\n\n      h.prototype.getColumnMetrics = function () {\n        var a = this,\n            c = a.options,\n            f = a.xAxis,\n            e = a.yAxis,\n            g = f.options.reversedStacks;\n        g = f.reversed && !g || !f.reversed && g;\n        var b = {},\n            d,\n            h = 0;\n        !1 === c.grouping ? h = 1 : a.chart.series.forEach(function (c) {\n          var g = c.yAxis,\n              f = c.options;\n\n          if (c.type === a.type && (c.visible || !a.chart.options.chart.ignoreHiddenSeries) && e.len === g.len && e.pos === g.pos) {\n            if (f.stacking && \"group\" !== f.stacking) {\n              d = c.stackKey;\n              \"undefined\" === typeof b[d] && (b[d] = h++);\n              var k = b[d];\n            } else !1 !== f.grouping && (k = h++);\n\n            c.columnIndex = k;\n          }\n        });\n        var r = Math.min(Math.abs(f.transA) * (f.ordinal && f.ordinal.slope || c.pointRange || f.closestPointRange || f.tickInterval || 1), f.len),\n            n = r * c.groupPadding,\n            m = (r - 2 * n) / (h || 1);\n        c = Math.min(c.maxPointWidth || f.len, K(c.pointWidth, m * (1 - 2 * c.pointPadding)));\n        a.columnMetrics = {\n          width: c,\n          offset: (m - c) / 2 + (n + ((a.columnIndex || 0) + (g ? 1 : 0)) * m - r / 2) * (g ? -1 : 1),\n          paddedWidth: m,\n          columnCount: h\n        };\n        return a.columnMetrics;\n      };\n\n      h.prototype.crispCol = function (a, c, f, e) {\n        var g = this.chart,\n            b = this.borderWidth,\n            d = -(b % 2 ? .5 : 0);\n        b = b % 2 ? .5 : 1;\n        g.inverted && g.renderer.isVML && (b += 1);\n        this.options.crisp && (f = Math.round(a + f) + d, a = Math.round(a) + d, f -= a);\n        e = Math.round(c + e) + b;\n        d = .5 >= Math.abs(c) && .5 < e;\n        c = Math.round(c) + b;\n        e -= c;\n        d && e && (--c, e += 1);\n        return {\n          x: a,\n          y: c,\n          width: f,\n          height: e\n        };\n      };\n\n      h.prototype.adjustForMissingColumns = function (a, c, f, e) {\n        var g = this,\n            b = this.options.stacking;\n\n        if (!f.isNull && 1 < e.columnCount) {\n          var d = 0,\n              k = 0;\n          v(this.yAxis.stacking && this.yAxis.stacking.stacks, function (a) {\n            if (\"number\" === typeof f.x && (a = a[f.x.toString()])) {\n              var e = a.points[g.index],\n                  c = a.total;\n              b ? (e && (d = k), a.hasValidPoints && k++) : C(e) && (d = e[1], k = c || 0);\n            }\n          });\n          a = (f.plotX || 0) + ((k - 1) * e.paddedWidth + c) / 2 - c - d * e.paddedWidth;\n        }\n\n        return a;\n      };\n\n      h.prototype.translate = function () {\n        var a = this,\n            f = a.chart,\n            d = a.options,\n            e = a.dense = 2 > a.closestPointRange * a.xAxis.transA;\n        e = a.borderWidth = K(d.borderWidth, e ? 0 : 1);\n        var g = a.xAxis,\n            b = a.yAxis,\n            h = d.threshold,\n            m = a.translatedThreshold = b.getThreshold(h),\n            r = K(d.minPointLength, 5),\n            x = a.getColumnMetrics(),\n            p = x.width,\n            u = a.pointXOffset = x.offset,\n            q = a.dataMin,\n            v = a.dataMax,\n            z = a.barW = Math.max(p, 1 + 2 * e);\n        f.inverted && (m -= .5);\n        d.pointPadding && (z = Math.ceil(z));\n        t.prototype.translate.apply(a);\n        a.points.forEach(function (e) {\n          var k = K(e.yBottom, m),\n              l = 999 + Math.abs(k),\n              B = e.plotX || 0;\n          l = c(e.plotY, -l, b.len + l);\n          var w = Math.min(l, k),\n              J = Math.max(l, k) - w,\n              M = p,\n              D = B + u,\n              t = z;\n          r && Math.abs(J) < r && (J = r, B = !b.reversed && !e.negative || b.reversed && e.negative, I(h) && I(v) && e.y === h && v <= h && (b.min || 0) < h && (q !== v || (b.max || 0) <= h) && (B = !B), w = Math.abs(w - m) > r ? k - r : m - (B ? r : 0));\n          n(e.options.pointWidth) && (M = t = Math.ceil(e.options.pointWidth), D -= Math.round((M - p) / 2));\n          d.centerInCategory && (D = a.adjustForMissingColumns(D, M, e, x));\n          e.barX = D;\n          e.pointWidth = M;\n          e.tooltipPos = f.inverted ? [c(b.len + b.pos - f.plotLeft - l, b.pos - f.plotLeft, b.len + b.pos - f.plotLeft), g.len + g.pos - f.plotTop - D - t / 2, J] : [g.left - f.plotLeft + D + t / 2, c(l + b.pos - f.plotTop, b.pos - f.plotTop, b.len + b.pos - f.plotTop), J];\n          e.shapeType = a.pointClass.prototype.shapeType || \"rect\";\n          e.shapeArgs = a.crispCol.apply(a, e.isNull ? [D, m, t, 0] : [D, w, t, J]);\n        });\n      };\n\n      h.prototype.drawGraph = function () {\n        this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n      };\n\n      h.prototype.pointAttribs = function (a, c) {\n        var f = this.options,\n            e = this.pointAttrToOptions || {},\n            g = e.stroke || \"borderColor\",\n            b = e[\"stroke-width\"] || \"borderWidth\",\n            d = a && a.color || this.color,\n            k = a && a[g] || f[g] || d;\n        e = a && a.options.dashStyle || f.dashStyle;\n        var r = a && a[b] || f[b] || this[b] || 0,\n            h = K(a && a.opacity, f.opacity, 1);\n\n        if (a && this.zones.length) {\n          var n = a.getZone();\n          d = a.options.color || n && (n.color || a.nonZonedColor) || this.color;\n          n && (k = n.borderColor || k, e = n.dashStyle || e, r = n.borderWidth || r);\n        }\n\n        c && a && (a = E(f.states[c], a.options.states && a.options.states[c] || {}), c = a.brightness, d = a.color || \"undefined\" !== typeof c && p(d).brighten(a.brightness).get() || d, k = a[g] || k, r = a[b] || r, e = a.dashStyle || e, h = K(a.opacity, h));\n        g = {\n          fill: d,\n          stroke: k,\n          \"stroke-width\": r,\n          opacity: h\n        };\n        e && (g.dashstyle = e);\n        return g;\n      };\n\n      h.prototype.drawPoints = function () {\n        var a = this,\n            c = this.chart,\n            f = a.options,\n            e = c.renderer,\n            g = f.animationLimit || 250,\n            b;\n        a.points.forEach(function (d) {\n          var k = d.graphic,\n              l = !!k,\n              h = k && c.pointCount < g ? \"animate\" : \"attr\";\n\n          if (I(d.plotY) && null !== d.y) {\n            b = d.shapeArgs;\n            k && d.hasNewShapeType() && (k = k.destroy());\n            a.enabledDataSorting && (d.startXPos = a.xAxis.reversed ? -(b ? b.width || 0 : 0) : a.xAxis.width);\n            k || (d.graphic = k = e[d.shapeType](b).add(d.group || a.group)) && a.enabledDataSorting && c.hasRendered && c.pointCount < g && (k.attr({\n              x: d.startXPos\n            }), l = !0, h = \"animate\");\n            if (k && l) k[h](E(b));\n            if (f.borderRadius) k[h]({\n              r: f.borderRadius\n            });\n            c.styledMode || k[h](a.pointAttribs(d, d.selected && \"select\")).shadow(!1 !== d.allowShadow && f.shadow, null, f.stacking && !f.borderRadius);\n            k && (k.addClass(d.getClassName(), !0), k.attr({\n              visibility: d.visible ? \"inherit\" : \"hidden\"\n            }));\n          } else k && (d.graphic = k.destroy());\n        });\n      };\n\n      h.prototype.drawTracker = function () {\n        var c = this,\n            d = c.chart,\n            l = d.pointer,\n            e = function (b) {\n          var a = l.getPointFromEvent(b);\n          \"undefined\" !== typeof a && (l.isDirectTouch = !0, a.onMouseOver(b));\n        },\n            g;\n\n        c.points.forEach(function (b) {\n          g = C(b.dataLabels) ? b.dataLabels : b.dataLabel ? [b.dataLabel] : [];\n          b.graphic && (b.graphic.element.point = b);\n          g.forEach(function (a) {\n            a.div ? a.div.point = b : a.element.point = b;\n          });\n        });\n        c._hasTracking || (c.trackerGroups.forEach(function (b) {\n          if (c[b]) {\n            c[b].addClass(\"highcharts-tracker\").on(\"mouseover\", e).on(\"mouseout\", function (b) {\n              l.onTrackerMouseOut(b);\n            });\n            if (f) c[b].on(\"touchstart\", e);\n            !d.styledMode && c.options.cursor && c[b].css(a).css({\n              cursor: c.options.cursor\n            });\n          }\n        }), c._hasTracking = !0);\n        D(this, \"afterDrawTracker\");\n      };\n\n      h.prototype.remove = function () {\n        var a = this,\n            c = a.chart;\n        c.hasRendered && c.series.forEach(function (c) {\n          c.type === a.type && (c.isDirty = !0);\n        });\n        t.prototype.remove.apply(a, arguments);\n      };\n\n      h.defaultOptions = E(t.defaultOptions, {\n        borderRadius: 0,\n        centerInCategory: !1,\n        groupPadding: .2,\n        marker: null,\n        pointPadding: .1,\n        minPointLength: 0,\n        cropThreshold: 50,\n        pointRange: null,\n        states: {\n          hover: {\n            halo: !1,\n            brightness: .1\n          },\n          select: {\n            color: \"#cccccc\",\n            borderColor: \"#000000\"\n          }\n        },\n        dataLabels: {\n          align: void 0,\n          verticalAlign: void 0,\n          y: void 0\n        },\n        startFromThreshold: !0,\n        stickyTracking: !1,\n        tooltip: {\n          distance: 6\n        },\n        threshold: 0,\n        borderColor: \"#ffffff\"\n      });\n      return h;\n    }(t);\n\n    m(H.prototype, {\n      cropShoulder: 0,\n      directTouch: !0,\n      drawLegendSymbol: F.drawRectangle,\n      getSymbol: d,\n      negStacks: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    });\n    G.registerSeriesType(\"column\", H);\n    \"\";\n    \"\";\n    return H;\n  });\n  N(h, \"Core/Series/DataLabel.js\", [h[\"Core/Animation/AnimationUtilities.js\"], h[\"Core/FormatUtilities.js\"], h[\"Core/Utilities.js\"]], function (d, h, A) {\n    var E = d.getDeferredAnimation,\n        t = h.format,\n        G = A.defined,\n        H = A.extend,\n        y = A.fireEvent,\n        q = A.isArray,\n        p = A.merge,\n        f = A.objectEach,\n        c = A.pick,\n        a = A.splat,\n        n;\n\n    (function (d) {\n      function h(a, f, d, l, e) {\n        var g = this,\n            b = this.chart,\n            k = this.isCartesian && b.inverted,\n            h = this.enabledDataSorting,\n            r = c(a.dlBox && a.dlBox.centerX, a.plotX, -9999),\n            n = c(a.plotY, -9999),\n            m = f.getBBox(),\n            p = d.rotation,\n            u = d.align,\n            q = b.isInsidePlot(r, Math.round(n), {\n          inverted: k,\n          paneCoordinates: !0,\n          series: g\n        }),\n            w = function (b) {\n          h && g.xAxis && !v && g.setDataLabelStartPos(a, f, e, q, b);\n        },\n            v = \"justify\" === c(d.overflow, h ? \"none\" : \"justify\"),\n            z = this.visible && !1 !== a.visible && (a.series.forceDL || h && !v || q || c(d.inside, !!this.options.stacking) && l && b.isInsidePlot(r, k ? l.x + 1 : l.y + l.height - 1, {\n          inverted: k,\n          paneCoordinates: !0,\n          series: g\n        }));\n\n        if (z) {\n          var D = b.renderer.fontMetrics(b.styledMode ? void 0 : d.style.fontSize, f).b;\n          l = H({\n            x: k ? this.yAxis.len - n : r,\n            y: Math.round(k ? this.xAxis.len - r : n),\n            width: 0,\n            height: 0\n          }, l);\n          H(d, {\n            width: m.width,\n            height: m.height\n          });\n          p ? (v = !1, r = b.renderer.rotCorr(D, p), r = {\n            x: l.x + (d.x || 0) + l.width / 2 + r.x,\n            y: l.y + (d.y || 0) + {\n              top: 0,\n              middle: .5,\n              bottom: 1\n            }[d.verticalAlign] * l.height\n          }, w(r), f[e ? \"attr\" : \"animate\"](r).attr({\n            align: u\n          }), w = (p + 720) % 360, w = 180 < w && 360 > w, \"left\" === u ? r.y -= w ? m.height : 0 : \"center\" === u ? (r.x -= m.width / 2, r.y -= m.height / 2) : \"right\" === u && (r.x -= m.width, r.y -= w ? 0 : m.height), f.placed = !0, f.alignAttr = r) : (w(l), f.align(d, void 0, l), r = f.alignAttr);\n          v && 0 <= l.height ? this.justifyDataLabel(f, d, r, m, l, e) : c(d.crop, !0) && (z = b.isInsidePlot(r.x, r.y, {\n            paneCoordinates: !0,\n            series: g\n          }) && b.isInsidePlot(r.x + m.width, r.y + m.height, {\n            paneCoordinates: !0,\n            series: g\n          }));\n          if (d.shape && !p) f[e ? \"attr\" : \"animate\"]({\n            anchorX: k ? b.plotWidth - a.plotY : a.plotX,\n            anchorY: k ? b.plotHeight - a.plotX : a.plotY\n          });\n        }\n\n        e && h && (f.placed = !1);\n        z || h && !v || (f.hide(!0), f.placed = !1);\n      }\n\n      function n(a, c) {\n        var f = c.filter;\n        return f ? (c = f.operator, a = a[f.property], f = f.value, \">\" === c && a > f || \"<\" === c && a < f || \">=\" === c && a >= f || \"<=\" === c && a <= f || \"==\" === c && a == f || \"===\" === c && a === f ? !0 : !1) : !0;\n      }\n\n      function m() {\n        var d = this,\n            k = d.chart,\n            h = d.options,\n            l = d.points,\n            e = d.hasRendered || 0,\n            g = k.renderer,\n            b = h.dataLabels,\n            m,\n            p = b.animation;\n        p = b.defer ? E(k, p, d) : {\n          defer: 0,\n          duration: 0\n        };\n        b = K(K(k.options.plotOptions && k.options.plotOptions.series && k.options.plotOptions.series.dataLabels, k.options.plotOptions && k.options.plotOptions[d.type] && k.options.plotOptions[d.type].dataLabels), b);\n        y(this, \"drawDataLabels\");\n\n        if (q(b) || b.enabled || d._hasPointLabels) {\n          var r = d.plotGroup(\"dataLabelsGroup\", \"data-labels\", e ? \"inherit\" : \"hidden\", b.zIndex || 6);\n          r.attr({\n            opacity: +e\n          });\n          !e && (e = d.dataLabelsGroup) && (d.visible && r.show(!0), e[h.animation ? \"animate\" : \"attr\"]({\n            opacity: 1\n          }, p));\n          l.forEach(function (e) {\n            m = a(K(b, e.dlOptions || e.options && e.options.dataLabels));\n            m.forEach(function (b, a) {\n              var l = b.enabled && (!e.isNull || e.dataLabelOnNull) && n(e, b),\n                  m = e.connectors ? e.connectors[a] : e.connector,\n                  p = e.dataLabels ? e.dataLabels[a] : e.dataLabel,\n                  x = c(b.distance, e.labelDistance),\n                  u = !p;\n\n              if (l) {\n                var B = e.getLabelConfig();\n                var q = c(b[e.formatPrefix + \"Format\"], b.format);\n                B = G(q) ? t(q, B, k) : (b[e.formatPrefix + \"Formatter\"] || b.formatter).call(B, b);\n                q = b.style;\n                var w = b.rotation;\n                k.styledMode || (q.color = c(b.color, q.color, d.color, \"#000000\"), \"contrast\" === q.color ? (e.contrastColor = g.getContrast(e.color || d.color), q.color = !G(x) && b.inside || 0 > x || h.stacking ? e.contrastColor : \"#000000\") : delete e.contrastColor, h.cursor && (q.cursor = h.cursor));\n                var v = {\n                  r: b.borderRadius || 0,\n                  rotation: w,\n                  padding: b.padding,\n                  zIndex: 1\n                };\n                k.styledMode || (v.fill = b.backgroundColor, v.stroke = b.borderColor, v[\"stroke-width\"] = b.borderWidth);\n                f(v, function (b, a) {\n                  \"undefined\" === typeof b && delete v[a];\n                });\n              }\n\n              !p || l && G(B) && !!p.div === !!b.useHTML || (e.dataLabel = p = e.dataLabel && e.dataLabel.destroy(), e.dataLabels && (1 === e.dataLabels.length ? delete e.dataLabels : delete e.dataLabels[a]), a || delete e.dataLabel, m && (e.connector = e.connector.destroy(), e.connectors && (1 === e.connectors.length ? delete e.connectors : delete e.connectors[a])));\n              l && G(B) && (p ? v.text = B : (e.dataLabels = e.dataLabels || [], p = e.dataLabels[a] = w ? g.text(B, 0, -9999, b.useHTML).addClass(\"highcharts-data-label\") : g.label(B, 0, -9999, b.shape, null, null, b.useHTML, null, \"data-label\"), a || (e.dataLabel = p), p.addClass(\" highcharts-data-label-color-\" + e.colorIndex + \" \" + (b.className || \"\") + (b.useHTML ? \" highcharts-tracker\" : \"\"))), p.options = b, p.attr(v), k.styledMode || p.css(q).shadow(b.shadow), p.added || p.add(r), b.textPath && !b.useHTML && (p.setTextPath(e.getDataLabelPath && e.getDataLabelPath(p) || e.graphic, b.textPath), e.dataLabelPath && !b.textPath.enabled && (e.dataLabelPath = e.dataLabelPath.destroy())), d.alignDataLabel(e, p, b, null, u));\n            });\n          });\n        }\n\n        y(this, \"afterDrawDataLabels\");\n      }\n\n      function A(a, c, f, d, e, g) {\n        var b = this.chart,\n            k = c.align,\n            l = c.verticalAlign,\n            r = a.box ? 0 : a.padding || 0,\n            h = c.x;\n        h = void 0 === h ? 0 : h;\n        var n = c.y;\n        n = void 0 === n ? 0 : n;\n        var m = (f.x || 0) + r;\n\n        if (0 > m) {\n          \"right\" === k && 0 <= h ? (c.align = \"left\", c.inside = !0) : h -= m;\n          var p = !0;\n        }\n\n        m = (f.x || 0) + d.width - r;\n        m > b.plotWidth && (\"left\" === k && 0 >= h ? (c.align = \"right\", c.inside = !0) : h += b.plotWidth - m, p = !0);\n        m = f.y + r;\n        0 > m && (\"bottom\" === l && 0 <= n ? (c.verticalAlign = \"top\", c.inside = !0) : n -= m, p = !0);\n        m = (f.y || 0) + d.height - r;\n        m > b.plotHeight && (\"top\" === l && 0 >= n ? (c.verticalAlign = \"bottom\", c.inside = !0) : n += b.plotHeight - m, p = !0);\n        p && (c.x = h, c.y = n, a.placed = !g, a.align(c, void 0, e));\n        return p;\n      }\n\n      function K(a, c) {\n        var f = [],\n            d;\n        if (q(a) && !q(c)) f = a.map(function (a) {\n          return p(a, c);\n        });else if (q(c) && !q(a)) f = c.map(function (e) {\n          return p(a, e);\n        });else if (q(a) || q(c)) for (d = Math.max(a.length, c.length); d--;) f[d] = p(a[d], c[d]);else f = p(a, c);\n        return f;\n      }\n\n      function v(a, c, f, d, e) {\n        var g = this.chart,\n            b = g.inverted,\n            k = this.xAxis,\n            l = k.reversed,\n            r = b ? c.height / 2 : c.width / 2;\n        a = (a = a.pointWidth) ? a / 2 : 0;\n        c.startXPos = b ? e.x : l ? -r - a : k.width - r + a;\n        c.startYPos = b ? l ? this.yAxis.height - r + a : -r - a : e.y;\n        d ? \"hidden\" === c.visibility && (c.show(), c.attr({\n          opacity: 0\n        }).animate({\n          opacity: 1\n        })) : c.attr({\n          opacity: 1\n        }).animate({\n          opacity: 0\n        }, void 0, c.hide);\n        g.hasRendered && (f && c.attr({\n          x: c.startXPos,\n          y: c.startYPos\n        }), c.placed = !0);\n      }\n\n      var z = [];\n\n      d.compose = function (a) {\n        if (-1 === z.indexOf(a)) {\n          var c = a.prototype;\n          z.push(a);\n          c.alignDataLabel = h;\n          c.drawDataLabels = m;\n          c.justifyDataLabel = A;\n          c.setDataLabelStartPos = v;\n        }\n      };\n    })(n || (n = {}));\n\n    \"\";\n    return n;\n  });\n  N(h, \"Series/Column/ColumnDataLabel.js\", [h[\"Core/Series/DataLabel.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"]], function (d, h, A) {\n    var E = h.series,\n        t = A.merge,\n        G = A.pick,\n        H;\n\n    (function (h) {\n      function q(f, c, a, d, h) {\n        var n = this.chart.inverted,\n            m = f.series,\n            p = (m.xAxis ? m.xAxis.len : this.chart.plotSizeX) || 0;\n        m = (m.yAxis ? m.yAxis.len : this.chart.plotSizeY) || 0;\n        var q = f.dlBox || f.shapeArgs,\n            y = G(f.below, f.plotY > G(this.translatedThreshold, m)),\n            v = G(a.inside, !!this.options.stacking);\n        q && (d = t(q), 0 > d.y && (d.height += d.y, d.y = 0), q = d.y + d.height - m, 0 < q && q < d.height && (d.height -= q), n && (d = {\n          x: m - d.y - d.height,\n          y: p - d.x - d.width,\n          width: d.height,\n          height: d.width\n        }), v || (n ? (d.x += y ? 0 : d.width, d.width = 0) : (d.y += y ? d.height : 0, d.height = 0)));\n        a.align = G(a.align, !n || v ? \"center\" : y ? \"right\" : \"left\");\n        a.verticalAlign = G(a.verticalAlign, n || v ? \"middle\" : y ? \"top\" : \"bottom\");\n        E.prototype.alignDataLabel.call(this, f, c, a, d, h);\n        a.inside && f.contrastColor && c.css({\n          color: f.contrastColor\n        });\n      }\n\n      var p = [];\n\n      h.compose = function (f) {\n        d.compose(E);\n        -1 === p.indexOf(f) && (p.push(f), f.prototype.alignDataLabel = q);\n      };\n    })(H || (H = {}));\n\n    return H;\n  });\n  N(h, \"Series/Bar/BarSeries.js\", [h[\"Series/Column/ColumnSeries.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"]], function (d, h, A) {\n    var E = this && this.__extends || function () {\n      var d = function (h, q) {\n        d = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, f) {\n          d.__proto__ = f;\n        } || function (d, f) {\n          for (var c in f) f.hasOwnProperty(c) && (d[c] = f[c]);\n        };\n\n        return d(h, q);\n      };\n\n      return function (h, q) {\n        function p() {\n          this.constructor = h;\n        }\n\n        d(h, q);\n        h.prototype = null === q ? Object.create(q) : (p.prototype = q.prototype, new p());\n      };\n    }(),\n        t = A.extend,\n        G = A.merge;\n\n    A = function (h) {\n      function t() {\n        var d = null !== h && h.apply(this, arguments) || this;\n        d.data = void 0;\n        d.options = void 0;\n        d.points = void 0;\n        return d;\n      }\n\n      E(t, h);\n      t.defaultOptions = G(d.defaultOptions, {});\n      return t;\n    }(d);\n\n    t(A.prototype, {\n      inverted: !0\n    });\n    h.registerSeriesType(\"bar\", A);\n    \"\";\n    return A;\n  });\n  N(h, \"Series/Scatter/ScatterSeries.js\", [h[\"Series/Column/ColumnSeries.js\"], h[\"Series/Line/LineSeries.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"]], function (d, h, A, F) {\n    var t = this && this.__extends || function () {\n      var d = function (h, f) {\n        d = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (c, a) {\n          c.__proto__ = a;\n        } || function (c, a) {\n          for (var f in a) a.hasOwnProperty(f) && (c[f] = a[f]);\n        };\n\n        return d(h, f);\n      };\n\n      return function (h, f) {\n        function c() {\n          this.constructor = h;\n        }\n\n        d(h, f);\n        h.prototype = null === f ? Object.create(f) : (c.prototype = f.prototype, new c());\n      };\n    }(),\n        E = F.addEvent,\n        H = F.extend,\n        y = F.merge;\n\n    F = function (d) {\n      function p() {\n        var f = null !== d && d.apply(this, arguments) || this;\n        f.data = void 0;\n        f.options = void 0;\n        f.points = void 0;\n        return f;\n      }\n\n      t(p, d);\n\n      p.prototype.applyJitter = function () {\n        var f = this,\n            c = this.options.jitter,\n            a = this.points.length;\n        c && this.points.forEach(function (d, h) {\n          [\"x\", \"y\"].forEach(function (n, m) {\n            var p = \"plot\" + n.toUpperCase();\n\n            if (c[n] && !d.isNull) {\n              var q = f[n + \"Axis\"];\n              var t = c[n] * q.transA;\n\n              if (q && !q.isLog) {\n                var v = Math.max(0, d[p] - t);\n                q = Math.min(q.len, d[p] + t);\n                m = 1E4 * Math.sin(h + m * a);\n                d[p] = v + (q - v) * (m - Math.floor(m));\n                \"x\" === n && (d.clientX = d.plotX);\n              }\n            }\n          });\n        });\n      };\n\n      p.prototype.drawGraph = function () {\n        this.options.lineWidth ? d.prototype.drawGraph.call(this) : this.graph && (this.graph = this.graph.destroy());\n      };\n\n      p.defaultOptions = y(h.defaultOptions, {\n        lineWidth: 0,\n        findNearestPointBy: \"xy\",\n        jitter: {\n          x: 0,\n          y: 0\n        },\n        marker: {\n          enabled: !0\n        },\n        tooltip: {\n          headerFormat: '<span style=\"color:{point.color}\">\\u25cf</span> <span style=\"font-size: 10px\"> {series.name}</span><br/>',\n          pointFormat: \"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>\"\n        }\n      });\n      return p;\n    }(h);\n\n    H(F.prototype, {\n      drawTracker: d.prototype.drawTracker,\n      sorted: !1,\n      requireSorting: !1,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      takeOrdinalPosition: !1\n    });\n    E(F, \"afterTranslate\", function () {\n      this.applyJitter();\n    });\n    A.registerSeriesType(\"scatter\", F);\n    \"\";\n    return F;\n  });\n  N(h, \"Series/CenteredUtilities.js\", [h[\"Core/Globals.js\"], h[\"Core/Series/Series.js\"], h[\"Core/Utilities.js\"]], function (d, h, A) {\n    var E = d.deg2rad,\n        t = A.isNumber,\n        G = A.pick,\n        H = A.relativeLength,\n        y;\n\n    (function (d) {\n      d.getCenter = function () {\n        var d = this.options,\n            f = this.chart,\n            c = 2 * (d.slicedOffset || 0),\n            a = f.plotWidth - 2 * c,\n            n = f.plotHeight - 2 * c,\n            m = d.center,\n            q = Math.min(a, n),\n            t = d.size,\n            y = d.innerSize || 0;\n        \"string\" === typeof t && (t = parseFloat(t));\n        \"string\" === typeof y && (y = parseFloat(y));\n        d = [G(m[0], \"50%\"), G(m[1], \"50%\"), G(t && 0 > t ? void 0 : d.size, \"100%\"), G(y && 0 > y ? void 0 : d.innerSize || 0, \"0%\")];\n        !f.angular || this instanceof h || (d[3] = 0);\n\n        for (m = 0; 4 > m; ++m) t = d[m], f = 2 > m || 2 === m && /%$/.test(t), d[m] = H(t, [a, n, q, d[2]][m]) + (f ? c : 0);\n\n        d[3] > d[2] && (d[3] = d[2]);\n        return d;\n      };\n\n      d.getStartAndEndRadians = function (d, f) {\n        d = t(d) ? d : 0;\n        f = t(f) && f > d && 360 > f - d ? f : d + 360;\n        return {\n          start: E * (d + -90),\n          end: E * (f + -90)\n        };\n      };\n    })(y || (y = {}));\n\n    \"\";\n    return y;\n  });\n  N(h, \"Series/Pie/PiePoint.js\", [h[\"Core/Animation/AnimationUtilities.js\"], h[\"Core/Series/Point.js\"], h[\"Core/Utilities.js\"]], function (d, h, A) {\n    var E = this && this.__extends || function () {\n      var f = function (c, a) {\n        f = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, c) {\n          a.__proto__ = c;\n        } || function (a, c) {\n          for (var f in c) c.hasOwnProperty(f) && (a[f] = c[f]);\n        };\n\n        return f(c, a);\n      };\n\n      return function (c, a) {\n        function d() {\n          this.constructor = c;\n        }\n\n        f(c, a);\n        c.prototype = null === a ? Object.create(a) : (d.prototype = a.prototype, new d());\n      };\n    }(),\n        t = d.setAnimation,\n        G = A.addEvent,\n        H = A.defined;\n\n    d = A.extend;\n    var y = A.isNumber,\n        q = A.pick,\n        p = A.relativeLength;\n\n    h = function (f) {\n      function c() {\n        var a = null !== f && f.apply(this, arguments) || this;\n        a.labelDistance = void 0;\n        a.options = void 0;\n        a.series = void 0;\n        return a;\n      }\n\n      E(c, f);\n\n      c.prototype.getConnectorPath = function () {\n        var a = this.labelPosition,\n            c = this.series.options.dataLabels,\n            f = this.connectorShapes,\n            d = c.connectorShape;\n        f[d] && (d = f[d]);\n        return d.call(this, {\n          x: a.final.x,\n          y: a.final.y,\n          alignment: a.alignment\n        }, a.connectorPosition, c);\n      };\n\n      c.prototype.getTranslate = function () {\n        return this.sliced ? this.slicedTranslation : {\n          translateX: 0,\n          translateY: 0\n        };\n      };\n\n      c.prototype.haloPath = function (a) {\n        var c = this.shapeArgs;\n        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(c.x, c.y, c.r + a, c.r + a, {\n          innerR: c.r - 1,\n          start: c.start,\n          end: c.end\n        });\n      };\n\n      c.prototype.init = function () {\n        var a = this;\n        f.prototype.init.apply(this, arguments);\n        this.name = q(this.name, \"Slice\");\n\n        var c = function (c) {\n          a.slice(\"select\" === c.type);\n        };\n\n        G(this, \"select\", c);\n        G(this, \"unselect\", c);\n        return this;\n      };\n\n      c.prototype.isValid = function () {\n        return y(this.y) && 0 <= this.y;\n      };\n\n      c.prototype.setVisible = function (a, c) {\n        var f = this,\n            d = this.series,\n            h = d.chart,\n            n = d.options.ignoreHiddenPoint;\n        c = q(c, n);\n        a !== this.visible && (this.visible = this.options.visible = a = \"undefined\" === typeof a ? !this.visible : a, d.options.data[d.data.indexOf(this)] = this.options, [\"graphic\", \"dataLabel\", \"connector\", \"shadowGroup\"].forEach(function (c) {\n          if (f[c]) f[c][a ? \"show\" : \"hide\"](a);\n        }), this.legendItem && h.legend.colorizeItem(this, a), a || \"hover\" !== this.state || this.setState(\"\"), n && (d.isDirty = !0), c && h.redraw());\n      };\n\n      c.prototype.slice = function (a, c, f) {\n        var d = this.series;\n        t(f, d.chart);\n        q(c, !0);\n        this.sliced = this.options.sliced = H(a) ? a : !this.sliced;\n        d.options.data[d.data.indexOf(this)] = this.options;\n        this.graphic && this.graphic.animate(this.getTranslate());\n        this.shadowGroup && this.shadowGroup.animate(this.getTranslate());\n      };\n\n      return c;\n    }(h);\n\n    d(h.prototype, {\n      connectorShapes: {\n        fixedOffset: function (f, c, a) {\n          var d = c.breakAt;\n          c = c.touchingSliceAt;\n          return [[\"M\", f.x, f.y], a.softConnector ? [\"C\", f.x + (\"left\" === f.alignment ? -5 : 5), f.y, 2 * d.x - c.x, 2 * d.y - c.y, d.x, d.y] : [\"L\", d.x, d.y], [\"L\", c.x, c.y]];\n        },\n        straight: function (f, c) {\n          c = c.touchingSliceAt;\n          return [[\"M\", f.x, f.y], [\"L\", c.x, c.y]];\n        },\n        crookedLine: function (f, c, a) {\n          c = c.touchingSliceAt;\n          var d = this.series,\n              h = d.center[0],\n              q = d.chart.plotWidth,\n              t = d.chart.plotLeft;\n          d = f.alignment;\n          var y = this.shapeArgs.r;\n          a = p(a.crookDistance, 1);\n          q = \"left\" === d ? h + y + (q + t - h - y) * (1 - a) : t + (h - y) * a;\n          a = [\"L\", q, f.y];\n          h = !0;\n          if (\"left\" === d ? q > f.x || q < c.x : q < f.x || q > c.x) h = !1;\n          f = [[\"M\", f.x, f.y]];\n          h && f.push(a);\n          f.push([\"L\", c.x, c.y]);\n          return f;\n        }\n      }\n    });\n    return h;\n  });\n  N(h, \"Series/Pie/PieSeries.js\", [h[\"Series/CenteredUtilities.js\"], h[\"Series/Column/ColumnSeries.js\"], h[\"Core/Globals.js\"], h[\"Core/Legend/LegendSymbol.js\"], h[\"Series/Pie/PiePoint.js\"], h[\"Core/Series/Series.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Renderer/SVG/Symbols.js\"], h[\"Core/Utilities.js\"]], function (d, h, A, F, t, G, H, y, q) {\n    var p = this && this.__extends || function () {\n      var a = function (c, f) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, c) {\n          a.__proto__ = c;\n        } || function (a, c) {\n          for (var f in c) c.hasOwnProperty(f) && (a[f] = c[f]);\n        };\n\n        return a(c, f);\n      };\n\n      return function (c, f) {\n        function d() {\n          this.constructor = c;\n        }\n\n        a(c, f);\n        c.prototype = null === f ? Object.create(f) : (d.prototype = f.prototype, new d());\n      };\n    }(),\n        f = d.getStartAndEndRadians;\n\n    A = A.noop;\n    var c = q.clamp,\n        a = q.extend,\n        n = q.fireEvent,\n        m = q.merge,\n        D = q.pick,\n        C = q.relativeLength;\n\n    q = function (a) {\n      function d() {\n        var c = null !== a && a.apply(this, arguments) || this;\n        c.center = void 0;\n        c.data = void 0;\n        c.maxLabelDistance = void 0;\n        c.options = void 0;\n        c.points = void 0;\n        return c;\n      }\n\n      p(d, a);\n\n      d.prototype.animate = function (a) {\n        var c = this,\n            f = c.points,\n            d = c.startAngleRad;\n        a || f.forEach(function (a) {\n          var f = a.graphic,\n              k = a.shapeArgs;\n          f && k && (f.attr({\n            r: D(a.startR, c.center && c.center[3] / 2),\n            start: d,\n            end: d\n          }), f.animate({\n            r: k.r,\n            start: k.start,\n            end: k.end\n          }, c.options.animation));\n        });\n      };\n\n      d.prototype.drawEmpty = function () {\n        var a = this.startAngleRad,\n            c = this.endAngleRad,\n            f = this.options;\n\n        if (0 === this.total && this.center) {\n          var d = this.center[0];\n          var k = this.center[1];\n          this.graph || (this.graph = this.chart.renderer.arc(d, k, this.center[1] / 2, 0, a, c).addClass(\"highcharts-empty-series\").add(this.group));\n          this.graph.attr({\n            d: y.arc(d, k, this.center[2] / 2, 0, {\n              start: a,\n              end: c,\n              innerR: this.center[3] / 2\n            })\n          });\n          this.chart.styledMode || this.graph.attr({\n            \"stroke-width\": f.borderWidth,\n            fill: f.fillColor || \"none\",\n            stroke: f.color || \"#cccccc\"\n          });\n        } else this.graph && (this.graph = this.graph.destroy());\n      };\n\n      d.prototype.drawPoints = function () {\n        var a = this.chart.renderer;\n        this.points.forEach(function (c) {\n          c.graphic && c.hasNewShapeType() && (c.graphic = c.graphic.destroy());\n          c.graphic || (c.graphic = a[c.shapeType](c.shapeArgs).add(c.series.group), c.delayedRendering = !0);\n        });\n      };\n\n      d.prototype.generatePoints = function () {\n        a.prototype.generatePoints.call(this);\n        this.updateTotals();\n      };\n\n      d.prototype.getX = function (a, f, d) {\n        var h = this.center,\n            k = this.radii ? this.radii[d.index] || 0 : h[2] / 2;\n        a = Math.asin(c((a - h[1]) / (k + d.labelDistance), -1, 1));\n        return h[0] + (f ? -1 : 1) * Math.cos(a) * (k + d.labelDistance) + (0 < d.labelDistance ? (f ? -1 : 1) * this.options.dataLabels.padding : 0);\n      };\n\n      d.prototype.hasData = function () {\n        return !!this.processedXData.length;\n      };\n\n      d.prototype.redrawPoints = function () {\n        var a = this,\n            c = a.chart,\n            f = c.renderer,\n            d = a.options.shadow,\n            k,\n            h,\n            l,\n            e;\n        this.drawEmpty();\n        !d || a.shadowGroup || c.styledMode || (a.shadowGroup = f.g(\"shadow\").attr({\n          zIndex: -1\n        }).add(a.group));\n        a.points.forEach(function (g) {\n          var b = {};\n          h = g.graphic;\n\n          if (!g.isNull && h) {\n            var n = void 0;\n            e = g.shapeArgs;\n            k = g.getTranslate();\n            c.styledMode || (n = g.shadowGroup, d && !n && (n = g.shadowGroup = f.g(\"shadow\").add(a.shadowGroup)), n && n.attr(k), l = a.pointAttribs(g, g.selected && \"select\"));\n            g.delayedRendering ? (h.setRadialReference(a.center).attr(e).attr(k), c.styledMode || h.attr(l).attr({\n              \"stroke-linejoin\": \"round\"\n            }).shadow(d, n), g.delayedRendering = !1) : (h.setRadialReference(a.center), c.styledMode || m(!0, b, l), m(!0, b, e, k), h.animate(b));\n            h.attr({\n              visibility: g.visible ? \"inherit\" : \"hidden\"\n            });\n            h.addClass(g.getClassName(), !0);\n          } else h && (g.graphic = h.destroy());\n        });\n      };\n\n      d.prototype.sortByAngle = function (a, c) {\n        a.sort(function (a, f) {\n          return \"undefined\" !== typeof a.angle && (f.angle - a.angle) * c;\n        });\n      };\n\n      d.prototype.translate = function (a) {\n        this.generatePoints();\n        var c = this.options,\n            d = c.slicedOffset,\n            h = d + (c.borderWidth || 0),\n            k = f(c.startAngle, c.endAngle),\n            m = this.startAngleRad = k.start;\n        k = (this.endAngleRad = k.end) - m;\n        var l = this.points,\n            e = c.dataLabels.distance;\n        c = c.ignoreHiddenPoint;\n        var g = l.length,\n            b,\n            p = 0;\n        a || (this.center = a = this.getCenter());\n\n        for (b = 0; b < g; b++) {\n          var q = l[b];\n          var r = m + p * k;\n          !q.isValid() || c && !q.visible || (p += q.percentage / 100);\n          var x = m + p * k;\n          var M = {\n            x: a[0],\n            y: a[1],\n            r: a[2] / 2,\n            innerR: a[3] / 2,\n            start: Math.round(1E3 * r) / 1E3,\n            end: Math.round(1E3 * x) / 1E3\n          };\n          q.shapeType = \"arc\";\n          q.shapeArgs = M;\n          q.labelDistance = D(q.options.dataLabels && q.options.dataLabels.distance, e);\n          q.labelDistance = C(q.labelDistance, M.r);\n          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, q.labelDistance);\n          x = (x + r) / 2;\n          x > 1.5 * Math.PI ? x -= 2 * Math.PI : x < -Math.PI / 2 && (x += 2 * Math.PI);\n          q.slicedTranslation = {\n            translateX: Math.round(Math.cos(x) * d),\n            translateY: Math.round(Math.sin(x) * d)\n          };\n          M = Math.cos(x) * a[2] / 2;\n          var t = Math.sin(x) * a[2] / 2;\n          q.tooltipPos = [a[0] + .7 * M, a[1] + .7 * t];\n          q.half = x < -Math.PI / 2 || x > Math.PI / 2 ? 1 : 0;\n          q.angle = x;\n          r = Math.min(h, q.labelDistance / 5);\n          q.labelPosition = {\n            natural: {\n              x: a[0] + M + Math.cos(x) * q.labelDistance,\n              y: a[1] + t + Math.sin(x) * q.labelDistance\n            },\n            \"final\": {},\n            alignment: 0 > q.labelDistance ? \"center\" : q.half ? \"right\" : \"left\",\n            connectorPosition: {\n              breakAt: {\n                x: a[0] + M + Math.cos(x) * r,\n                y: a[1] + t + Math.sin(x) * r\n              },\n              touchingSliceAt: {\n                x: a[0] + M,\n                y: a[1] + t\n              }\n            }\n          };\n        }\n\n        n(this, \"afterTranslate\");\n      };\n\n      d.prototype.updateTotals = function () {\n        var a = this.points,\n            c = a.length,\n            f = this.options.ignoreHiddenPoint,\n            d,\n            k = 0;\n\n        for (d = 0; d < c; d++) {\n          var h = a[d];\n          !h.isValid() || f && !h.visible || (k += h.y);\n        }\n\n        this.total = k;\n\n        for (d = 0; d < c; d++) h = a[d], h.percentage = 0 < k && (h.visible || !f) ? h.y / k * 100 : 0, h.total = k;\n      };\n\n      d.defaultOptions = m(G.defaultOptions, {\n        center: [null, null],\n        clip: !1,\n        colorByPoint: !0,\n        dataLabels: {\n          allowOverlap: !0,\n          connectorPadding: 5,\n          connectorShape: \"fixedOffset\",\n          crookDistance: \"70%\",\n          distance: 30,\n          enabled: !0,\n          formatter: function () {\n            return this.point.isNull ? void 0 : this.point.name;\n          },\n          softConnector: !0,\n          x: 0\n        },\n        fillColor: void 0,\n        ignoreHiddenPoint: !0,\n        inactiveOtherPoints: !0,\n        legendType: \"point\",\n        marker: null,\n        size: null,\n        showInLegend: !1,\n        slicedOffset: 10,\n        stickyTracking: !1,\n        tooltip: {\n          followPointer: !0\n        },\n        borderColor: \"#ffffff\",\n        borderWidth: 1,\n        lineWidth: void 0,\n        states: {\n          hover: {\n            brightness: .1\n          }\n        }\n      });\n      return d;\n    }(G);\n\n    a(q.prototype, {\n      axisTypes: [],\n      directTouch: !0,\n      drawGraph: void 0,\n      drawLegendSymbol: F.drawRectangle,\n      drawTracker: h.prototype.drawTracker,\n      getCenter: d.getCenter,\n      getSymbol: A,\n      isCartesian: !1,\n      noSharedTooltip: !0,\n      pointAttribs: h.prototype.pointAttribs,\n      pointClass: t,\n      requireSorting: !1,\n      searchPoint: A,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    });\n    H.registerSeriesType(\"pie\", q);\n    \"\";\n    return q;\n  });\n  N(h, \"Series/Pie/PieDataLabel.js\", [h[\"Core/Series/DataLabel.js\"], h[\"Core/Globals.js\"], h[\"Core/Renderer/RendererUtilities.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"]], function (d, h, A, F, t) {\n    var E = h.noop,\n        H = A.distribute,\n        y = F.series,\n        q = t.arrayMax,\n        p = t.clamp,\n        f = t.defined,\n        c = t.merge,\n        a = t.pick,\n        n = t.relativeLength,\n        m;\n\n    (function (h) {\n      function m() {\n        var d = this,\n            h = d.data,\n            k = d.chart,\n            m = d.options.dataLabels || {},\n            l = m.connectorPadding,\n            e = k.plotWidth,\n            g = k.plotHeight,\n            b = k.plotLeft,\n            n = Math.round(k.chartWidth / 3),\n            p = d.center,\n            r = p[2] / 2,\n            x = p[1],\n            v = [[], []],\n            t = [0, 0, 0, 0],\n            D = d.dataLabelPositioners,\n            C,\n            E,\n            A,\n            I,\n            F,\n            G,\n            L,\n            K,\n            N,\n            T,\n            U,\n            S;\n        d.visible && (m.enabled || d._hasPointLabels) && (h.forEach(function (b) {\n          b.dataLabel && b.visible && b.dataLabel.shortened && (b.dataLabel.attr({\n            width: \"auto\"\n          }).css({\n            width: \"auto\",\n            textOverflow: \"clip\"\n          }), b.dataLabel.shortened = !1);\n        }), y.prototype.drawDataLabels.apply(d), h.forEach(function (b) {\n          b.dataLabel && (b.visible ? (v[b.half].push(b), b.dataLabel._pos = null, !f(m.style.width) && !f(b.options.dataLabels && b.options.dataLabels.style && b.options.dataLabels.style.width) && b.dataLabel.getBBox().width > n && (b.dataLabel.css({\n            width: Math.round(.7 * n) + \"px\"\n          }), b.dataLabel.shortened = !0)) : (b.dataLabel = b.dataLabel.destroy(), b.dataLabels && 1 === b.dataLabels.length && delete b.dataLabels));\n        }), v.forEach(function (c, h) {\n          var n = c.length,\n              q = [],\n              B;\n\n          if (n) {\n            d.sortByAngle(c, h - .5);\n\n            if (0 < d.maxLabelDistance) {\n              var u = Math.max(0, x - r - d.maxLabelDistance);\n              var w = Math.min(x + r + d.maxLabelDistance, k.plotHeight);\n              c.forEach(function (b) {\n                0 < b.labelDistance && b.dataLabel && (b.top = Math.max(0, x - r - b.labelDistance), b.bottom = Math.min(x + r + b.labelDistance, k.plotHeight), B = b.dataLabel.getBBox().height || 21, b.distributeBox = {\n                  target: b.labelPosition.natural.y - b.top + B / 2,\n                  size: B,\n                  rank: b.y\n                }, q.push(b.distributeBox));\n              });\n              u = w + B - u;\n              H(q, u, u / 5);\n            }\n\n            for (U = 0; U < n; U++) {\n              C = c[U];\n              G = C.labelPosition;\n              I = C.dataLabel;\n              T = !1 === C.visible ? \"hidden\" : \"inherit\";\n              N = u = G.natural.y;\n              q && f(C.distributeBox) && (\"undefined\" === typeof C.distributeBox.pos ? T = \"hidden\" : (L = C.distributeBox.size, N = D.radialDistributionY(C)));\n              delete C.positionIndex;\n              if (m.justify) K = D.justify(C, r, p);else switch (m.alignTo) {\n                case \"connectors\":\n                  K = D.alignToConnectors(c, h, e, b);\n                  break;\n\n                case \"plotEdges\":\n                  K = D.alignToPlotEdges(I, h, e, b);\n                  break;\n\n                default:\n                  K = D.radialDistributionX(d, C, N, u);\n              }\n              I._attr = {\n                visibility: T,\n                align: G.alignment\n              };\n              S = C.options.dataLabels || {};\n              I._pos = {\n                x: K + a(S.x, m.x) + ({\n                  left: l,\n                  right: -l\n                }[G.alignment] || 0),\n                y: N + a(S.y, m.y) - 10\n              };\n              G.final.x = K;\n              G.final.y = N;\n              a(m.crop, !0) && (F = I.getBBox().width, u = null, K - F < l && 1 === h ? (u = Math.round(F - K + l), t[3] = Math.max(u, t[3])) : K + F > e - l && 0 === h && (u = Math.round(K + F - e + l), t[1] = Math.max(u, t[1])), 0 > N - L / 2 ? t[0] = Math.max(Math.round(-N + L / 2), t[0]) : N + L / 2 > g && (t[2] = Math.max(Math.round(N + L / 2 - g), t[2])), I.sideOverflow = u);\n            }\n          }\n        }), 0 === q(t) || this.verifyDataLabelOverflow(t)) && (this.placeDataLabels(), this.points.forEach(function (b) {\n          S = c(m, b.options.dataLabels);\n\n          if (E = a(S.connectorWidth, 1)) {\n            var e;\n            A = b.connector;\n\n            if ((I = b.dataLabel) && I._pos && b.visible && 0 < b.labelDistance) {\n              T = I._attr.visibility;\n              if (e = !A) b.connector = A = k.renderer.path().addClass(\"highcharts-data-label-connector  highcharts-color-\" + b.colorIndex + (b.className ? \" \" + b.className : \"\")).add(d.dataLabelsGroup), k.styledMode || A.attr({\n                \"stroke-width\": E,\n                stroke: S.connectorColor || b.color || \"#666666\"\n              });\n              A[e ? \"attr\" : \"animate\"]({\n                d: b.getConnectorPath()\n              });\n              A.attr(\"visibility\", T);\n            } else A && (b.connector = A.destroy());\n          }\n        }));\n      }\n\n      function t() {\n        this.points.forEach(function (a) {\n          var c = a.dataLabel,\n              f;\n          c && a.visible && ((f = c._pos) ? (c.sideOverflow && (c._attr.width = Math.max(c.getBBox().width - c.sideOverflow, 0), c.css({\n            width: c._attr.width + \"px\",\n            textOverflow: (this.options.dataLabels.style || {}).textOverflow || \"ellipsis\"\n          }), c.shortened = !0), c.attr(c._attr), c[c.moved ? \"animate\" : \"attr\"](f), c.moved = !0) : c && c.attr({\n            y: -9999\n          }));\n          delete a.distributeBox;\n        }, this);\n      }\n\n      function D(a) {\n        var c = this.center,\n            f = this.options,\n            d = f.center,\n            l = f.minSize || 80,\n            e = null !== f.size;\n\n        if (!e) {\n          if (null !== d[0]) var g = Math.max(c[2] - Math.max(a[1], a[3]), l);else g = Math.max(c[2] - a[1] - a[3], l), c[0] += (a[3] - a[1]) / 2;\n          null !== d[1] ? g = p(g, l, c[2] - Math.max(a[0], a[2])) : (g = p(g, l, c[2] - a[0] - a[2]), c[1] += (a[0] - a[2]) / 2);\n          g < c[2] ? (c[2] = g, c[3] = Math.min(n(f.innerSize || 0, g), g), this.translate(c), this.drawDataLabels && this.drawDataLabels()) : e = !0;\n        }\n\n        return e;\n      }\n\n      var A = [],\n          v = {\n        radialDistributionY: function (a) {\n          return a.top + a.distributeBox.pos;\n        },\n        radialDistributionX: function (a, c, f, d) {\n          return a.getX(f < c.top + 2 || f > c.bottom - 2 ? d : f, c.half, c);\n        },\n        justify: function (a, c, f) {\n          return f[0] + (a.half ? -1 : 1) * (c + a.labelDistance);\n        },\n        alignToPlotEdges: function (a, c, f, d) {\n          a = a.getBBox().width;\n          return c ? a + d : f - a - d;\n        },\n        alignToConnectors: function (a, c, f, d) {\n          var k = 0,\n              e;\n          a.forEach(function (a) {\n            e = a.dataLabel.getBBox().width;\n            e > k && (k = e);\n          });\n          return c ? k + d : f - k - d;\n        }\n      };\n\n      h.compose = function (a) {\n        d.compose(y);\n        -1 === A.indexOf(a) && (A.push(a), a = a.prototype, a.dataLabelPositioners = v, a.alignDataLabel = E, a.drawDataLabels = m, a.placeDataLabels = t, a.verifyDataLabelOverflow = D);\n      };\n    })(m || (m = {}));\n\n    return m;\n  });\n  N(h, \"Extensions/OverlappingDataLabels.js\", [h[\"Core/Chart/Chart.js\"], h[\"Core/Utilities.js\"]], function (d, h) {\n    function E(d, f) {\n      var c = !1;\n\n      if (d) {\n        var a = d.newOpacity;\n        d.oldOpacity !== a && (d.alignAttr && d.placed ? (d[a ? \"removeClass\" : \"addClass\"](\"highcharts-data-label-hidden\"), c = !0, d.alignAttr.opacity = a, d[d.isOld ? \"animate\" : \"attr\"](d.alignAttr, null, function () {\n          f.styledMode || d.css({\n            pointerEvents: a ? \"auto\" : \"none\"\n          });\n        }), t(f, \"afterHideOverlappingLabel\")) : d.attr({\n          opacity: a\n        }));\n        d.isOld = !0;\n      }\n\n      return c;\n    }\n\n    var F = h.addEvent,\n        t = h.fireEvent,\n        G = h.isArray,\n        H = h.isNumber,\n        y = h.objectEach,\n        q = h.pick;\n    F(d, \"render\", function () {\n      var d = this,\n          f = [];\n      (this.labelCollectors || []).forEach(function (c) {\n        f = f.concat(c());\n      });\n      (this.yAxis || []).forEach(function (c) {\n        c.stacking && c.options.stackLabels && !c.options.stackLabels.allowOverlap && y(c.stacking.stacks, function (a) {\n          y(a, function (a) {\n            a.label && \"hidden\" !== a.label.visibility && f.push(a.label);\n          });\n        });\n      });\n      (this.series || []).forEach(function (c) {\n        var a = c.options.dataLabels;\n        c.visible && (!1 !== a.enabled || c._hasPointLabels) && (a = function (a) {\n          return a.forEach(function (a) {\n            a.visible && (G(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : []).forEach(function (c) {\n              var h = c.options;\n              c.labelrank = q(h.labelrank, a.labelrank, a.shapeArgs && a.shapeArgs.height);\n              h.allowOverlap ? (c.oldOpacity = c.opacity, c.newOpacity = 1, E(c, d)) : f.push(c);\n            });\n          });\n        }, a(c.nodes || []), a(c.points));\n      });\n      this.hideOverlappingLabels(f);\n    });\n\n    d.prototype.hideOverlappingLabels = function (d) {\n      var f = this,\n          c = d.length,\n          a = f.renderer,\n          h,\n          m,\n          p,\n          q = !1;\n\n      var y = function (c) {\n        var f,\n            d = c.box ? 0 : c.padding || 0,\n            k = f = 0,\n            h;\n\n        if (c && (!c.alignAttr || c.placed)) {\n          var l = c.alignAttr || {\n            x: c.attr(\"x\"),\n            y: c.attr(\"y\")\n          };\n          var e = c.parentGroup;\n          c.width || (f = c.getBBox(), c.width = f.width, c.height = f.height, f = a.fontMetrics(null, c.element).h);\n          var g = c.width - 2 * d;\n          (h = {\n            left: \"0\",\n            center: \"0.5\",\n            right: \"1\"\n          }[c.alignValue]) ? k = +h * g : H(c.x) && Math.round(c.x) !== c.translateX && (k = c.x - c.translateX);\n          return {\n            x: l.x + (e.translateX || 0) + d - (k || 0),\n            y: l.y + (e.translateY || 0) + d - f,\n            width: c.width - 2 * d,\n            height: c.height - 2 * d\n          };\n        }\n      };\n\n      for (m = 0; m < c; m++) if (h = d[m]) h.oldOpacity = h.opacity, h.newOpacity = 1, h.absoluteBox = y(h);\n\n      d.sort(function (a, c) {\n        return (c.labelrank || 0) - (a.labelrank || 0);\n      });\n\n      for (m = 0; m < c; m++) {\n        var A = (y = d[m]) && y.absoluteBox;\n\n        for (h = m + 1; h < c; ++h) {\n          var F = (p = d[h]) && p.absoluteBox;\n          !A || !F || y === p || 0 === y.newOpacity || 0 === p.newOpacity || F.x >= A.x + A.width || F.x + F.width <= A.x || F.y >= A.y + A.height || F.y + F.height <= A.y || ((y.labelrank < p.labelrank ? y : p).newOpacity = 0);\n        }\n      }\n\n      d.forEach(function (a) {\n        E(a, f) && (q = !0);\n      });\n      q && t(f, \"afterHideAllOverlappingLabels\");\n    };\n  });\n  N(h, \"Core/Responsive.js\", [h[\"Core/Utilities.js\"]], function (d) {\n    var h = d.extend,\n        A = d.find,\n        F = d.isArray,\n        t = d.isObject,\n        G = d.merge,\n        H = d.objectEach,\n        y = d.pick,\n        q = d.splat,\n        p = d.uniqueKey,\n        f;\n\n    (function (c) {\n      var a = [];\n\n      c.compose = function (c) {\n        -1 === a.indexOf(c) && (a.push(c), h(c.prototype, f.prototype));\n        return c;\n      };\n\n      var f = function () {\n        function a() {}\n\n        a.prototype.currentOptions = function (a) {\n          function c(a, d, h, m) {\n            var k;\n            H(a, function (a, l) {\n              if (!m && -1 < f.collectionsWithUpdate.indexOf(l) && d[l]) for (a = q(a), h[l] = [], k = 0; k < Math.max(a.length, d[l].length); k++) d[l][k] && (void 0 === a[k] ? h[l][k] = d[l][k] : (h[l][k] = {}, c(a[k], d[l][k], h[l][k], m + 1)));else t(a) ? (h[l] = F(a) ? [] : {}, c(a, d[l] || {}, h[l], m + 1)) : h[l] = \"undefined\" === typeof d[l] ? null : d[l];\n            });\n          }\n\n          var f = this,\n              d = {};\n          c(a, this.options, d, 0);\n          return d;\n        };\n\n        a.prototype.matchResponsiveRule = function (a, c) {\n          var f = a.condition;\n          (f.callback || function () {\n            return this.chartWidth <= y(f.maxWidth, Number.MAX_VALUE) && this.chartHeight <= y(f.maxHeight, Number.MAX_VALUE) && this.chartWidth >= y(f.minWidth, 0) && this.chartHeight >= y(f.minHeight, 0);\n          }).call(this) && c.push(a._id);\n        };\n\n        a.prototype.setResponsive = function (a, c) {\n          var f = this,\n              d = this.options.responsive,\n              h = this.currentResponsive,\n              m = [];\n          !c && d && d.rules && d.rules.forEach(function (a) {\n            \"undefined\" === typeof a._id && (a._id = p());\n            f.matchResponsiveRule(a, m);\n          }, this);\n          c = G.apply(void 0, m.map(function (a) {\n            return A((d || {}).rules || [], function (c) {\n              return c._id === a;\n            });\n          }).map(function (a) {\n            return a && a.chartOptions;\n          }));\n          c.isResponsiveOptions = !0;\n          m = m.toString() || void 0;\n          m !== (h && h.ruleIds) && (h && this.update(h.undoOptions, a, !0), m ? (h = this.currentOptions(c), h.isResponsiveOptions = !0, this.currentResponsive = {\n            ruleIds: m,\n            mergedOptions: c,\n            undoOptions: h\n          }, this.update(c, a, !0)) : this.currentResponsive = void 0);\n        };\n\n        return a;\n      }();\n    })(f || (f = {}));\n\n    \"\";\n    \"\";\n    return f;\n  });\n  N(h, \"masters/highcharts.src.js\", [h[\"Core/Globals.js\"], h[\"Core/Utilities.js\"], h[\"Core/DefaultOptions.js\"], h[\"Core/Animation/Fx.js\"], h[\"Core/Animation/AnimationUtilities.js\"], h[\"Core/Renderer/HTML/AST.js\"], h[\"Core/FormatUtilities.js\"], h[\"Core/Renderer/RendererUtilities.js\"], h[\"Core/Renderer/SVG/SVGElement.js\"], h[\"Core/Renderer/SVG/SVGRenderer.js\"], h[\"Core/Renderer/HTML/HTMLElement.js\"], h[\"Core/Renderer/HTML/HTMLRenderer.js\"], h[\"Core/Axis/Axis.js\"], h[\"Core/Axis/DateTimeAxis.js\"], h[\"Core/Axis/LogarithmicAxis.js\"], h[\"Core/Axis/PlotLineOrBand/PlotLineOrBand.js\"], h[\"Core/Axis/Tick.js\"], h[\"Core/Tooltip.js\"], h[\"Core/Series/Point.js\"], h[\"Core/Pointer.js\"], h[\"Core/MSPointer.js\"], h[\"Core/Legend/Legend.js\"], h[\"Core/Chart/Chart.js\"], h[\"Core/Series/Series.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Series/Column/ColumnSeries.js\"], h[\"Series/Column/ColumnDataLabel.js\"], h[\"Series/Pie/PieSeries.js\"], h[\"Series/Pie/PieDataLabel.js\"], h[\"Core/Series/DataLabel.js\"], h[\"Core/Responsive.js\"], h[\"Core/Color/Color.js\"], h[\"Core/Time.js\"]], function (d, h, A, F, t, G, H, y, q, p, f, c, a, n, m, D, C, I, L, K, v, z, u, k, w, l, e, g, b, B, J, r, x) {\n    d.animate = t.animate;\n    d.animObject = t.animObject;\n    d.getDeferredAnimation = t.getDeferredAnimation;\n    d.setAnimation = t.setAnimation;\n    d.stop = t.stop;\n    d.timers = F.timers;\n    d.AST = G;\n    d.Axis = a;\n    d.Chart = u;\n    d.chart = u.chart;\n    d.Fx = F;\n    d.Legend = z;\n    d.PlotLineOrBand = D;\n    d.Point = L;\n    d.Pointer = v.isRequired() ? v : K;\n    d.Series = k;\n    d.SVGElement = q;\n    d.SVGRenderer = p;\n    d.Tick = C;\n    d.Time = x;\n    d.Tooltip = I;\n    d.Color = r;\n    d.color = r.parse;\n    c.compose(p);\n    f.compose(q);\n    d.defaultOptions = A.defaultOptions;\n    d.getOptions = A.getOptions;\n    d.time = A.defaultTime;\n    d.setOptions = A.setOptions;\n    d.dateFormat = H.dateFormat;\n    d.format = H.format;\n    d.numberFormat = H.numberFormat;\n    d.addEvent = h.addEvent;\n    d.arrayMax = h.arrayMax;\n    d.arrayMin = h.arrayMin;\n    d.attr = h.attr;\n    d.clearTimeout = h.clearTimeout;\n    d.correctFloat = h.correctFloat;\n    d.createElement = h.createElement;\n    d.css = h.css;\n    d.defined = h.defined;\n    d.destroyObjectProperties = h.destroyObjectProperties;\n    d.discardElement = h.discardElement;\n    d.distribute = y.distribute;\n    d.erase = h.erase;\n    d.error = h.error;\n    d.extend = h.extend;\n    d.extendClass = h.extendClass;\n    d.find = h.find;\n    d.fireEvent = h.fireEvent;\n    d.getMagnitude = h.getMagnitude;\n    d.getStyle = h.getStyle;\n    d.inArray = h.inArray;\n    d.isArray = h.isArray;\n    d.isClass = h.isClass;\n    d.isDOMElement = h.isDOMElement;\n    d.isFunction = h.isFunction;\n    d.isNumber = h.isNumber;\n    d.isObject = h.isObject;\n    d.isString = h.isString;\n    d.keys = h.keys;\n    d.merge = h.merge;\n    d.normalizeTickInterval = h.normalizeTickInterval;\n    d.objectEach = h.objectEach;\n    d.offset = h.offset;\n    d.pad = h.pad;\n    d.pick = h.pick;\n    d.pInt = h.pInt;\n    d.relativeLength = h.relativeLength;\n    d.removeEvent = h.removeEvent;\n    d.seriesType = w.seriesType;\n    d.splat = h.splat;\n    d.stableSort = h.stableSort;\n    d.syncTimeout = h.syncTimeout;\n    d.timeUnits = h.timeUnits;\n    d.uniqueKey = h.uniqueKey;\n    d.useSerialIds = h.useSerialIds;\n    d.wrap = h.wrap;\n    e.compose(l);\n    B.compose(k);\n    n.compose(a);\n    m.compose(a);\n    b.compose(g);\n    D.compose(a);\n    J.compose(u);\n    return d;\n  });\n  N(h, \"Core/Axis/OrdinalAxis.js\", [h[\"Core/Axis/Axis.js\"], h[\"Core/Globals.js\"], h[\"Core/Series/Series.js\"], h[\"Core/Utilities.js\"]], function (d, h, A, F) {\n    var t = F.addEvent,\n        E = F.correctFloat,\n        H = F.css,\n        y = F.defined,\n        q = F.error,\n        p = F.pick,\n        f = F.timeUnits,\n        c = [],\n        a;\n\n    (function (a) {\n      function d(a, c, b, d, k, l, h) {\n        void 0 === k && (k = []);\n        void 0 === l && (l = 0);\n        var e = {},\n            g = this.options.tickPixelInterval,\n            r = this.chart.time,\n            m = [],\n            n,\n            p,\n            x = 0,\n            B = [],\n            u = -Number.MAX_VALUE;\n        if (!this.options.ordinal && !this.options.breaks || !k || 3 > k.length || \"undefined\" === typeof c) return r.getTimeTicks.apply(r, arguments);\n        var J = k.length;\n\n        for (n = 0; n < J; n++) {\n          var w = n && k[n - 1] > b;\n          k[n] < c && (x = n);\n\n          if (n === J - 1 || k[n + 1] - k[n] > 5 * l || w) {\n            if (k[n] > u) {\n              for (p = r.getTimeTicks(a, k[x], k[n], d); p.length && p[0] <= u;) p.shift();\n\n              p.length && (u = p[p.length - 1]);\n              m.push(B.length);\n              B = B.concat(p);\n            }\n\n            x = n + 1;\n          }\n\n          if (w) break;\n        }\n\n        if (p) {\n          p = p.info;\n\n          if (h && p.unitRange <= f.hour) {\n            n = B.length - 1;\n\n            for (x = 1; x < n; x++) if (r.dateFormat(\"%d\", B[x]) !== r.dateFormat(\"%d\", B[x - 1])) {\n              e[B[x]] = \"day\";\n              var v = !0;\n            }\n\n            v && (e[B[0]] = \"day\");\n            p.higherRanks = e;\n          }\n\n          p.segmentStarts = m;\n          B.info = p;\n        } else q(12, !1, this.chart);\n\n        if (h && y(g)) {\n          p = B.length;\n          r = [];\n          x = [];\n          n = void 0;\n\n          for (v = p; v--;) m = this.translate(B[v]), n && (x[v] = n - m), r[v] = n = m;\n\n          x.sort();\n          x = x[Math.floor(x.length / 2)];\n          x < .6 * g && (x = null);\n          v = B[p - 1] > b ? p - 1 : p;\n\n          for (n = void 0; v--;) m = r[v], p = Math.abs(n - m), n && p < .8 * g && (null === x || p < .8 * x) ? (e[B[v]] && !e[B[v + 1]] ? (p = v + 1, n = m) : p = v, B.splice(p, 1)) : n = m;\n        }\n\n        return B;\n      }\n\n      function n(a) {\n        var e = this.ordinal.positions;\n        if (!e) return a;\n        var b = e.length - 1;\n        if (0 > a) a = e[0];else if (a > b) a = e[b];else {\n          b = Math.floor(a);\n          var c = a - b;\n        }\n        return \"undefined\" !== typeof c && \"undefined\" !== typeof e[b] ? e[b] + (c ? c * (e[b + 1] - e[b]) : 0) : a;\n      }\n\n      function C(a) {\n        var e = this.ordinal,\n            b = e.positions;\n        if (!b) return a;\n        var c = (a - (this.old ? this.old.min : this.min)) * (this.old ? this.old.transA : this.transA) + this.minPixelPadding;\n        0 < c && c < this.left + this.len || (e.extendedOrdinalPositions || (e.extendedOrdinalPositions = e.getExtendedPositions()), b = e.extendedOrdinalPositions);\n\n        if (b && b.length) {\n          a = e.getIndexOfPoint(c, b);\n          e = E(a % 1);\n          if (0 <= a && a < b.length - 1) return b[Math.floor(a)] + e * (b[Math.ceil(a)] - b[Math.floor(a)]);\n          e = b.length;\n          c = b[0];\n          b = b[e - 1];\n          var f = (b - c) / (e - 1);\n          return 0 > a ? c + f * a : b + f * (a - e);\n        }\n\n        return a;\n      }\n\n      function I(e, c) {\n        var b = a.Additions.findIndexOf(e, c, !0);\n        return e[b] === c ? b : b + (c - e[b]) / (e[b + 1] - e[b]);\n      }\n\n      function F() {\n        this.ordinal || (this.ordinal = new a.Additions(this));\n      }\n\n      function G() {\n        this.isXAxis && y(this.options.overscroll) && this.max === this.dataMax && (!this.chart.mouseIsDown || this.isInternal) && (!this.eventArgs || this.eventArgs && \"navigator\" !== this.eventArgs.trigger) && (this.max += this.options.overscroll, !this.isInternal && y(this.userMin) && (this.min += this.options.overscroll));\n      }\n\n      function v() {\n        this.horiz && !this.isDirty && (this.isDirty = this.isOrdinal && this.chart.navigator && !this.chart.navigator.adaptToUpdatedData);\n      }\n\n      function z() {\n        this.ordinal && (this.ordinal.beforeSetTickPositions(), this.tickInterval = this.ordinal.postProcessTickInterval(this.tickInterval));\n      }\n\n      function u(a) {\n        var e = this.xAxis[0],\n            b = e.options.overscroll,\n            c = a.originalEvent.chartX,\n            f = this.options.chart.panning,\n            d = !1;\n\n        if (f && \"y\" !== f.type && e.options.ordinal && e.series.length) {\n          var k = this.mouseDownX,\n              l = e.getExtremes(),\n              h = l.dataMax,\n              m = l.min,\n              n = l.max,\n              p = this.hoverPoints,\n              q = e.closestPointRange || e.ordinal && e.ordinal.overscrollPointsRange;\n          k = (k - c) / (e.translationSlope * (e.ordinal.slope || q));\n          q = {\n            ordinal: {\n              positions: e.ordinal.getExtendedPositions()\n            }\n          };\n          var u = e.index2val,\n              w = e.val2lin,\n              v = void 0,\n              t = v = void 0,\n              z = void 0;\n          q.ordinal.positions ? 1 < Math.abs(k) && (p && p.forEach(function (a) {\n            a.setState();\n          }), 0 > k ? (t = q, z = e.ordinal.positions ? e : q) : (t = e.ordinal.positions ? e : q, z = q), v = z.ordinal.positions, h > v[v.length - 1] && v.push(h), this.fixedRange = n - m, v = e.navigatorAxis.toFixedRange(void 0, void 0, u.apply(t, [w.apply(t, [m, !0]) + k]), u.apply(z, [w.apply(z, [n, !0]) + k])), v.min >= Math.min(l.dataMin, m) && v.max <= Math.max(h, n) + b && e.setExtremes(v.min, v.max, !0, !1, {\n            trigger: \"pan\"\n          }), this.mouseDownX = c, H(this.container, {\n            cursor: \"move\"\n          })) : d = !0;\n        } else d = !0;\n\n        d || f && /y/.test(f.type) ? b && (e.max = e.dataMax + b) : a.preventDefault();\n      }\n\n      function k() {\n        var a = this.xAxis;\n        a && a.options.ordinal && (delete a.ordinal.index, delete a.ordinal.extendedOrdinalPositions);\n      }\n\n      function w(a, c) {\n        var b = this.ordinal,\n            e = b.positions,\n            g = b.slope,\n            f = b.extendedOrdinalPositions;\n        if (!e) return a;\n        var d = e.length;\n        if (e[0] <= a && e[d - 1] >= a) a = I(e, a);else {\n          f || (f = b.getExtendedPositions && b.getExtendedPositions(), b.extendedOrdinalPositions = f);\n          if (!f || !f.length) return a;\n          d = f.length;\n          g || (g = (f[d - 1] - f[0]) / d);\n          e = I(f, e[0]);\n          a >= f[0] && a <= f[d - 1] ? a = I(f, a) - e : a < f[0] ? (a = f[0] - a, a = -e - a / g) : (a -= f[d - 1], a = a / g + d - e);\n        }\n        return c ? a : g * (a || 0) + b.offset;\n      }\n\n      a.compose = function (a, g, b) {\n        if (-1 === c.indexOf(a)) {\n          c.push(a);\n          var e = a.prototype;\n          e.getTimeTicks = d;\n          e.index2val = n;\n          e.lin2val = C;\n          e.val2lin = w;\n          e.ordinal2lin = e.val2lin;\n          t(a, \"afterInit\", F);\n          t(a, \"foundExtremes\", G);\n          t(a, \"afterSetScale\", v);\n          t(a, \"initialAxisTranslation\", z);\n        }\n\n        -1 === c.indexOf(b) && (c.push(b), t(b, \"pan\", u));\n        -1 === c.indexOf(g) && (c.push(g), t(g, \"updatedData\", k));\n        return a;\n      };\n\n      var l = function () {\n        function a(a) {\n          this.index = {};\n          this.axis = a;\n        }\n\n        a.prototype.beforeSetTickPositions = function () {\n          var a = this.axis,\n              b = a.ordinal,\n              e = a.getExtremes(),\n              c = e.min,\n              f = e.max,\n              d = a.isXAxis && !!a.options.breaks;\n          e = a.options.ordinal;\n          var k = a.chart.options.chart.ignoreHiddenSeries,\n              l,\n              h,\n              m = [],\n              n = Number.MAX_VALUE,\n              q = !1;\n\n          if (e || d) {\n            a.series.forEach(function (a, b) {\n              l = [];\n\n              if (!(k && !1 === a.visible || !1 === a.takeOrdinalPosition && !d) && (m = m.concat(a.processedXData), u = m.length, m.sort(function (a, b) {\n                return a - b;\n              }), n = Math.min(n, p(a.closestPointRange, n)), u)) {\n                for (b = 0; b < u - 1;) m[b] !== m[b + 1] && l.push(m[b + 1]), b++;\n\n                l[0] !== m[0] && l.unshift(m[0]);\n                m = l;\n              }\n            });\n            var u = m.length;\n\n            if (2 < u) {\n              var w = m[1] - m[0];\n\n              for (h = u - 1; h-- && !q;) m[h + 1] - m[h] !== w && (q = !0);\n\n              !a.options.keepOrdinalPadding && (m[0] - c > w || f - m[m.length - 1] > w) && (q = !0);\n            } else a.options.overscroll && (2 === u ? n = m[1] - m[0] : 1 === u ? (n = a.options.overscroll, m = [m[0], m[0] + n]) : n = b.overscrollPointsRange);\n\n            q || a.forceOrdinal ? (a.options.overscroll && (b.overscrollPointsRange = n, m = m.concat(b.getOverscrollPositions())), b.positions = m, w = a.ordinal2lin(Math.max(c, m[0]), !0), h = Math.max(a.ordinal2lin(Math.min(f, m[m.length - 1]), !0), 1), b.slope = f = (f - c) / (h - w), b.offset = c - w * f) : (b.overscrollPointsRange = p(a.closestPointRange, b.overscrollPointsRange), b.positions = a.ordinal.slope = b.offset = void 0);\n          }\n\n          a.isOrdinal = e && q;\n          b.groupIntervalFactor = null;\n        };\n\n        a.findIndexOf = function (a, b, e) {\n          for (var c = 0, g = a.length - 1, f; c < g;) f = Math.ceil((c + g) / 2), a[f] <= b ? c = f : g = f - 1;\n\n          return a[c] === b ? c : e ? c : -1;\n        };\n\n        a.prototype.getExtendedPositions = function () {\n          var a = this,\n              b = a.axis,\n              e = b.constructor.prototype,\n              c = b.chart,\n              f = b.series[0].currentDataGrouping,\n              d = f ? f.count + f.unitName : \"raw\",\n              k = b.options.overscroll,\n              l = b.getExtremes(),\n              m = void 0,\n              n = a.index;\n          n || (n = a.index = {});\n\n          if (!n[d]) {\n            var p = {\n              series: [],\n              chart: c,\n              forceOrdinal: !1,\n              getExtremes: function () {\n                return {\n                  min: l.dataMin,\n                  max: l.dataMax + k\n                };\n              },\n              getGroupPixelWidth: e.getGroupPixelWidth,\n              getTimeTicks: e.getTimeTicks,\n              options: {\n                ordinal: !0\n              },\n              ordinal: {\n                getGroupIntervalFactor: this.getGroupIntervalFactor\n              },\n              ordinal2lin: e.ordinal2lin,\n              getIndexOfPoint: e.getIndexOfPoint,\n              val2lin: e.val2lin\n            };\n            p.ordinal.axis = p;\n            b.series.forEach(function (b) {\n              m = {\n                xAxis: p,\n                xData: b.xData.slice(),\n                chart: c,\n                destroyGroupedData: h.noop,\n                getProcessedData: A.prototype.getProcessedData,\n                applyGrouping: A.prototype.applyGrouping\n              };\n              m.xData = m.xData.concat(a.getOverscrollPositions());\n              m.options = {\n                dataGrouping: f ? {\n                  firstAnchor: \"firstPoint\",\n                  anchor: \"middle\",\n                  lastAnchor: \"lastPoint\",\n                  enabled: !0,\n                  forced: !0,\n                  approximation: \"open\",\n                  units: [[f.unitName, [f.count]]]\n                } : {\n                  enabled: !1\n                }\n              };\n              p.series.push(m);\n              b.processData.apply(m);\n            });\n            m.closestPointRange !== m.basePointRange && m.currentDataGrouping && (p.forceOrdinal = !0);\n            b.ordinal.beforeSetTickPositions.apply({\n              axis: p\n            });\n            n[d] = p.ordinal.positions;\n          }\n\n          return n[d];\n        };\n\n        a.prototype.getGroupIntervalFactor = function (a, b, e) {\n          e = e.processedXData;\n          var c = e.length,\n              f = [];\n          var g = this.groupIntervalFactor;\n\n          if (!g) {\n            for (g = 0; g < c - 1; g++) f[g] = e[g + 1] - e[g];\n\n            f.sort(function (a, b) {\n              return a - b;\n            });\n            f = f[Math.floor(c / 2)];\n            a = Math.max(a, e[0]);\n            b = Math.min(b, e[c - 1]);\n            this.groupIntervalFactor = g = c * f / (b - a);\n          }\n\n          return g;\n        };\n\n        a.prototype.getIndexOfPoint = function (e, b) {\n          var c = this.axis,\n              f = this.positions ? this.positions[0] : 0,\n              g = c.series[0].points && c.series[0].points[0] && c.series[0].points[0].plotX || c.minPixelPadding;\n          1 < c.series.length && c.series.forEach(function (a) {\n            a.points && y(a.points[0]) && y(a.points[0].plotX) && a.points[0].plotX < g && (g = a.points[0].plotX);\n          });\n          e = (e - g) / (c.translationSlope * (this.slope || c.closestPointRange || this.overscrollPointsRange));\n          return a.findIndexOf(b, f) + e;\n        };\n\n        a.prototype.getOverscrollPositions = function () {\n          var a = this.axis,\n              b = a.options.overscroll,\n              e = this.overscrollPointsRange,\n              c = [],\n              f = a.dataMax;\n          if (y(e)) for (; f <= a.dataMax + b;) f += e, c.push(f);\n          return c;\n        };\n\n        a.prototype.postProcessTickInterval = function (a) {\n          var b = this.axis,\n              e = this.slope;\n          return e ? b.options.breaks ? b.closestPointRange || a : a / (e / b.closestPointRange) : a;\n        };\n\n        return a;\n      }();\n\n      a.Additions = l;\n    })(a || (a = {}));\n\n    return a;\n  });\n  N(h, \"Series/DataModifyComposition.js\", [h[\"Core/Axis/Axis.js\"], h[\"Core/Series/Point.js\"], h[\"Core/Series/Series.js\"], h[\"Core/Utilities.js\"]], function (d, h, A, F) {\n    var t = h.prototype.tooltipFormatter,\n        E = F.addEvent,\n        H = F.arrayMax,\n        y = F.arrayMin,\n        q = F.correctFloat,\n        p = F.defined,\n        f = F.isArray,\n        c = F.isNumber,\n        a = F.isString,\n        n = F.pick,\n        m;\n\n    (function (d) {\n      function h(e, b, c) {\n        this.isXAxis || (this.series.forEach(function (c) {\n          \"compare\" === e && \"boolean\" !== typeof b ? c.setCompare(b, !1) : \"cumulative\" !== e || a(b) || c.setCumulative(b, !1);\n        }), n(c, !0) && this.chart.redraw());\n      }\n\n      function m(a) {\n        var b = this,\n            e = b.series.chart.numberFormatter,\n            c = function (c) {\n          a = a.replace(\"{point.\" + c + \"}\", (0 < b[c] && \"change\" === c ? \"+\" : \"\") + e(b[c], n(b.series.tooltipOptions.changeDecimals, 2)));\n        };\n\n        p(b.change) && c(\"change\");\n        p(b.cumulativeSum) && c(\"cumulativeSum\");\n        return t.apply(this, [a]);\n      }\n\n      function D() {\n        var a = this.options.compare;\n\n        if (\"percent\" === a || \"value\" === a || this.options.cumulative) {\n          var b = new e(this);\n          \"percent\" === a || \"value\" === a ? b.initCompare(a) : b.initCumulative();\n        }\n\n        this.dataModify = b;\n      }\n\n      function A(a) {\n        a = a.dataExtremes;\n        var b = a.activeYData;\n\n        if (this.dataModify && a) {\n          var c = void 0;\n          this.options.compare ? c = [this.dataModify.modifyValue(a.dataMin), this.dataModify.modifyValue(a.dataMax)] : this.options.cumulative && f(b) && 2 <= b.length && (c = e.getCumulativeExtremes(b));\n          c && (a.dataMin = y(c), a.dataMax = H(c));\n        }\n      }\n\n      function v(a, b) {\n        this.options.compare = this.userOptions.compare = a;\n        this.update({}, n(b, !0));\n        !this.dataModify || \"value\" !== a && \"percent\" !== a ? this.points.forEach(function (a) {\n          delete a.change;\n        }) : this.dataModify.initCompare(a);\n      }\n\n      function z() {\n        if (this.xAxis && this.processedYData && this.dataModify) {\n          var a = this.processedXData,\n              b = this.processedYData,\n              e = b.length,\n              f = !0 === this.options.compareStart ? 0 : 1,\n              d = -1,\n              k;\n          this.pointArrayMap && (d = this.pointArrayMap.indexOf(this.options.pointValKey || this.pointValKey || \"y\"));\n\n          for (k = 0; k < e - f; k++) {\n            var l = b[k] && -1 < d ? b[k][d] : b[k];\n\n            if (c(l) && 0 !== l && a[k + f] >= (this.xAxis.min || 0)) {\n              this.dataModify.compareValue = l;\n              break;\n            }\n          }\n        }\n      }\n\n      function u(a, b) {\n        this.setModifier(\"compare\", a, b);\n      }\n\n      function k(a, b) {\n        a = n(a, !1);\n        this.options.cumulative = this.userOptions.cumulative = a;\n        this.update({}, n(b, !0));\n        this.dataModify ? this.dataModify.initCumulative() : this.points.forEach(function (a) {\n          delete a.cumulativeSum;\n        });\n      }\n\n      function w(a, b) {\n        this.setModifier(\"cumulative\", a, b);\n      }\n\n      var l = [];\n\n      d.compose = function (a, b, e) {\n        if (-1 === l.indexOf(a)) {\n          l.push(a);\n          var c = a.prototype;\n          c.setCompare = v;\n          c.setCumulative = k;\n          E(a, \"afterInit\", D);\n          E(a, \"afterGetExtremes\", A);\n          E(a, \"afterProcessData\", z);\n        }\n\n        -1 === l.indexOf(b) && (l.push(b), b = b.prototype, b.setCompare = u, b.setModifier = h, b.setCumulative = w);\n        -1 === l.indexOf(e) && (l.push(e), e.prototype.tooltipFormatter = m);\n        return a;\n      };\n\n      var e = function () {\n        function a(a) {\n          this.series = a;\n        }\n\n        a.prototype.modifyValue = function () {\n          return 0;\n        };\n\n        a.getCumulativeExtremes = function (a) {\n          var b = Infinity,\n              e = -Infinity;\n          a.reduce(function (a, c) {\n            c = a + c;\n            b = Math.min(b, c, a);\n            e = Math.max(e, c, a);\n            return c;\n          });\n          return [b, e];\n        };\n\n        a.prototype.initCompare = function (a) {\n          this.modifyValue = function (b, e) {\n            null === b && (b = 0);\n            var c = this.compareValue;\n            return \"undefined\" !== typeof b && \"undefined\" !== typeof c ? (b = \"value\" === a ? b - c : b / c * 100 - (100 === this.series.options.compareBase ? 0 : 100), \"undefined\" !== typeof e && (e = this.series.points[e]) && (e.change = b), b) : 0;\n          };\n        };\n\n        a.prototype.initCumulative = function () {\n          this.modifyValue = function (a, e) {\n            null === a && (a = 0);\n\n            if (void 0 !== a && void 0 !== e) {\n              var b = 0 < e ? this.series.points[e - 1] : null;\n              b && b.cumulativeSum && (a = q(b.cumulativeSum + a));\n              if (e = this.series.points[e]) e.cumulativeSum = a;\n              return a;\n            }\n\n            return 0;\n          };\n        };\n\n        return a;\n      }();\n\n      d.Additions = e;\n    })(m || (m = {}));\n\n    \"\";\n    return m;\n  });\n  N(h, \"Core/Axis/BrokenAxis.js\", [h[\"Extensions/Stacking.js\"], h[\"Core/Utilities.js\"]], function (d, h) {\n    var A = h.addEvent,\n        E = h.find,\n        t = h.fireEvent,\n        G = h.isArray,\n        H = h.isNumber,\n        y = h.pick,\n        q;\n\n    (function (h) {\n      function f() {\n        \"undefined\" !== typeof this.brokenAxis && this.brokenAxis.setBreaks(this.options.breaks, !1);\n      }\n\n      function c() {\n        this.brokenAxis && this.brokenAxis.hasBreaks && (this.options.ordinal = !1);\n      }\n\n      function a() {\n        var a = this.brokenAxis;\n\n        if (a && a.hasBreaks) {\n          for (var c = this.tickPositions, f = this.tickPositions.info, d = [], h = 0; h < c.length; h++) a.isInAnyBreak(c[h]) || d.push(c[h]);\n\n          this.tickPositions = d;\n          this.tickPositions.info = f;\n        }\n      }\n\n      function n() {\n        this.brokenAxis || (this.brokenAxis = new K(this));\n      }\n\n      function m() {\n        var a = this.options.connectNulls,\n            c = this.points,\n            f = this.xAxis,\n            d = this.yAxis;\n        if (this.isDirty) for (var h = c.length; h--;) {\n          var l = c[h],\n              e = !(null === l.y && !1 === a) && (f && f.brokenAxis && f.brokenAxis.isInAnyBreak(l.x, !0) || d && d.brokenAxis && d.brokenAxis.isInAnyBreak(l.y, !0));\n          l.visible = e ? !1 : !1 !== l.options.visible;\n        }\n      }\n\n      function p() {\n        this.drawBreaks(this.xAxis, [\"x\"]);\n        this.drawBreaks(this.yAxis, y(this.pointArrayMap, [\"y\"]));\n      }\n\n      function q(a, c) {\n        var f = this,\n            d = f.points,\n            h,\n            l,\n            e,\n            g;\n\n        if (a && a.brokenAxis && a.brokenAxis.hasBreaks) {\n          var b = a.brokenAxis;\n          c.forEach(function (c) {\n            h = b && b.breakArray || [];\n            l = a.isXAxis ? a.min : y(f.options.threshold, a.min);\n            d.forEach(function (b) {\n              g = y(b[\"stack\" + c.toUpperCase()], b[c]);\n              h.forEach(function (c) {\n                if (H(l) && H(g)) {\n                  e = !1;\n                  if (l < c.from && g > c.to || l > c.from && g < c.from) e = \"pointBreak\";else if (l < c.from && g > c.from && g < c.to || l > c.from && g > c.to && g < c.from) e = \"pointInBreak\";\n                  e && t(a, e, {\n                    point: b,\n                    brk: c\n                  });\n                }\n              });\n            });\n          });\n        }\n      }\n\n      function I() {\n        var a = this.currentDataGrouping,\n            c = a && a.gapSize;\n        a = this.points.slice();\n        var f = this.yAxis,\n            k = this.options.gapSize,\n            h = a.length - 1,\n            l;\n        if (k && 0 < h) for (\"value\" !== this.options.gapUnit && (k *= this.basePointRange), c && c > k && c >= this.basePointRange && (k = c), l = void 0; h--;) l && !1 !== l.visible || (l = a[h + 1]), c = a[h], !1 !== l.visible && !1 !== c.visible && (l.x - c.x > k && (l = (c.x + l.x) / 2, a.splice(h + 1, 0, {\n          isNull: !0,\n          x: l\n        }), f.stacking && this.options.stacking && (l = f.stacking.stacks[this.stackKey][l] = new d(f, f.options.stackLabels, !1, l, this.stack), l.total = 0)), l = c);\n        return this.getGraphPath(a);\n      }\n\n      var F = [];\n\n      h.compose = function (d, h) {\n        -1 === F.indexOf(d) && (F.push(d), d.keepProps.push(\"brokenAxis\"), A(d, \"init\", n), A(d, \"afterInit\", f), A(d, \"afterSetTickPositions\", a), A(d, \"afterSetOptions\", c));\n\n        if (-1 === F.indexOf(h)) {\n          F.push(h);\n          var u = h.prototype;\n          u.drawBreaks = q;\n          u.gappedPath = I;\n          A(h, \"afterGeneratePoints\", m);\n          A(h, \"afterRender\", p);\n        }\n\n        return d;\n      };\n\n      var K = function () {\n        function a(a) {\n          this.hasBreaks = !1;\n          this.axis = a;\n        }\n\n        a.isInBreak = function (a, c) {\n          var f = a.repeat || Infinity,\n              d = a.from,\n              l = a.to - a.from;\n          c = c >= d ? (c - d) % f : f - (d - c) % f;\n          return a.inclusive ? c <= l : c < l && 0 !== c;\n        };\n\n        a.lin2Val = function (c) {\n          var f = this.brokenAxis;\n          f = f && f.breakArray;\n          if (!f || !H(c)) return c;\n          var d;\n\n          for (d = 0; d < f.length; d++) {\n            var h = f[d];\n            if (h.from >= c) break;else h.to < c ? c += h.len : a.isInBreak(h, c) && (c += h.len);\n          }\n\n          return c;\n        };\n\n        a.val2Lin = function (c) {\n          var f = this.brokenAxis;\n          f = f && f.breakArray;\n          if (!f || !H(c)) return c;\n          var d = c,\n              h;\n\n          for (h = 0; h < f.length; h++) {\n            var l = f[h];\n            if (l.to <= c) d -= l.len;else if (l.from >= c) break;else if (a.isInBreak(l, c)) {\n              d -= c - l.from;\n              break;\n            }\n          }\n\n          return d;\n        };\n\n        a.prototype.findBreakAt = function (a, c) {\n          return E(c, function (c) {\n            return c.from < a && a < c.to;\n          });\n        };\n\n        a.prototype.isInAnyBreak = function (c, f) {\n          var d = this.axis,\n              h = d.options.breaks || [],\n              l = h.length,\n              e;\n\n          if (l && H(c)) {\n            for (; l--;) if (a.isInBreak(h[l], c)) {\n              var g = !0;\n              e || (e = y(h[l].showPoints, !d.isXAxis));\n            }\n\n            var b = g && f ? g && !e : g;\n          }\n\n          return b;\n        };\n\n        a.prototype.setBreaks = function (c, f) {\n          var d = this,\n              h = d.axis,\n              l = G(c) && !!c.length;\n          h.isDirty = d.hasBreaks !== l;\n          d.hasBreaks = l;\n          h.options.breaks = h.userOptions.breaks = c;\n          h.forceRedraw = !0;\n          h.series.forEach(function (a) {\n            a.isDirty = !0;\n          });\n          l || h.val2lin !== a.val2Lin || (delete h.val2lin, delete h.lin2val);\n          l && (h.userOptions.ordinal = !1, h.lin2val = a.lin2Val, h.val2lin = a.val2Lin, h.setExtremes = function (a, c, b, f, k) {\n            if (d.hasBreaks) {\n              for (var e = this.options.breaks || [], g; g = d.findBreakAt(a, e);) a = g.to;\n\n              for (; g = d.findBreakAt(c, e);) c = g.from;\n\n              c < a && (c = a);\n            }\n\n            h.constructor.prototype.setExtremes.call(this, a, c, b, f, k);\n          }, h.setAxisTranslation = function () {\n            h.constructor.prototype.setAxisTranslation.call(this);\n            d.unitLength = void 0;\n\n            if (d.hasBreaks) {\n              var c = h.options.breaks || [],\n                  f = [],\n                  b = [],\n                  k = y(h.pointRangePadding, 0),\n                  l = 0,\n                  r,\n                  m = h.userMin || h.min,\n                  n = h.userMax || h.max,\n                  p;\n              c.forEach(function (b) {\n                r = b.repeat || Infinity;\n                H(m) && H(n) && (a.isInBreak(b, m) && (m += b.to % r - m % r), a.isInBreak(b, n) && (n -= n % r - b.from % r));\n              });\n              c.forEach(function (a) {\n                u = a.from;\n                r = a.repeat || Infinity;\n\n                if (H(m) && H(n)) {\n                  for (; u - r > m;) u -= r;\n\n                  for (; u < m;) u += r;\n\n                  for (p = u; p < n; p += r) f.push({\n                    value: p,\n                    move: \"in\"\n                  }), f.push({\n                    value: p + a.to - a.from,\n                    move: \"out\",\n                    size: a.breakSize\n                  });\n                }\n              });\n              f.sort(function (a, b) {\n                return a.value === b.value ? (\"in\" === a.move ? 0 : 1) - (\"in\" === b.move ? 0 : 1) : a.value - b.value;\n              });\n              var q = 0;\n              var u = m;\n              f.forEach(function (a) {\n                q += \"in\" === a.move ? 1 : -1;\n                1 === q && \"in\" === a.move && (u = a.value);\n                0 === q && H(u) && (b.push({\n                  from: u,\n                  to: a.value,\n                  len: a.value - u - (a.size || 0)\n                }), l += a.value - u - (a.size || 0));\n              });\n              d.breakArray = b;\n              H(m) && H(n) && H(h.min) && (d.unitLength = n - m - l + k, t(h, \"afterBreaks\"), h.staticScale ? h.transA = h.staticScale : d.unitLength && (h.transA *= (n - h.min + k) / d.unitLength), k && (h.minPixelPadding = h.transA * (h.minPointOffset || 0)), h.min = m, h.max = n);\n            }\n          });\n          y(f, !0) && h.chart.redraw();\n        };\n\n        return a;\n      }();\n\n      h.Additions = K;\n    })(q || (q = {}));\n\n    return q;\n  });\n  N(h, \"masters/modules/broken-axis.src.js\", [h[\"Core/Globals.js\"], h[\"Core/Axis/BrokenAxis.js\"]], function (d, h) {\n    h.compose(d.Axis, d.Series);\n  });\n  N(h, \"Extensions/DataGrouping.js\", [h[\"Core/Axis/Axis.js\"], h[\"Core/Axis/DateTimeAxis.js\"], h[\"Core/FormatUtilities.js\"], h[\"Core/Globals.js\"], h[\"Core/Series/Point.js\"], h[\"Core/Series/Series.js\"], h[\"Core/Tooltip.js\"], h[\"Core/DefaultOptions.js\"], h[\"Core/Utilities.js\"]], function (d, h, A, F, t, G, H, y, q) {\n    var p = A.format,\n        f = G.prototype;\n    A = q.addEvent;\n    var c = q.arrayMax,\n        a = q.arrayMin,\n        n = q.correctFloat,\n        m = q.defined,\n        D = q.error,\n        C = q.extend,\n        I = q.isNumber,\n        E = q.merge,\n        K = q.pick;\n    \"\";\n    var v = F.approximations = {\n      sum: function (a) {\n        var c = a.length;\n        if (!c && a.hasNulls) var b = null;else if (c) for (b = 0; c--;) b += a[c];\n        return b;\n      },\n      average: function (a) {\n        var c = a.length;\n        a = v.sum(a);\n        I(a) && c && (a = n(a / c));\n        return a;\n      },\n      averages: function () {\n        var a = [];\n        [].forEach.call(arguments, function (c) {\n          a.push(v.average(c));\n        });\n        return \"undefined\" === typeof a[0] ? void 0 : a;\n      },\n      open: function (a) {\n        return a.length ? a[0] : a.hasNulls ? null : void 0;\n      },\n      high: function (a) {\n        return a.length ? c(a) : a.hasNulls ? null : void 0;\n      },\n      low: function (c) {\n        return c.length ? a(c) : c.hasNulls ? null : void 0;\n      },\n      close: function (a) {\n        return a.length ? a[a.length - 1] : a.hasNulls ? null : void 0;\n      },\n      hlc: function (a, c, b) {\n        a = v.high(a);\n        c = v.low(c);\n        b = v.close(b);\n        if (I(a) || I(c) || I(b)) return [a, c, b];\n      },\n      ohlc: function (a, c, b, f) {\n        a = v.open(a);\n        c = v.high(c);\n        b = v.low(b);\n        f = v.close(f);\n        if (I(a) || I(c) || I(b) || I(f)) return [a, c, b, f];\n      },\n      range: function (a, c) {\n        a = v.low(a);\n        c = v.high(c);\n        if (I(a) || I(c)) return [a, c];\n        if (null === a && null === c) return null;\n      }\n    };\n\n    q = function (a, c, b, f) {\n      var e = this,\n          d = e.data,\n          g = e.options && e.options.data,\n          k = [],\n          l = [],\n          h = [],\n          n = a.length,\n          p = !!c,\n          q = [],\n          u = e.pointArrayMap,\n          B = u && u.length,\n          w = [\"x\"].concat(u || [\"y\"]),\n          t = this.options.dataGrouping && this.options.dataGrouping.groupAll,\n          z = 0,\n          y = 0,\n          D;\n      f = \"function\" === typeof f ? f : v[f] ? v[f] : v[e.getDGApproximation && e.getDGApproximation() || \"average\"];\n      B ? u.forEach(function () {\n        q.push([]);\n      }) : q.push([]);\n      var C = B || 1;\n\n      for (D = 0; D <= n && !(a[D] >= b[0]); D++);\n\n      for (D; D <= n; D++) {\n        for (; \"undefined\" !== typeof b[z + 1] && a[D] >= b[z + 1] || D === n;) {\n          var A = b[z];\n          e.dataGroupInfo = {\n            start: t ? y : e.cropStart + y,\n            length: q[0].length\n          };\n          var F = f.apply(e, q);\n          e.pointClass && !m(e.dataGroupInfo.options) && (e.dataGroupInfo.options = E(e.pointClass.prototype.optionsToObject.call({\n            series: e\n          }, e.options.data[e.cropStart + y])), w.forEach(function (a) {\n            delete e.dataGroupInfo.options[a];\n          }));\n          \"undefined\" !== typeof F && (k.push(A), l.push(F), h.push(e.dataGroupInfo));\n          y = D;\n\n          for (A = 0; A < C; A++) q[A].length = 0, q[A].hasNulls = !1;\n\n          z += 1;\n          if (D === n) break;\n        }\n\n        if (D === n) break;\n\n        if (u) {\n          A = e.options.dataGrouping && e.options.dataGrouping.groupAll ? D : e.cropStart + D;\n          F = d && d[A] || e.pointClass.prototype.applyOptions.apply({\n            series: e\n          }, [g[A]]);\n          var G = void 0;\n\n          for (A = 0; A < B; A++) G = F[u[A]], I(G) ? q[A].push(G) : null === G && (q[A].hasNulls = !0);\n        } else A = p ? c[D] : null, I(A) ? q[0].push(A) : null === A && (q[0].hasNulls = !0);\n      }\n\n      return {\n        groupedXData: k,\n        groupedYData: l,\n        groupMap: h\n      };\n    };\n\n    var z = {\n      approximations: v,\n      groupData: q\n    },\n        u = f.generatePoints,\n        k = {\n      groupPixelWidth: 2,\n      dateTimeLabelFormats: {\n        millisecond: [\"%A, %b %e, %H:%M:%S.%L\", \"%A, %b %e, %H:%M:%S.%L\", \"-%H:%M:%S.%L\"],\n        second: [\"%A, %b %e, %H:%M:%S\", \"%A, %b %e, %H:%M:%S\", \"-%H:%M:%S\"],\n        minute: [\"%A, %b %e, %H:%M\", \"%A, %b %e, %H:%M\", \"-%H:%M\"],\n        hour: [\"%A, %b %e, %H:%M\", \"%A, %b %e, %H:%M\", \"-%H:%M\"],\n        day: [\"%A, %b %e, %Y\", \"%A, %b %e\", \"-%A, %b %e, %Y\"],\n        week: [\"Week from %A, %b %e, %Y\", \"%A, %b %e\", \"-%A, %b %e, %Y\"],\n        month: [\"%B %Y\", \"%B\", \"-%B %Y\"],\n        year: [\"%Y\", \"%Y\", \"-%Y\"]\n      }\n    },\n        w = {\n      line: {},\n      spline: {},\n      area: {},\n      areaspline: {},\n      arearange: {},\n      column: {\n        groupPixelWidth: 10\n      },\n      columnrange: {\n        groupPixelWidth: 10\n      },\n      candlestick: {\n        groupPixelWidth: 10\n      },\n      ohlc: {\n        groupPixelWidth: 5\n      },\n      hlc: {\n        groupPixelWidth: 5\n      },\n      heikinashi: {\n        groupPixelWidth: 10\n      }\n    },\n        l = F.defaultDataGroupingUnits = [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1]], [\"week\", [1]], [\"month\", [1, 3, 6]], [\"year\", null]];\n\n    f.getDGApproximation = function () {\n      return this.is(\"arearange\") ? \"range\" : this.is(\"ohlc\") ? \"ohlc\" : this.is(\"hlc\") ? \"hlc\" : this.is(\"column\") ? \"sum\" : \"average\";\n    };\n\n    f.groupData = q;\n\n    f.applyGrouping = function (a) {\n      var c = this.chart,\n          b = this.options.dataGrouping,\n          e = !1 !== this.allowDG && b && K(b.enabled, c.options.isStock),\n          d = this.visible || !c.options.chart.ignoreHiddenSeries,\n          k,\n          n = this.currentDataGrouping,\n          p = !1;\n      e && !this.requireSorting && (this.requireSorting = p = !0);\n      a = !1 === !(this.isCartesian && !this.isDirty && !this.xAxis.isDirty && !this.yAxis.isDirty && !a) || !e;\n      p && (this.requireSorting = !1);\n\n      if (!a) {\n        this.destroyGroupedData();\n        e = b.groupAll ? this.xData : this.processedXData;\n        var q = b.groupAll ? this.yData : this.processedYData;\n        a = c.plotSizeX;\n        p = this.xAxis;\n        var u = p.options.ordinal,\n            w = this.groupPixelWidth;\n\n        if (w && e && e.length) {\n          this.isDirty = k = !0;\n          this.points = null;\n          var v = p.getExtremes();\n          var t = v.min;\n          v = v.max;\n          u = u && p.ordinal && p.ordinal.getGroupIntervalFactor(t, v, this) || 1;\n          a = p.getTimeTicks(h.Additions.prototype.normalizeTimeTickInterval(w * (v - t) / a * u, b.units || l), Math.min(t, e[0]), Math.max(v, e[e.length - 1]), p.options.startOfWeek, e, this.closestPointRange);\n          w = f.groupData.apply(this, [e, q, a, b.approximation]);\n          e = w.groupedXData;\n          q = w.groupedYData;\n          u = 0;\n          b && b.smoothed && e.length && (b.firstAnchor = \"firstPoint\", b.anchor = \"middle\", b.lastAnchor = \"lastPoint\", D(32, !1, c, {\n            \"dataGrouping.smoothed\": \"use dataGrouping.anchor\"\n          }));\n          c = e;\n          var z = this.options.dataGrouping;\n          t = this.currentDataGrouping && this.currentDataGrouping.gapSize;\n\n          if (z && this.xData && t && this.groupMap) {\n            var y = c.length - 1;\n            var C = z.anchor;\n            var A = K(z.firstAnchor, C);\n            z = K(z.lastAnchor, C);\n\n            if (C && \"start\" !== C) {\n              var F = t * {\n                middle: .5,\n                end: 1\n              }[C];\n\n              for (C = c.length - 1; C-- && 0 < C;) c[C] += F;\n            }\n\n            if (A && \"start\" !== A && this.xData[0] >= c[0]) {\n              C = this.groupMap[0].start;\n              F = this.groupMap[0].length;\n              var E = void 0;\n              I(C) && I(F) && (E = C + (F - 1));\n              c[0] = {\n                middle: c[0] + .5 * t,\n                end: c[0] + t,\n                firstPoint: this.xData[0],\n                lastPoint: E && this.xData[E]\n              }[A];\n            }\n\n            z && \"start\" !== z && t && c[y] >= v - t && (v = this.groupMap[this.groupMap.length - 1].start, c[y] = {\n              middle: c[y] + .5 * t,\n              end: c[y] + t,\n              firstPoint: v && this.xData[v],\n              lastPoint: this.xData[this.xData.length - 1]\n            }[z]);\n          }\n\n          for (v = 1; v < a.length; v++) a.info.segmentStarts && -1 !== a.info.segmentStarts.indexOf(v) || (u = Math.max(a[v] - a[v - 1], u));\n\n          v = a.info;\n          v.gapSize = u;\n          this.closestPointRange = a.info.totalRange;\n          this.groupMap = w.groupMap;\n\n          if (d) {\n            d = e;\n\n            if (m(d[0]) && I(p.min) && I(p.dataMin) && d[0] < p.min) {\n              if (!m(p.options.min) && p.min <= p.dataMin || p.min === p.dataMin) p.min = Math.min(d[0], p.min);\n              p.dataMin = Math.min(d[0], p.dataMin);\n            }\n\n            if (m(d[d.length - 1]) && I(p.max) && I(p.dataMax) && d[d.length - 1] > p.max) {\n              if (!m(p.options.max) && I(p.dataMax) && p.max >= p.dataMax || p.max === p.dataMax) p.max = Math.max(d[d.length - 1], p.max);\n              p.dataMax = Math.max(d[d.length - 1], p.dataMax);\n            }\n          }\n\n          b.groupAll && (this.allGroupedData = q, b = this.cropData(e, q, p.min, p.max, 1), e = b.xData, q = b.yData, this.cropStart = b.start);\n          this.processedXData = e;\n          this.processedYData = q;\n        } else this.groupMap = null;\n\n        this.hasGroupedData = k;\n        this.currentDataGrouping = v;\n        this.preventGraphAnimation = (n && n.totalRange) !== (v && v.totalRange);\n      }\n    };\n\n    f.destroyGroupedData = function () {\n      this.groupedData && (this.groupedData.forEach(function (a, c) {\n        a && (this.groupedData[c] = a.destroy ? a.destroy() : null);\n      }, this), this.groupedData.length = 0);\n    };\n\n    f.generatePoints = function () {\n      u.apply(this);\n      this.destroyGroupedData();\n      this.groupedData = this.hasGroupedData ? this.points : null;\n    };\n\n    d.prototype.applyGrouping = function (a) {\n      var c = this;\n      c.series.forEach(function (b) {\n        b.groupPixelWidth = void 0;\n        b.groupPixelWidth = c.getGroupPixelWidth && c.getGroupPixelWidth();\n        b.groupPixelWidth && (b.hasProcessed = !0);\n        b.applyGrouping(!!a.hasExtemesChanged);\n      });\n    };\n\n    d.prototype.getGroupPixelWidth = function () {\n      var a = this.series,\n          c = a.length,\n          b,\n          f = 0,\n          d = !1,\n          l;\n\n      for (b = c; b--;) (l = a[b].options.dataGrouping) && (f = Math.max(f, K(l.groupPixelWidth, k.groupPixelWidth)));\n\n      for (b = c; b--;) if (l = a[b].options.dataGrouping) if (c = (a[b].processedXData || a[b].data).length, a[b].groupPixelWidth || c > this.chart.plotSizeX / f || c && l.forced) d = !0;\n\n      return d ? f : 0;\n    };\n\n    d.prototype.setDataGrouping = function (a, c) {\n      var b;\n      c = K(c, !0);\n      a || (a = {\n        forced: !1,\n        units: null\n      });\n      if (this instanceof d) for (b = this.series.length; b--;) this.series[b].update({\n        dataGrouping: a\n      }, !1);else this.chart.options.series.forEach(function (b) {\n        b.dataGrouping = a;\n      }, !1);\n      this.ordinal && (this.ordinal.slope = void 0);\n      c && this.chart.redraw();\n    };\n\n    A(d, \"postProcessData\", d.prototype.applyGrouping);\n    A(t, \"update\", function () {\n      if (this.dataGroup) return D(24, !1, this.series.chart), !1;\n    });\n    A(H, \"headerFormatter\", function (a) {\n      var c = this.chart,\n          b = c.time,\n          e = a.labelConfig,\n          f = e.series,\n          d = f.tooltipOptions,\n          l = f.options.dataGrouping,\n          h = d.xDateFormat,\n          m = f.xAxis,\n          n = d[a.isFooter ? \"footerFormat\" : \"headerFormat\"];\n\n      if (m && \"datetime\" === m.options.type && l && I(e.key)) {\n        var q = f.currentDataGrouping;\n        l = l.dateTimeLabelFormats || k.dateTimeLabelFormats;\n        if (q) {\n          if (d = l[q.unitName], 1 === q.count) h = d[0];else {\n            h = d[1];\n            var u = d[2];\n          }\n        } else !h && l && m.dateTime && (h = m.dateTime.getXDateFormat(e.x, d.dateTimeLabelFormats));\n        h = b.dateFormat(h, e.key);\n        u && (h += b.dateFormat(u, e.key + q.totalRange - 1));\n        f.chart.styledMode && (n = this.styledModeFormat(n));\n        a.text = p(n, {\n          point: C(e.point, {\n            key: h\n          }),\n          series: f\n        }, c);\n        a.preventDefault();\n      }\n    });\n    A(G, \"destroy\", f.destroyGroupedData);\n    A(G, \"afterSetOptions\", function (a) {\n      a = a.options;\n      var c = this.type,\n          b = this.chart.options.plotOptions,\n          e = y.defaultOptions.plotOptions[c].dataGrouping,\n          f = this.useCommonDataGrouping && k;\n\n      if (b && (w[c] || f)) {\n        e || (e = E(k, w[c]));\n        var d = this.chart.rangeSelector;\n        a.dataGrouping = E(f, e, b.series && b.series.dataGrouping, b[c].dataGrouping, this.userOptions.dataGrouping, !a.isInternal && d && I(d.selected) && d.buttonOptions[d.selected].dataGrouping);\n      }\n    });\n    A(d, \"afterSetScale\", function () {\n      this.series.forEach(function (a) {\n        a.hasProcessed = !1;\n      });\n    });\n    F.dataGrouping = z;\n    \"\";\n    return z;\n  });\n  N(h, \"Series/HLC/HLCPoint.js\", [h[\"Core/Series/SeriesRegistry.js\"]], function (d) {\n    var h = this && this.__extends || function () {\n      var d = function (h, t) {\n        d = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, h) {\n          d.__proto__ = h;\n        } || function (d, h) {\n          for (var t in h) h.hasOwnProperty(t) && (d[t] = h[t]);\n        };\n\n        return d(h, t);\n      };\n\n      return function (h, t) {\n        function A() {\n          this.constructor = h;\n        }\n\n        d(h, t);\n        h.prototype = null === t ? Object.create(t) : (A.prototype = t.prototype, new A());\n      };\n    }();\n\n    return function (d) {\n      function A() {\n        var h = null !== d && d.apply(this, arguments) || this;\n        h.close = void 0;\n        h.high = void 0;\n        h.low = void 0;\n        h.options = void 0;\n        h.plotClose = void 0;\n        h.series = void 0;\n        return h;\n      }\n\n      h(A, d);\n      return A;\n    }(d.seriesTypes.column.prototype.pointClass);\n  });\n  N(h, \"Series/HLC/HLCSeries.js\", [h[\"Series/HLC/HLCPoint.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"]], function (d, h, A) {\n    var F = this && this.__extends || function () {\n      var d = function (h, p) {\n        d = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (f, c) {\n          f.__proto__ = c;\n        } || function (f, c) {\n          for (var a in c) c.hasOwnProperty(a) && (f[a] = c[a]);\n        };\n\n        return d(h, p);\n      };\n\n      return function (h, p) {\n        function f() {\n          this.constructor = h;\n        }\n\n        d(h, p);\n        h.prototype = null === p ? Object.create(p) : (f.prototype = p.prototype, new f());\n      };\n    }(),\n        t = h.seriesTypes.column,\n        E = A.extend,\n        H = A.merge;\n\n    A = function (d) {\n      function h() {\n        var h = null !== d && d.apply(this, arguments) || this;\n        h.data = void 0;\n        h.options = void 0;\n        h.points = void 0;\n        h.yData = void 0;\n        return h;\n      }\n\n      F(h, d);\n\n      h.prototype.extendStem = function (d, f, c) {\n        var a = d[0];\n        d = d[1];\n        \"number\" === typeof a[2] && (a[2] = Math.max(c + f, a[2]));\n        \"number\" === typeof d[2] && (d[2] = Math.min(c - f, d[2]));\n      };\n\n      h.prototype.getPointPath = function (d, f) {\n        f = f.strokeWidth();\n        var c = d.series,\n            a = f % 2 / 2,\n            h = Math.round(d.plotX) - a,\n            m = Math.round(d.shapeArgs.width / 2);\n        var p = [[\"M\", h, Math.round(d.yBottom)], [\"L\", h, Math.round(d.plotHigh)]];\n        null !== d.close && (d = Math.round(d.plotClose) + a, p.push([\"M\", h, d], [\"L\", h + m, d]), c.extendStem(p, f / 2, d));\n        return p;\n      };\n\n      h.prototype.drawSinglePoint = function (d) {\n        var f = d.series,\n            c = f.chart,\n            a = d.graphic,\n            h = !a;\n        \"undefined\" !== typeof d.plotY && (a || (d.graphic = a = c.renderer.path().add(f.group)), c.styledMode || a.attr(f.pointAttribs(d, d.selected && \"select\")), f = f.getPointPath(d, a), a[h ? \"attr\" : \"animate\"]({\n          d: f\n        }).addClass(d.getClassName(), !0));\n      };\n\n      h.prototype.drawPoints = function () {\n        this.points.forEach(this.drawSinglePoint);\n      };\n\n      h.prototype.init = function () {\n        d.prototype.init.apply(this, arguments);\n        this.options.stacking = void 0;\n      };\n\n      h.prototype.pointAttribs = function (h, f) {\n        h = d.prototype.pointAttribs.call(this, h, f);\n        delete h.fill;\n        return h;\n      };\n\n      h.prototype.toYData = function (d) {\n        return [d.high, d.low, d.close];\n      };\n\n      h.prototype.translate = function () {\n        var h = this,\n            f = h.yAxis,\n            c = this.pointArrayMap && this.pointArrayMap.slice() || [],\n            a = c.map(function (a) {\n          return \"plot\" + (a.charAt(0).toUpperCase() + a.slice(1));\n        });\n        a.push(\"yBottom\");\n        c.push(\"low\");\n        d.prototype.translate.apply(h);\n        h.points.forEach(function (d) {\n          c.forEach(function (c, n) {\n            c = d[c];\n            null !== c && (h.dataModify && (c = h.dataModify.modifyValue(c)), d[a[n]] = f.toPixels(c, !0));\n          });\n          d.tooltipPos[1] = d.plotHigh + f.pos - h.chart.plotTop;\n        });\n      };\n\n      h.defaultOptions = H(t.defaultOptions, {\n        lineWidth: 1,\n        tooltip: {\n          pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> <b> {series.name}</b><br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>'\n        },\n        threshold: null,\n        states: {\n          hover: {\n            lineWidth: 3\n          }\n        },\n        stickyTracking: !0\n      });\n      return h;\n    }(t);\n\n    E(A.prototype, {\n      animate: null,\n      directTouch: !1,\n      pointArrayMap: [\"high\", \"low\", \"close\"],\n      pointAttrToOptions: {\n        stroke: \"color\",\n        \"stroke-width\": \"lineWidth\"\n      },\n      pointValKey: \"close\"\n    });\n    A.prototype.pointClass = d;\n    h.registerSeriesType(\"hlc\", A);\n    \"\";\n    return A;\n  });\n  N(h, \"Series/OHLC/OHLCPoint.js\", [h[\"Core/Series/SeriesRegistry.js\"]], function (d) {\n    var h = this && this.__extends || function () {\n      var d = function (h, t) {\n        d = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, h) {\n          d.__proto__ = h;\n        } || function (d, h) {\n          for (var t in h) h.hasOwnProperty(t) && (d[t] = h[t]);\n        };\n\n        return d(h, t);\n      };\n\n      return function (h, t) {\n        function A() {\n          this.constructor = h;\n        }\n\n        d(h, t);\n        h.prototype = null === t ? Object.create(t) : (A.prototype = t.prototype, new A());\n      };\n    }();\n\n    return function (d) {\n      function A() {\n        var h = null !== d && d.apply(this, arguments) || this;\n        h.open = void 0;\n        h.options = void 0;\n        h.plotOpen = void 0;\n        h.series = void 0;\n        return h;\n      }\n\n      h(A, d);\n\n      A.prototype.getClassName = function () {\n        return d.prototype.getClassName.call(this) + (this.open < this.close ? \" highcharts-point-up\" : \" highcharts-point-down\");\n      };\n\n      A.prototype.resolveUpColor = function () {\n        this.open < this.close && !this.options.color && this.series.options.upColor && (this.color = this.series.options.upColor);\n      };\n\n      A.prototype.resolveColor = function () {\n        d.prototype.resolveColor.call(this);\n        this.resolveUpColor();\n      };\n\n      A.prototype.getZone = function () {\n        var h = d.prototype.getZone.call(this);\n        this.resolveUpColor();\n        return h;\n      };\n\n      A.prototype.applyOptions = function () {\n        d.prototype.applyOptions.apply(this, arguments);\n        this.resolveColor && this.resolveColor();\n        return this;\n      };\n\n      return A;\n    }(d.seriesTypes.hlc.prototype.pointClass);\n  });\n  N(h, \"Series/OHLC/OHLCSeries.js\", [h[\"Series/OHLC/OHLCPoint.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"]], function (d, h, A) {\n    var E = this && this.__extends || function () {\n      var d = function (c, a) {\n        d = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, c) {\n          a.__proto__ = c;\n        } || function (a, c) {\n          for (var d in c) c.hasOwnProperty(d) && (a[d] = c[d]);\n        };\n\n        return d(c, a);\n      };\n\n      return function (c, a) {\n        function f() {\n          this.constructor = c;\n        }\n\n        d(c, a);\n        c.prototype = null === a ? Object.create(a) : (f.prototype = a.prototype, new f());\n      };\n    }(),\n        t = h.series,\n        G = h.seriesTypes.hlc,\n        H = A.addEvent,\n        y = A.extend,\n        q = A.merge,\n        p = function (d) {\n      function c() {\n        var a = null !== d && d.apply(this, arguments) || this;\n        a.data = void 0;\n        a.options = void 0;\n        a.points = void 0;\n        return a;\n      }\n\n      E(c, d);\n\n      c.prototype.getPointPath = function (a, c) {\n        var f = d.prototype.getPointPath.call(this, a, c);\n        c = c.strokeWidth();\n        var h = c % 2 / 2,\n            n = Math.round(a.plotX) - h,\n            p = Math.round(a.shapeArgs.width / 2);\n        null !== a.open && (a = Math.round(a.plotOpen) + h, f.push([\"M\", n, a], [\"L\", n - p, a]), d.prototype.extendStem.call(this, f, c / 2, a));\n        return f;\n      };\n\n      c.prototype.pointAttribs = function (a, c) {\n        c = d.prototype.pointAttribs.call(this, a, c);\n        var f = this.options;\n        delete c.fill;\n        !a.options.color && f.upColor && a.open < a.close && (c.stroke = f.upColor);\n        return c;\n      };\n\n      c.prototype.toYData = function (a) {\n        return [a.open, a.high, a.low, a.close];\n      };\n\n      c.defaultOptions = q(G.defaultOptions, {\n        tooltip: {\n          pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> <b> {series.name}</b><br/>Open: {point.open}<br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>'\n        }\n      });\n      return c;\n    }(G);\n\n    y(p.prototype, {\n      pointArrayMap: [\"open\", \"high\", \"low\", \"close\"]\n    });\n    p.prototype.pointClass = d;\n    h.registerSeriesType(\"ohlc\", p);\n    H(t, \"init\", function (d) {\n      d = d.options;\n      d.useOhlcData && \"highcharts-navigator-series\" !== d.id && y(this, {\n        pointValKey: p.prototype.pointValKey,\n        pointArrayMap: p.prototype.pointArrayMap,\n        toYData: p.prototype.toYData\n      });\n    });\n    H(t, \"afterSetOptions\", function (d) {\n      d = d.options;\n      var c = d.dataGrouping;\n      c && d.useOhlcData && \"highcharts-navigator-series\" !== d.id && (c.approximation = \"ohlc\");\n    });\n    \"\";\n    return p;\n  });\n  N(h, \"Series/Candlestick/CandlestickSeries.js\", [h[\"Core/DefaultOptions.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"]], function (d, h, A) {\n    var E = this && this.__extends || function () {\n      var d = function (h, f) {\n        d = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (c, a) {\n          c.__proto__ = a;\n        } || function (c, a) {\n          for (var d in a) a.hasOwnProperty(d) && (c[d] = a[d]);\n        };\n\n        return d(h, f);\n      };\n\n      return function (h, f) {\n        function c() {\n          this.constructor = h;\n        }\n\n        d(h, f);\n        h.prototype = null === f ? Object.create(f) : (c.prototype = f.prototype, new c());\n      };\n    }(),\n        t = d.defaultOptions;\n\n    d = h.seriesTypes;\n    var G = d.column,\n        H = d.ohlc,\n        y = A.merge;\n\n    A = function (d) {\n      function h() {\n        var f = null !== d && d.apply(this, arguments) || this;\n        f.data = void 0;\n        f.options = void 0;\n        f.points = void 0;\n        return f;\n      }\n\n      E(h, d);\n\n      h.prototype.pointAttribs = function (d, c) {\n        var a = G.prototype.pointAttribs.call(this, d, c),\n            f = this.options,\n            h = d.open < d.close,\n            p = f.lineColor || this.color,\n            q = d.color || this.color;\n        a[\"stroke-width\"] = f.lineWidth;\n        a.fill = d.options.color || (h ? f.upColor || q : q);\n        a.stroke = d.options.lineColor || (h ? f.upLineColor || p : p);\n        c && (d = f.states[c], a.fill = d.color || a.fill, a.stroke = d.lineColor || a.stroke, a[\"stroke-width\"] = d.lineWidth || a[\"stroke-width\"]);\n        return a;\n      };\n\n      h.prototype.drawPoints = function () {\n        var d = this,\n            c = d.chart,\n            a = d.yAxis.reversed;\n        d.points.forEach(function (f) {\n          var h = f.graphic,\n              n = !h;\n\n          if (\"undefined\" !== typeof f.plotY) {\n            h || (f.graphic = h = c.renderer.path().add(d.group));\n            d.chart.styledMode || h.attr(d.pointAttribs(f, f.selected && \"select\")).shadow(d.options.shadow);\n            var p = h.strokeWidth() % 2 / 2;\n            var q = Math.round(f.plotX) - p;\n            var t = f.plotOpen;\n            var y = f.plotClose;\n            var v = Math.min(t, y);\n            t = Math.max(t, y);\n            var z = Math.round(f.shapeArgs.width / 2);\n            y = a ? t !== f.yBottom : Math.round(v) !== Math.round(f.plotHigh);\n            var u = a ? Math.round(v) !== Math.round(f.plotHigh) : t !== f.yBottom;\n            v = Math.round(v) + p;\n            t = Math.round(t) + p;\n            p = [];\n            p.push([\"M\", q - z, t], [\"L\", q - z, v], [\"L\", q + z, v], [\"L\", q + z, t], [\"Z\"], [\"M\", q, v], [\"L\", q, y ? Math.round(a ? f.yBottom : f.plotHigh) : v], [\"M\", q, t], [\"L\", q, u ? Math.round(a ? f.plotHigh : f.yBottom) : t]);\n            h[n ? \"attr\" : \"animate\"]({\n              d: p\n            }).addClass(f.getClassName(), !0);\n          }\n        });\n      };\n\n      h.defaultOptions = y(H.defaultOptions, t.plotOptions, {\n        states: {\n          hover: {\n            lineWidth: 2\n          }\n        },\n        tooltip: t.plotOptions.ohlc.tooltip,\n        threshold: null,\n        lineColor: \"#000000\",\n        lineWidth: 1,\n        upColor: \"#ffffff\",\n        stickyTracking: !0\n      });\n      return h;\n    }(H);\n\n    h.registerSeriesType(\"candlestick\", A);\n    \"\";\n    return A;\n  });\n  N(h, \"Series/Flags/FlagsPoint.js\", [h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"]], function (d, h) {\n    var A = this && this.__extends || function () {\n      var d = function (h, t) {\n        d = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, h) {\n          d.__proto__ = h;\n        } || function (d, h) {\n          for (var p in h) h.hasOwnProperty(p) && (d[p] = h[p]);\n        };\n\n        return d(h, t);\n      };\n\n      return function (h, t) {\n        function y() {\n          this.constructor = h;\n        }\n\n        d(h, t);\n        h.prototype = null === t ? Object.create(t) : (y.prototype = t.prototype, new y());\n      };\n    }(),\n        E = h.isNumber;\n\n    return function (d) {\n      function h() {\n        var h = null !== d && d.apply(this, arguments) || this;\n        h.options = void 0;\n        h.series = void 0;\n        return h;\n      }\n\n      A(h, d);\n\n      h.prototype.isValid = function () {\n        return E(this.y) || \"undefined\" === typeof this.y;\n      };\n\n      h.prototype.hasNewShapeType = function () {\n        var d = this.options.shape || this.series.options.shape;\n        return this.graphic && d && d !== this.graphic.symbolKey;\n      };\n\n      return h;\n    }(d.seriesTypes.column.prototype.pointClass);\n  });\n  N(h, \"Series/OnSeriesComposition.js\", [h[\"Series/Column/ColumnSeries.js\"], h[\"Core/Series/Series.js\"], h[\"Core/Utilities.js\"]], function (d, h, A) {\n    var E = d.prototype,\n        t = h.prototype,\n        G = A.defined,\n        H = A.stableSort,\n        y;\n\n    (function (d) {\n      function h() {\n        return t.getPlotBox.call(this.options.onSeries && this.chart.get(this.options.onSeries) || this);\n      }\n\n      function f() {\n        E.translate.apply(this);\n        var a = this,\n            c = a.options,\n            d = a.chart,\n            f = a.points,\n            h = c.onSeries,\n            p = (h = h && d.get(h)) && h.options.step,\n            q = h && h.points,\n            t = d.inverted,\n            v = a.xAxis,\n            z = a.yAxis;\n        d = f.length - 1;\n        var u;\n        c = c.onKey || \"y\";\n        var k = q && q.length,\n            w = 0,\n            l;\n\n        if (h && h.visible && k) {\n          w = (h.pointXOffset || 0) + (h.barW || 0) / 2;\n          var e = h.currentDataGrouping;\n          var g = q[k - 1].x + (e ? e.totalRange : 0);\n          H(f, function (a, b) {\n            return a.x - b.x;\n          });\n\n          for (c = \"plot\" + c[0].toUpperCase() + c.substr(1); k-- && f[d];) {\n            var b = q[k];\n            e = f[d];\n            e.y = b.y;\n\n            if (b.x <= e.x && \"undefined\" !== typeof b[c]) {\n              if (e.x <= g && (e.plotY = b[c], b.x < e.x && !p && (l = q[k + 1]) && \"undefined\" !== typeof l[c])) {\n                var B = (e.x - b.x) / (l.x - b.x);\n                e.plotY += B * (l[c] - b[c]);\n                e.y += B * (l.y - b.y);\n              }\n\n              d--;\n              k++;\n              if (0 > d) break;\n            }\n          }\n        }\n\n        f.forEach(function (b, c) {\n          b.plotX += w;\n          if (\"undefined\" === typeof b.plotY || t) 0 <= b.plotX && b.plotX <= v.len ? t ? (b.plotY = v.translate(b.x, 0, 1, 0, 1), b.plotX = G(b.y) ? z.translate(b.y, 0, 0, 0, 1) : 0) : b.plotY = (v.opposite ? 0 : a.yAxis.len) + v.offset : b.shapeArgs = {};\n\n          if ((u = f[c - 1]) && u.plotX === b.plotX) {\n            \"undefined\" === typeof u.stackIndex && (u.stackIndex = 0);\n            var e = u.stackIndex + 1;\n          }\n\n          b.stackIndex = e;\n        });\n        this.onSeries = h;\n      }\n\n      var c = [];\n\n      d.compose = function (a) {\n        if (-1 === c.indexOf(a)) {\n          c.push(a);\n          var d = a.prototype;\n          d.getPlotBox = h;\n          d.translate = f;\n        }\n\n        return a;\n      };\n\n      d.getPlotBox = h;\n      d.translate = f;\n    })(y || (y = {}));\n\n    return y;\n  });\n  N(h, \"Series/Flags/FlagsSymbols.js\", [h[\"Core/Renderer/RendererRegistry.js\"], h[\"Core/Renderer/SVG/SVGRenderer.js\"]], function (d, h) {\n    function A(d) {\n      E[d + \"pin\"] = function (h, t, y, q, p) {\n        var f = p && p.anchorX;\n        p = p && p.anchorY;\n        \"circle\" === d && q > y && (h -= Math.round((q - y) / 2), y = q);\n        var c = E[d](h, t, y, q);\n\n        if (f && p) {\n          var a = f;\n          \"circle\" === d ? a = h + y / 2 : (h = c[0], y = c[1], \"M\" === h[0] && \"L\" === y[0] && (a = (h[1] + y[1]) / 2));\n          c.push([\"M\", a, t > p ? t : t + q], [\"L\", f, p]);\n          c = c.concat(E.circle(f - 1, p - 1, 2, 2));\n        }\n\n        return c;\n      };\n    }\n\n    var E = h.prototype.symbols;\n\n    E.flag = function (d, h, A, y, q) {\n      var p = q && q.anchorX || d;\n      q = q && q.anchorY || h;\n      var f = E.circle(p - 1, q - 1, 2, 2);\n      f.push([\"M\", p, q], [\"L\", d, h + y], [\"L\", d, h], [\"L\", d + A, h], [\"L\", d + A, h + y], [\"L\", d, h + y], [\"Z\"]);\n      return f;\n    };\n\n    A(\"circle\");\n    A(\"square\");\n    d = d.getRendererType();\n    d !== h && (d.prototype.symbols.circlepin = E.circlepin, d.prototype.symbols.flag = E.flag, d.prototype.symbols.squarepin = E.squarepin);\n    return E;\n  });\n  N(h, \"Series/Flags/FlagsSeries.js\", [h[\"Series/Flags/FlagsPoint.js\"], h[\"Core/Globals.js\"], h[\"Series/OnSeriesComposition.js\"], h[\"Core/Renderer/RendererUtilities.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Renderer/SVG/SVGElement.js\"], h[\"Core/Utilities.js\"]], function (d, h, A, F, t, G, H) {\n    var y = this && this.__extends || function () {\n      var a = function (c, d) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, c) {\n          a.__proto__ = c;\n        } || function (a, c) {\n          for (var d in c) c.hasOwnProperty(d) && (a[d] = c[d]);\n        };\n\n        return a(c, d);\n      };\n\n      return function (c, d) {\n        function f() {\n          this.constructor = c;\n        }\n\n        a(c, d);\n        c.prototype = null === d ? Object.create(d) : (f.prototype = d.prototype, new f());\n      };\n    }();\n\n    h = h.noop;\n    var q = F.distribute,\n        p = t.series,\n        f = t.seriesTypes.column,\n        c = H.addEvent,\n        a = H.defined;\n    F = H.extend;\n    var n = H.merge,\n        m = H.objectEach,\n        D = H.wrap;\n\n    H = function (d) {\n      function h() {\n        var a = null !== d && d.apply(this, arguments) || this;\n        a.data = void 0;\n        a.options = void 0;\n        a.points = void 0;\n        return a;\n      }\n\n      y(h, d);\n\n      h.prototype.animate = function (a) {\n        a && this.setClip();\n      };\n\n      h.prototype.drawPoints = function () {\n        var c = this.points,\n            d = this.chart,\n            f = d.renderer,\n            h = d.inverted,\n            p = this.options,\n            k = p.y,\n            w,\n            l = this.yAxis,\n            e = {},\n            g = [];\n\n        for (w = c.length; w--;) {\n          var b = c[w];\n          var B = (h ? b.plotY : b.plotX) > this.xAxis.len;\n          var t = b.plotX;\n          var r = b.stackIndex;\n          var x = b.options.shape || p.shape;\n          var M = b.plotY;\n          \"undefined\" !== typeof M && (M = b.plotY + k - (\"undefined\" !== typeof r && r * p.stackDistance));\n          b.anchorX = r ? void 0 : b.plotX;\n          var y = r ? void 0 : b.plotY;\n          var A = \"flag\" !== x;\n          r = b.graphic;\n          \"undefined\" !== typeof M && 0 <= t && !B ? (r && b.hasNewShapeType() && (r = r.destroy()), r || (r = b.graphic = f.label(\"\", null, null, x, null, null, p.useHTML).addClass(\"highcharts-point\").add(this.markerGroup), b.graphic.div && (b.graphic.div.point = b), r.isNew = !0), r.attr({\n            align: A ? \"center\" : \"left\",\n            width: p.width,\n            height: p.height,\n            \"text-align\": p.textAlign\n          }), d.styledMode || r.attr(this.pointAttribs(b)).css(n(p.style, b.style)).shadow(p.shadow), 0 < t && (t -= r.strokeWidth() % 2), x = {\n            y: M,\n            anchorY: y\n          }, p.allowOverlapX && (x.x = t, x.anchorX = b.anchorX), r.attr({\n            text: b.options.title || p.title || \"A\"\n          })[r.isNew ? \"attr\" : \"animate\"](x), p.allowOverlapX || (e[b.plotX] ? e[b.plotX].size = Math.max(e[b.plotX].size, r.width) : e[b.plotX] = {\n            align: A ? .5 : 0,\n            size: r.width,\n            target: t,\n            anchorX: t\n          }), b.tooltipPos = [t, M + l.pos - d.plotTop]) : r && (b.graphic = r.destroy());\n        }\n\n        if (!p.allowOverlapX) {\n          var C = 100;\n          m(e, function (a) {\n            a.plotX = a.anchorX;\n            g.push(a);\n            C = Math.max(a.size, C);\n          });\n          q(g, h ? l.len : this.xAxis.len, C);\n          c.forEach(function (b) {\n            var c = b.graphic && e[b.plotX];\n            c && (b.graphic[b.graphic.isNew ? \"attr\" : \"animate\"]({\n              x: c.pos + c.align * c.size,\n              anchorX: b.anchorX\n            }), a(c.pos) ? b.graphic.isNew = !1 : (b.graphic.attr({\n              x: -9999,\n              anchorX: -9999\n            }), b.graphic.isNew = !0));\n          });\n        }\n\n        p.useHTML && D(this.markerGroup, \"on\", function (a) {\n          return G.prototype.on.apply(a.apply(this, [].slice.call(arguments, 1)), [].slice.call(arguments, 1));\n        });\n      };\n\n      h.prototype.drawTracker = function () {\n        var a = this.points;\n        d.prototype.drawTracker.call(this);\n        a.forEach(function (d) {\n          var f = d.graphic;\n          f && (d.unbindMouseOver && d.unbindMouseOver(), d.unbindMouseOver = c(f.element, \"mouseover\", function () {\n            0 < d.stackIndex && !d.raised && (d._y = f.y, f.attr({\n              y: d._y - 8\n            }), d.raised = !0);\n            a.forEach(function (a) {\n              a !== d && a.raised && a.graphic && (a.graphic.attr({\n                y: a._y\n              }), a.raised = !1);\n            });\n          }));\n        });\n      };\n\n      h.prototype.pointAttribs = function (a, c) {\n        var d = this.options,\n            f = a && a.color || this.color,\n            h = d.lineColor,\n            k = a && a.lineWidth;\n        a = a && a.fillColor || d.fillColor;\n        c && (a = d.states[c].fillColor, h = d.states[c].lineColor, k = d.states[c].lineWidth);\n        return {\n          fill: a || f,\n          stroke: h || f,\n          \"stroke-width\": k || d.lineWidth || 0\n        };\n      };\n\n      h.prototype.setClip = function () {\n        p.prototype.setClip.apply(this, arguments);\n        !1 !== this.options.clip && this.sharedClipKey && this.markerGroup && this.markerGroup.clip(this.chart.sharedClips[this.sharedClipKey]);\n      };\n\n      h.defaultOptions = n(f.defaultOptions, {\n        pointRange: 0,\n        allowOverlapX: !1,\n        shape: \"flag\",\n        stackDistance: 12,\n        textAlign: \"center\",\n        tooltip: {\n          pointFormat: \"{point.text}\"\n        },\n        threshold: null,\n        y: -30,\n        fillColor: \"#ffffff\",\n        lineWidth: 1,\n        states: {\n          hover: {\n            lineColor: \"#000000\",\n            fillColor: \"#ccd6eb\"\n          }\n        },\n        style: {\n          fontSize: \"11px\",\n          fontWeight: \"bold\"\n        }\n      });\n      return h;\n    }(f);\n\n    A.compose(H);\n    F(H.prototype, {\n      allowDG: !1,\n      forceCrop: !0,\n      invertible: !1,\n      noSharedTooltip: !0,\n      pointClass: d,\n      sorted: !1,\n      takeOrdinalPosition: !1,\n      trackerGroups: [\"markerGroup\"],\n      buildKDTree: h,\n      init: p.prototype.init,\n      invertGroups: h\n    });\n    t.registerSeriesType(\"flags\", H);\n    \"\";\n    \"\";\n    return H;\n  });\n  N(h, \"Core/Axis/ScrollbarAxis.js\", [h[\"Core/Utilities.js\"]], function (d) {\n    var h = d.addEvent,\n        A = d.defined,\n        F = d.pick;\n    return function () {\n      function d() {}\n\n      d.compose = function (t, E) {\n        if (-1 === d.composed.indexOf(t)) d.composed.push(t);else return t;\n\n        var y = function (d) {\n          var h = F(d.options && d.options.min, d.min),\n              f = F(d.options && d.options.max, d.max);\n          return {\n            axisMin: h,\n            axisMax: f,\n            scrollMin: A(d.dataMin) ? Math.min(h, d.min, d.dataMin, F(d.threshold, Infinity)) : h,\n            scrollMax: A(d.dataMax) ? Math.max(f, d.max, d.dataMax, F(d.threshold, -Infinity)) : f\n          };\n        };\n\n        h(t, \"afterInit\", function () {\n          var d = this;\n          d.options && d.options.scrollbar && d.options.scrollbar.enabled && (d.options.scrollbar.vertical = !d.horiz, d.options.startOnTick = d.options.endOnTick = !1, d.scrollbar = new E(d.chart.renderer, d.options.scrollbar, d.chart), h(d.scrollbar, \"changed\", function (h) {\n            var f = y(d),\n                c = f.axisMax,\n                a = f.scrollMin,\n                p = f.scrollMax - a;\n            A(f.axisMin) && A(c) && (d.horiz && !d.reversed || !d.horiz && d.reversed ? (f = a + p * this.to, a += p * this.from) : (f = a + p * (1 - this.from), a += p * (1 - this.to)), this.shouldUpdateExtremes(h.DOMType) ? d.setExtremes(a, f, !0, \"mousemove\" !== h.DOMType && \"touchmove\" !== h.DOMType, h) : this.setRange(this.from, this.to));\n          }));\n        });\n        h(t, \"afterRender\", function () {\n          var d = y(this),\n              h = d.scrollMin,\n              f = d.scrollMax;\n          d = this.scrollbar;\n          var c = this.axisTitleMargin + (this.titleOffset || 0),\n              a = this.chart.scrollbarsOffsets,\n              n = this.options.margin || 0;\n          d && (this.horiz ? (this.opposite || (a[1] += c), d.position(this.left, this.top + this.height + 2 + a[1] - (this.opposite ? n : 0), this.width, this.height), this.opposite || (a[1] += n), c = 1) : (this.opposite && (a[0] += c), d.position(d.options.opposite ? this.left + this.width + 2 + a[0] - (this.opposite ? 0 : n) : this.opposite ? 0 : n, this.top, this.width, this.height), this.opposite && (a[0] += n), c = 0), a[c] += d.size + d.options.margin, isNaN(h) || isNaN(f) || !A(this.min) || !A(this.max) || this.min === this.max ? d.setRange(0, 1) : (a = (this.min - h) / (f - h), h = (this.max - h) / (f - h), this.horiz && !this.reversed || !this.horiz && this.reversed ? d.setRange(a, h) : d.setRange(1 - h, 1 - a)));\n        });\n        h(t, \"afterGetOffset\", function () {\n          var d = this.scrollbar && !this.scrollbar.options.opposite;\n          d = this.horiz ? 2 : d ? 3 : 1;\n          var h = this.scrollbar;\n          h && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[d] += h.size + h.options.margin);\n        });\n        return t;\n      };\n\n      d.composed = [];\n      return d;\n    }();\n  });\n  N(h, \"Core/ScrollbarDefaults.js\", [h[\"Core/Globals.js\"]], function (d) {\n    return {\n      height: d.isTouchDevice ? 20 : 14,\n      barBorderRadius: 0,\n      buttonBorderRadius: 0,\n      liveRedraw: void 0,\n      margin: 10,\n      minWidth: 6,\n      opposite: !0,\n      step: .2,\n      zIndex: 3,\n      barBackgroundColor: \"#cccccc\",\n      barBorderWidth: 1,\n      barBorderColor: \"#cccccc\",\n      buttonArrowColor: \"#333333\",\n      buttonBackgroundColor: \"#e6e6e6\",\n      buttonBorderColor: \"#cccccc\",\n      buttonBorderWidth: 1,\n      rifleColor: \"#333333\",\n      trackBackgroundColor: \"#f2f2f2\",\n      trackBorderColor: \"#f2f2f2\",\n      trackBorderWidth: 1\n    };\n  });\n  N(h, \"Core/Scrollbar.js\", [h[\"Core/DefaultOptions.js\"], h[\"Core/Globals.js\"], h[\"Core/Axis/ScrollbarAxis.js\"], h[\"Core/ScrollbarDefaults.js\"], h[\"Core/Utilities.js\"]], function (d, h, A, F, t) {\n    var E = d.defaultOptions,\n        H = t.addEvent,\n        y = t.correctFloat,\n        q = t.defined,\n        p = t.destroyObjectProperties,\n        f = t.fireEvent,\n        c = t.merge,\n        a = t.pick,\n        n = t.removeEvent;\n\n    d = function () {\n      function d(a, c, d) {\n        this._events = [];\n        this.chart = void 0;\n        this.from = this.chartY = this.chartX = 0;\n        this.scrollbar = this.renderer = this.options = this.group = void 0;\n        this.scrollbarButtons = [];\n        this.scrollbarGroup = void 0;\n        this.scrollbarLeft = 0;\n        this.scrollbarRifles = void 0;\n        this.scrollbarStrokeWidth = 1;\n        this.to = this.size = this.scrollbarTop = 0;\n        this.track = void 0;\n        this.trackBorderWidth = 1;\n        this.userOptions = void 0;\n        this.y = this.x = 0;\n        this.init(a, c, d);\n      }\n\n      d.compose = function (a) {\n        A.compose(a, d);\n      };\n\n      d.swapXY = function (a, c) {\n        c && a.forEach(function (a) {\n          for (var c = a.length, d, f = 0; f < c; f += 2) d = a[f + 1], \"number\" === typeof d && (a[f + 1] = a[f + 2], a[f + 2] = d);\n        });\n        return a;\n      };\n\n      d.prototype.addEvents = function () {\n        var a = this.options.inverted ? [1, 0] : [0, 1],\n            c = this.scrollbarButtons,\n            d = this.scrollbarGroup.element,\n            f = this.track.element,\n            m = this.mouseDownHandler.bind(this),\n            n = this.mouseMoveHandler.bind(this),\n            p = this.mouseUpHandler.bind(this);\n        a = [[c[a[0]].element, \"click\", this.buttonToMinClick.bind(this)], [c[a[1]].element, \"click\", this.buttonToMaxClick.bind(this)], [f, \"click\", this.trackClick.bind(this)], [d, \"mousedown\", m], [d.ownerDocument, \"mousemove\", n], [d.ownerDocument, \"mouseup\", p]];\n        h.hasTouch && a.push([d, \"touchstart\", m], [d.ownerDocument, \"touchmove\", n], [d.ownerDocument, \"touchend\", p]);\n        a.forEach(function (a) {\n          H.apply(null, a);\n        });\n        this._events = a;\n      };\n\n      d.prototype.buttonToMaxClick = function (c) {\n        var d = (this.to - this.from) * a(this.options.step, .2);\n        this.updatePosition(this.from + d, this.to + d);\n        f(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMEvent: c\n        });\n      };\n\n      d.prototype.buttonToMinClick = function (c) {\n        var d = y(this.to - this.from) * a(this.options.step, .2);\n        this.updatePosition(y(this.from - d), y(this.to - d));\n        f(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMEvent: c\n        });\n      };\n\n      d.prototype.cursorToScrollbarPosition = function (a) {\n        var c = this.options;\n        c = c.minWidth > this.calculatedWidth ? c.minWidth : 0;\n        return {\n          chartX: (a.chartX - this.x - this.xOffset) / (this.barWidth - c),\n          chartY: (a.chartY - this.y - this.yOffset) / (this.barWidth - c)\n        };\n      };\n\n      d.prototype.destroy = function () {\n        var a = this,\n            c = a.chart.scroller;\n        a.removeEvents();\n        [\"track\", \"scrollbarRifles\", \"scrollbar\", \"scrollbarGroup\", \"group\"].forEach(function (c) {\n          a[c] && a[c].destroy && (a[c] = a[c].destroy());\n        });\n        c && a === c.scrollbar && (c.scrollbar = null, p(c.scrollbarButtons));\n      };\n\n      d.prototype.drawScrollbarButton = function (a) {\n        var c = this.renderer,\n            f = this.scrollbarButtons,\n            h = this.options,\n            m = this.size,\n            n = c.g().add(this.group);\n        f.push(n);\n        n = c.rect().addClass(\"highcharts-scrollbar-button\").add(n);\n        this.chart.styledMode || n.attr({\n          stroke: h.buttonBorderColor,\n          \"stroke-width\": h.buttonBorderWidth,\n          fill: h.buttonBackgroundColor\n        });\n        n.attr(n.crisp({\n          x: -.5,\n          y: -.5,\n          width: m + 1,\n          height: m + 1,\n          r: h.buttonBorderRadius\n        }, n.strokeWidth()));\n        n = c.path(d.swapXY([[\"M\", m / 2 + (a ? -1 : 1), m / 2 - 3], [\"L\", m / 2 + (a ? -1 : 1), m / 2 + 3], [\"L\", m / 2 + (a ? 2 : -2), m / 2]], h.vertical)).addClass(\"highcharts-scrollbar-arrow\").add(f[a]);\n        this.chart.styledMode || n.attr({\n          fill: h.buttonArrowColor\n        });\n      };\n\n      d.prototype.init = function (d, f, h) {\n        this.scrollbarButtons = [];\n        this.renderer = d;\n        this.userOptions = f;\n        this.options = c(F, E.scrollbar, f);\n        this.chart = h;\n        this.size = a(this.options.size, this.options.height);\n        f.enabled && (this.render(), this.addEvents());\n      };\n\n      d.prototype.mouseDownHandler = function (a) {\n        a = this.chart.pointer.normalize(a);\n        a = this.cursorToScrollbarPosition(a);\n        this.chartX = a.chartX;\n        this.chartY = a.chartY;\n        this.initPositions = [this.from, this.to];\n        this.grabbedCenter = !0;\n      };\n\n      d.prototype.mouseMoveHandler = function (a) {\n        var c = this.chart.pointer.normalize(a),\n            d = this.options.vertical ? \"chartY\" : \"chartX\",\n            h = this.initPositions || [];\n        !this.grabbedCenter || a.touches && 0 === a.touches[0][d] || (c = this.cursorToScrollbarPosition(c)[d], d = this[d], d = c - d, this.hasDragged = !0, this.updatePosition(h[0] + d, h[1] + d), this.hasDragged && f(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMType: a.type,\n          DOMEvent: a\n        }));\n      };\n\n      d.prototype.mouseUpHandler = function (a) {\n        this.hasDragged && f(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMType: a.type,\n          DOMEvent: a\n        });\n        this.grabbedCenter = this.hasDragged = this.chartX = this.chartY = null;\n      };\n\n      d.prototype.position = function (a, c, d, f) {\n        var h = this.options.vertical,\n            m = this.rendered ? \"animate\" : \"attr\",\n            n = 0;\n        this.x = a;\n        this.y = c + this.trackBorderWidth;\n        this.width = d;\n        this.xOffset = this.height = f;\n        this.yOffset = n;\n        h ? (this.width = this.yOffset = d = n = this.size, this.xOffset = c = 0, this.barWidth = f - 2 * d, this.x = a += this.options.margin) : (this.height = this.xOffset = f = c = this.size, this.barWidth = d - 2 * f, this.y += this.options.margin);\n        this.group[m]({\n          translateX: a,\n          translateY: this.y\n        });\n        this.track[m]({\n          width: d,\n          height: f\n        });\n        this.scrollbarButtons[1][m]({\n          translateX: h ? 0 : d - c,\n          translateY: h ? f - n : 0\n        });\n      };\n\n      d.prototype.removeEvents = function () {\n        this._events.forEach(function (a) {\n          n.apply(null, a);\n        });\n\n        this._events.length = 0;\n      };\n\n      d.prototype.render = function () {\n        var a = this.renderer,\n            c = this.options,\n            f = this.size,\n            h = this.chart.styledMode,\n            m = a.g(\"scrollbar\").attr({\n          zIndex: c.zIndex,\n          translateY: -99999\n        }).add();\n        this.group = m;\n        this.track = a.rect().addClass(\"highcharts-scrollbar-track\").attr({\n          x: 0,\n          r: c.trackBorderRadius || 0,\n          height: f,\n          width: f\n        }).add(m);\n        h || this.track.attr({\n          fill: c.trackBackgroundColor,\n          stroke: c.trackBorderColor,\n          \"stroke-width\": c.trackBorderWidth\n        });\n        this.trackBorderWidth = this.track.strokeWidth();\n        this.track.attr({\n          y: -this.trackBorderWidth % 2 / 2\n        });\n        this.scrollbarGroup = a.g().add(m);\n        this.scrollbar = a.rect().addClass(\"highcharts-scrollbar-thumb\").attr({\n          height: f,\n          width: f,\n          r: c.barBorderRadius || 0\n        }).add(this.scrollbarGroup);\n        this.scrollbarRifles = a.path(d.swapXY([[\"M\", -3, f / 4], [\"L\", -3, 2 * f / 3], [\"M\", 0, f / 4], [\"L\", 0, 2 * f / 3], [\"M\", 3, f / 4], [\"L\", 3, 2 * f / 3]], c.vertical)).addClass(\"highcharts-scrollbar-rifles\").add(this.scrollbarGroup);\n        h || (this.scrollbar.attr({\n          fill: c.barBackgroundColor,\n          stroke: c.barBorderColor,\n          \"stroke-width\": c.barBorderWidth\n        }), this.scrollbarRifles.attr({\n          stroke: c.rifleColor,\n          \"stroke-width\": 1\n        }));\n        this.scrollbarStrokeWidth = this.scrollbar.strokeWidth();\n        this.scrollbarGroup.translate(-this.scrollbarStrokeWidth % 2 / 2, -this.scrollbarStrokeWidth % 2 / 2);\n        this.drawScrollbarButton(0);\n        this.drawScrollbarButton(1);\n      };\n\n      d.prototype.setRange = function (a, c) {\n        var d = this.options,\n            f = d.vertical,\n            h = d.minWidth,\n            m = this.barWidth,\n            n = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? \"attr\" : \"animate\";\n\n        if (q(m)) {\n          var p = m * Math.min(c, 1);\n          a = Math.max(a, 0);\n          var k = Math.ceil(m * a);\n          this.calculatedWidth = p = y(p - k);\n          p < h && (k = (m - h + p) * a, p = h);\n          h = Math.floor(k + this.xOffset + this.yOffset);\n          m = p / 2 - .5;\n          this.from = a;\n          this.to = c;\n          f ? (this.scrollbarGroup[n]({\n            translateY: h\n          }), this.scrollbar[n]({\n            height: p\n          }), this.scrollbarRifles[n]({\n            translateY: m\n          }), this.scrollbarTop = h, this.scrollbarLeft = 0) : (this.scrollbarGroup[n]({\n            translateX: h\n          }), this.scrollbar[n]({\n            width: p\n          }), this.scrollbarRifles[n]({\n            translateX: m\n          }), this.scrollbarLeft = h, this.scrollbarTop = 0);\n          12 >= p ? this.scrollbarRifles.hide() : this.scrollbarRifles.show(!0);\n          !1 === d.showFull && (0 >= a && 1 <= c ? this.group.hide() : this.group.show());\n          this.rendered = !0;\n        }\n      };\n\n      d.prototype.shouldUpdateExtremes = function (c) {\n        return a(this.options.liveRedraw, h.svg && !h.isTouchDevice && !this.chart.isBoosting) || \"mouseup\" === c || \"touchend\" === c || !q(c);\n      };\n\n      d.prototype.trackClick = function (a) {\n        var c = this.chart.pointer.normalize(a),\n            d = this.to - this.from,\n            h = this.y + this.scrollbarTop,\n            m = this.x + this.scrollbarLeft;\n        this.options.vertical && c.chartY > h || !this.options.vertical && c.chartX > m ? this.updatePosition(this.from + d, this.to + d) : this.updatePosition(this.from - d, this.to - d);\n        f(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMEvent: a\n        });\n      };\n\n      d.prototype.update = function (a) {\n        this.destroy();\n        this.init(this.chart.renderer, c(!0, this.options, a), this.chart);\n      };\n\n      d.prototype.updatePosition = function (a, c) {\n        1 < c && (a = y(1 - y(c - a)), c = 1);\n        0 > a && (c = y(c - a), a = 0);\n        this.from = a;\n        this.to = c;\n      };\n\n      d.defaultOptions = F;\n      return d;\n    }();\n\n    E.scrollbar = c(!0, d.defaultOptions, E.scrollbar);\n    return d;\n  });\n  N(h, \"Core/Axis/NavigatorAxis.js\", [h[\"Core/Globals.js\"], h[\"Core/Utilities.js\"]], function (d, h) {\n    var A = d.isTouchDevice,\n        E = h.addEvent,\n        t = h.correctFloat,\n        G = h.defined,\n        H = h.isNumber,\n        y = h.pick,\n        q = function () {\n      function d(d) {\n        this.axis = d;\n      }\n\n      d.prototype.destroy = function () {\n        this.axis = void 0;\n      };\n\n      d.prototype.toFixedRange = function (d, c, a, h) {\n        var f = this.axis,\n            n = f.chart;\n        n = n && n.fixedRange;\n        var p = (f.pointRange || 0) / 2;\n        d = y(a, f.translate(d, !0, !f.horiz));\n        c = y(h, f.translate(c, !0, !f.horiz));\n        f = n && (c - d) / n;\n        G(a) || (d = t(d + p));\n        G(h) || (c = t(c - p));\n        .7 < f && 1.3 > f && (h ? d = c - n : c = d + n);\n        H(d) && H(c) || (d = c = void 0);\n        return {\n          min: d,\n          max: c\n        };\n      };\n\n      return d;\n    }();\n\n    return function () {\n      function d() {}\n\n      d.compose = function (d) {\n        d.keepProps.push(\"navigatorAxis\");\n        E(d, \"init\", function () {\n          this.navigatorAxis || (this.navigatorAxis = new q(this));\n        });\n        E(d, \"zoom\", function (c) {\n          var a = this.chart.options,\n              d = a.navigator,\n              f = this.navigatorAxis,\n              h = a.chart.pinchType,\n              p = a.rangeSelector;\n          a = a.chart.zoomType;\n          this.isXAxis && (d && d.enabled || p && p.enabled) && (\"y\" === a ? c.zoomed = !1 : (!A && \"xy\" === a || A && \"xy\" === h) && this.options.range && (d = f.previousZoom, G(c.newMin) ? f.previousZoom = [this.min, this.max] : d && (c.newMin = d[0], c.newMax = d[1], f.previousZoom = void 0)));\n          \"undefined\" !== typeof c.zoomed && c.preventDefault();\n        });\n      };\n\n      d.AdditionsClass = q;\n      return d;\n    }();\n  });\n  N(h, \"Core/Navigator.js\", [h[\"Core/Axis/Axis.js\"], h[\"Core/Chart/Chart.js\"], h[\"Core/Color/Color.js\"], h[\"Core/Globals.js\"], h[\"Core/Axis/NavigatorAxis.js\"], h[\"Core/DefaultOptions.js\"], h[\"Core/Renderer/RendererRegistry.js\"], h[\"Core/Scrollbar.js\"], h[\"Core/Series/Series.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"]], function (d, h, A, F, t, G, H, y, q, p, f) {\n    A = A.parse;\n\n    var c = F.hasTouch,\n        a = F.isTouchDevice,\n        n = G.defaultOptions,\n        m = f.addEvent,\n        E = f.clamp,\n        C = f.correctFloat,\n        I = f.defined,\n        L = f.destroyObjectProperties,\n        K = f.erase,\n        v = f.extend,\n        z = f.find,\n        u = f.isArray,\n        k = f.isNumber,\n        w = f.merge,\n        l = f.pick,\n        e = f.removeEvent,\n        g = f.splat,\n        b = function (a) {\n      for (var b = [], c = 1; c < arguments.length; c++) b[c - 1] = arguments[c];\n\n      b = [].filter.call(b, k);\n      if (b.length) return Math[a].apply(0, b);\n    };\n\n    G = \"undefined\" === typeof p.seriesTypes.areaspline ? \"line\" : \"areaspline\";\n    v(n, {\n      navigator: {\n        height: 40,\n        margin: 25,\n        maskInside: !0,\n        handles: {\n          width: 7,\n          height: 15,\n          symbols: [\"navigator-handle\", \"navigator-handle\"],\n          enabled: !0,\n          lineWidth: 1,\n          backgroundColor: \"#f2f2f2\",\n          borderColor: \"#999999\"\n        },\n        maskFill: A(\"#6685c2\").setOpacity(.3).get(),\n        outlineColor: \"#cccccc\",\n        outlineWidth: 1,\n        series: {\n          type: G,\n          fillOpacity: .05,\n          lineWidth: 1,\n          compare: null,\n          dataGrouping: {\n            approximation: \"average\",\n            enabled: !0,\n            groupPixelWidth: 2,\n            firstAnchor: \"firstPoint\",\n            anchor: \"middle\",\n            lastAnchor: \"lastPoint\",\n            units: [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2, 3, 4]], [\"week\", [1, 2, 3]], [\"month\", [1, 3, 6]], [\"year\", null]]\n          },\n          dataLabels: {\n            enabled: !1,\n            zIndex: 2\n          },\n          id: \"highcharts-navigator-series\",\n          className: \"highcharts-navigator-series\",\n          lineColor: null,\n          marker: {\n            enabled: !1\n          },\n          threshold: null\n        },\n        xAxis: {\n          overscroll: 0,\n          className: \"highcharts-navigator-xaxis\",\n          tickLength: 0,\n          lineWidth: 0,\n          gridLineColor: \"#e6e6e6\",\n          gridLineWidth: 1,\n          tickPixelInterval: 200,\n          labels: {\n            align: \"left\",\n            style: {\n              color: \"#999999\"\n            },\n            x: 3,\n            y: -4\n          },\n          crosshair: !1\n        },\n        yAxis: {\n          className: \"highcharts-navigator-yaxis\",\n          gridLineWidth: 0,\n          startOnTick: !1,\n          endOnTick: !1,\n          minPadding: .1,\n          maxPadding: .1,\n          labels: {\n            enabled: !1\n          },\n          crosshair: !1,\n          title: {\n            text: null\n          },\n          tickLength: 0,\n          tickWidth: 0\n        }\n      }\n    });\n\n    H.getRendererType().prototype.symbols[\"navigator-handle\"] = function (a, b, c, e, d) {\n      a = (d && d.width || 0) / 2;\n      b = Math.round(a / 3) + .5;\n      d = d && d.height || 0;\n      return [[\"M\", -a - 1, .5], [\"L\", a, .5], [\"L\", a, d + .5], [\"L\", -a - 1, d + .5], [\"L\", -a - 1, .5], [\"M\", -b, 4], [\"L\", -b, d - 3], [\"M\", b - 1, 4], [\"L\", b - 1, d - 3]];\n    };\n\n    var B = function () {\n      function f(a) {\n        this.zoomedMin = this.zoomedMax = this.yAxis = this.xAxis = this.top = this.size = this.shades = this.rendered = this.range = this.outlineHeight = this.outline = this.opposite = this.navigatorSize = this.navigatorSeries = this.navigatorOptions = this.navigatorGroup = this.navigatorEnabled = this.left = this.height = this.handles = this.chart = this.baseSeries = void 0;\n        this.init(a);\n      }\n\n      f.prototype.drawHandle = function (a, b, c, d) {\n        var e = this.navigatorOptions.handles.height;\n        this.handles[b][d](c ? {\n          translateX: Math.round(this.left + this.height / 2),\n          translateY: Math.round(this.top + parseInt(a, 10) + .5 - e)\n        } : {\n          translateX: Math.round(this.left + parseInt(a, 10)),\n          translateY: Math.round(this.top + this.height / 2 - e / 2 - 1)\n        });\n      };\n\n      f.prototype.drawOutline = function (a, b, c, d) {\n        var e = this.navigatorOptions.maskInside,\n            f = this.outline.strokeWidth(),\n            g = f / 2,\n            h = f % 2 / 2;\n        f = this.outlineHeight;\n        var k = this.scrollbarHeight || 0,\n            l = this.size,\n            m = this.left - k,\n            r = this.top;\n        c ? (m -= g, c = r + b + h, b = r + a + h, h = [[\"M\", m + f, r - k - h], [\"L\", m + f, c], [\"L\", m, c], [\"L\", m, b], [\"L\", m + f, b], [\"L\", m + f, r + l + k]], e && h.push([\"M\", m + f, c - g], [\"L\", m + f, b + g])) : (a += m + k - h, b += m + k - h, r += g, h = [[\"M\", m, r], [\"L\", a, r], [\"L\", a, r + f], [\"L\", b, r + f], [\"L\", b, r], [\"L\", m + l + 2 * k, r]], e && h.push([\"M\", a - g, r], [\"L\", b + g, r]));\n        this.outline[d]({\n          d: h\n        });\n      };\n\n      f.prototype.drawMasks = function (a, b, c, d) {\n        var e = this.left,\n            f = this.top,\n            g = this.height;\n\n        if (c) {\n          var h = [e, e, e];\n          var k = [f, f + a, f + b];\n          var l = [g, g, g];\n          var m = [a, b - a, this.size - b];\n        } else h = [e, e + a, e + b], k = [f, f, f], l = [a, b - a, this.size - b], m = [g, g, g];\n\n        this.shades.forEach(function (a, b) {\n          a[d]({\n            x: h[b],\n            y: k[b],\n            width: l[b],\n            height: m[b]\n          });\n        });\n      };\n\n      f.prototype.renderElements = function () {\n        var a = this,\n            b = a.navigatorOptions,\n            c = b.maskInside,\n            e = a.chart,\n            d = e.renderer,\n            f,\n            g = {\n          cursor: e.inverted ? \"ns-resize\" : \"ew-resize\"\n        };\n        a.navigatorGroup = f = d.g(\"navigator\").attr({\n          zIndex: 8,\n          visibility: \"hidden\"\n        }).add();\n        [!c, c, !c].forEach(function (c, h) {\n          a.shades[h] = d.rect().addClass(\"highcharts-navigator-mask\" + (1 === h ? \"-inside\" : \"-outside\")).add(f);\n          e.styledMode || a.shades[h].attr({\n            fill: c ? b.maskFill : \"rgba(0,0,0,0)\"\n          }).css(1 === h && g);\n        });\n        a.outline = d.path().addClass(\"highcharts-navigator-outline\").add(f);\n        e.styledMode || a.outline.attr({\n          \"stroke-width\": b.outlineWidth,\n          stroke: b.outlineColor\n        });\n        b.handles.enabled && [0, 1].forEach(function (c) {\n          b.handles.inverted = e.inverted;\n          a.handles[c] = d.symbol(b.handles.symbols[c], -b.handles.width / 2 - 1, 0, b.handles.width, b.handles.height, b.handles);\n          a.handles[c].attr({\n            zIndex: 7 - c\n          }).addClass(\"highcharts-navigator-handle highcharts-navigator-handle-\" + [\"left\", \"right\"][c]).add(f);\n\n          if (!e.styledMode) {\n            var h = b.handles;\n            a.handles[c].attr({\n              fill: h.backgroundColor,\n              stroke: h.borderColor,\n              \"stroke-width\": h.lineWidth\n            }).css(g);\n          }\n        });\n      };\n\n      f.prototype.update = function (a) {\n        (this.series || []).forEach(function (a) {\n          a.baseSeries && delete a.baseSeries.navigatorSeries;\n        });\n        this.destroy();\n        w(!0, this.chart.options.navigator, this.options, a);\n        this.init(this.chart);\n      };\n\n      f.prototype.render = function (a, b, c, e) {\n        var d = this.chart,\n            f = this.scrollbarHeight,\n            g,\n            h = this.xAxis,\n            m = h.pointRange || 0;\n        var r = h.navigatorAxis.fake ? d.xAxis[0] : h;\n        var n = this.navigatorEnabled,\n            p,\n            x = this.rendered;\n        var q = d.inverted;\n        var u = d.xAxis[0].minRange,\n            B = d.xAxis[0].options.maxRange;\n\n        if (!this.hasDragged || I(c)) {\n          a = C(a - m / 2);\n          b = C(b + m / 2);\n          if (!k(a) || !k(b)) if (x) c = 0, e = l(h.width, r.width);else return;\n          this.left = l(h.left, d.plotLeft + f + (q ? d.plotWidth : 0));\n          this.size = p = g = l(h.len, (q ? d.plotHeight : d.plotWidth) - 2 * f);\n          d = q ? f : g + 2 * f;\n          c = l(c, h.toPixels(a, !0));\n          e = l(e, h.toPixels(b, !0));\n          k(c) && Infinity !== Math.abs(c) || (c = 0, e = d);\n          a = h.toValue(c, !0);\n          b = h.toValue(e, !0);\n          var w = Math.abs(C(b - a));\n          w < u ? this.grabbedLeft ? c = h.toPixels(b - u - m, !0) : this.grabbedRight && (e = h.toPixels(a + u + m, !0)) : I(B) && C(w - m) > B && (this.grabbedLeft ? c = h.toPixels(b - B - m, !0) : this.grabbedRight && (e = h.toPixels(a + B + m, !0)));\n          this.zoomedMax = E(Math.max(c, e), 0, p);\n          this.zoomedMin = E(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(c, e), 0, p);\n          this.range = this.zoomedMax - this.zoomedMin;\n          p = Math.round(this.zoomedMax);\n          c = Math.round(this.zoomedMin);\n          n && (this.navigatorGroup.attr({\n            visibility: \"visible\"\n          }), x = x && !this.hasDragged ? \"animate\" : \"attr\", this.drawMasks(c, p, q, x), this.drawOutline(c, p, q, x), this.navigatorOptions.handles.enabled && (this.drawHandle(c, 0, q, x), this.drawHandle(p, 1, q, x)));\n          this.scrollbar && (q ? (q = this.top - f, r = this.left - f + (n || !r.opposite ? 0 : (r.titleOffset || 0) + r.axisTitleMargin), f = g + 2 * f) : (q = this.top + (n ? this.height : -f), r = this.left - f), this.scrollbar.position(r, q, d, f), this.scrollbar.setRange(this.zoomedMin / (g || 1), this.zoomedMax / (g || 1)));\n          this.rendered = !0;\n        }\n      };\n\n      f.prototype.addMouseEvents = function () {\n        var a = this,\n            b = a.chart,\n            e = b.container,\n            d = [],\n            f,\n            g;\n\n        a.mouseMoveHandler = f = function (b) {\n          a.onMouseMove(b);\n        };\n\n        a.mouseUpHandler = g = function (b) {\n          a.onMouseUp(b);\n        };\n\n        d = a.getPartsEvents(\"mousedown\");\n        d.push(m(b.renderTo, \"mousemove\", f), m(e.ownerDocument, \"mouseup\", g));\n        c && (d.push(m(b.renderTo, \"touchmove\", f), m(e.ownerDocument, \"touchend\", g)), d.concat(a.getPartsEvents(\"touchstart\")));\n        a.eventsToUnbind = d;\n        a.series && a.series[0] && d.push(m(a.series[0].xAxis, \"foundExtremes\", function () {\n          b.navigator.modifyNavigatorAxisExtremes();\n        }));\n      };\n\n      f.prototype.getPartsEvents = function (a) {\n        var b = this,\n            c = [];\n        [\"shades\", \"handles\"].forEach(function (d) {\n          b[d].forEach(function (e, f) {\n            c.push(m(e.element, a, function (a) {\n              b[d + \"Mousedown\"](a, f);\n            }));\n          });\n        });\n        return c;\n      };\n\n      f.prototype.shadesMousedown = function (a, b) {\n        a = this.chart.pointer.normalize(a);\n        var c = this.chart,\n            d = this.xAxis,\n            e = this.zoomedMin,\n            f = this.left,\n            g = this.size,\n            h = this.range,\n            k = a.chartX;\n        c.inverted && (k = a.chartY, f = this.top);\n        if (1 === b) this.grabbedCenter = k, this.fixedWidth = h, this.dragOffset = k - e;else {\n          a = k - f - h / 2;\n          if (0 === b) a = Math.max(0, a);else if (2 === b && a + h >= g) if (a = g - h, this.reversedExtremes) {\n            a -= h;\n            var l = this.getUnionExtremes().dataMin;\n          } else var m = this.getUnionExtremes().dataMax;\n          a !== e && (this.fixedWidth = h, b = d.navigatorAxis.toFixedRange(a, a + h, l, m), I(b.min) && c.xAxis[0].setExtremes(Math.min(b.min, b.max), Math.max(b.min, b.max), !0, null, {\n            trigger: \"navigator\"\n          }));\n        }\n      };\n\n      f.prototype.handlesMousedown = function (a, b) {\n        this.chart.pointer.normalize(a);\n        a = this.chart;\n        var c = a.xAxis[0],\n            d = this.reversedExtremes;\n        0 === b ? (this.grabbedLeft = !0, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = d ? c.min : c.max) : (this.grabbedRight = !0, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = d ? c.max : c.min);\n        a.fixedRange = null;\n      };\n\n      f.prototype.onMouseMove = function (b) {\n        var c = this,\n            d = c.chart,\n            e = c.left,\n            f = c.navigatorSize,\n            g = c.range,\n            h = c.dragOffset,\n            k = d.inverted;\n        b.touches && 0 === b.touches[0].pageX || (b = d.pointer.normalize(b), d = b.chartX, k && (e = c.top, d = b.chartY), c.grabbedLeft ? (c.hasDragged = !0, c.render(0, 0, d - e, c.otherHandlePos)) : c.grabbedRight ? (c.hasDragged = !0, c.render(0, 0, c.otherHandlePos, d - e)) : c.grabbedCenter && (c.hasDragged = !0, d < h ? d = h : d > f + h - g && (d = f + h - g), c.render(0, 0, d - h, d - h + g)), c.hasDragged && c.scrollbar && l(c.scrollbar.options.liveRedraw, F.svg && !a && !this.chart.isBoosting) && (b.DOMType = b.type, setTimeout(function () {\n          c.onMouseUp(b);\n        }, 0)));\n      };\n\n      f.prototype.onMouseUp = function (a) {\n        var b = this.chart,\n            c = this.xAxis,\n            d = this.scrollbar,\n            e = a.DOMEvent || a,\n            f = b.inverted,\n            g = this.rendered && !this.hasDragged ? \"animate\" : \"attr\";\n\n        if (this.hasDragged && (!d || !d.hasDragged) || \"scrollbar\" === a.trigger) {\n          d = this.getUnionExtremes();\n          if (this.zoomedMin === this.otherHandlePos) var h = this.fixedExtreme;else if (this.zoomedMax === this.otherHandlePos) var l = this.fixedExtreme;\n          this.zoomedMax === this.size && (l = this.reversedExtremes ? d.dataMin : d.dataMax);\n          0 === this.zoomedMin && (h = this.reversedExtremes ? d.dataMax : d.dataMin);\n          c = c.navigatorAxis.toFixedRange(this.zoomedMin, this.zoomedMax, h, l);\n          I(c.min) && b.xAxis[0].setExtremes(Math.min(c.min, c.max), Math.max(c.min, c.max), !0, this.hasDragged ? !1 : null, {\n            trigger: \"navigator\",\n            triggerOp: \"navigator-drag\",\n            DOMEvent: e\n          });\n        }\n\n        \"mousemove\" !== a.DOMType && \"touchmove\" !== a.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null);\n        this.navigatorEnabled && k(this.zoomedMin) && k(this.zoomedMax) && (b = Math.round(this.zoomedMin), a = Math.round(this.zoomedMax), this.shades && this.drawMasks(b, a, f, g), this.outline && this.drawOutline(b, a, f, g), this.navigatorOptions.handles.enabled && Object.keys(this.handles).length === this.handles.length && (this.drawHandle(b, 0, f, g), this.drawHandle(a, 1, f, g)));\n      };\n\n      f.prototype.removeEvents = function () {\n        this.eventsToUnbind && (this.eventsToUnbind.forEach(function (a) {\n          a();\n        }), this.eventsToUnbind = void 0);\n        this.removeBaseSeriesEvents();\n      };\n\n      f.prototype.removeBaseSeriesEvents = function () {\n        var a = this.baseSeries || [];\n        this.navigatorEnabled && a[0] && (!1 !== this.navigatorOptions.adaptToUpdatedData && a.forEach(function (a) {\n          e(a, \"updatedData\", this.updatedDataHandler);\n        }, this), a[0].xAxis && e(a[0].xAxis, \"foundExtremes\", this.modifyBaseAxisExtremes));\n      };\n\n      f.prototype.init = function (a) {\n        var c = a.options,\n            e = c.navigator,\n            f = e.enabled,\n            g = c.scrollbar,\n            h = g.enabled;\n        c = f ? e.height : 0;\n        var k = h ? g.height : 0;\n        this.handles = [];\n        this.shades = [];\n        this.chart = a;\n        this.setBaseSeries();\n        this.height = c;\n        this.scrollbarHeight = k;\n        this.scrollbarEnabled = h;\n        this.navigatorEnabled = f;\n        this.navigatorOptions = e;\n        this.scrollbarOptions = g;\n        this.outlineHeight = c + k;\n        this.opposite = l(e.opposite, !(f || !a.inverted));\n        var n = this;\n        f = n.baseSeries;\n        g = a.xAxis.length;\n        h = a.yAxis.length;\n        var p = f && f[0] && f[0].xAxis || a.xAxis[0] || {\n          options: {}\n        };\n        a.isDirtyBox = !0;\n        n.navigatorEnabled ? (n.xAxis = new d(a, w({\n          breaks: p.options.breaks,\n          ordinal: p.options.ordinal\n        }, e.xAxis, {\n          id: \"navigator-x-axis\",\n          yAxis: \"navigator-y-axis\",\n          isX: !0,\n          type: \"datetime\",\n          index: g,\n          isInternal: !0,\n          offset: 0,\n          keepOrdinalPadding: !0,\n          startOnTick: !1,\n          endOnTick: !1,\n          minPadding: 0,\n          maxPadding: 0,\n          zoomEnabled: !1\n        }, a.inverted ? {\n          offsets: [k, 0, -k, 0],\n          width: c\n        } : {\n          offsets: [0, -k, 0, k],\n          height: c\n        })), n.yAxis = new d(a, w(e.yAxis, {\n          id: \"navigator-y-axis\",\n          alignTicks: !1,\n          offset: 0,\n          index: h,\n          isInternal: !0,\n          reversed: l(e.yAxis && e.yAxis.reversed, a.yAxis[0] && a.yAxis[0].reversed, !1),\n          zoomEnabled: !1\n        }, a.inverted ? {\n          width: c\n        } : {\n          height: c\n        })), f || e.series.data ? n.updateNavigatorSeries(!1) : 0 === a.series.length && (n.unbindRedraw = m(a, \"beforeRedraw\", function () {\n          0 < a.series.length && !n.series && (n.setBaseSeries(), n.unbindRedraw());\n        })), n.reversedExtremes = a.inverted && !n.xAxis.reversed || !a.inverted && n.xAxis.reversed, n.renderElements(), n.addMouseEvents()) : (n.xAxis = {\n          chart: a,\n          navigatorAxis: {\n            fake: !0\n          },\n          translate: function (c, d) {\n            var e = a.xAxis[0],\n                f = e.getExtremes(),\n                g = e.len - 2 * k,\n                h = b(\"min\", e.options.min, f.dataMin);\n            e = b(\"max\", e.options.max, f.dataMax) - h;\n            return d ? c * e / g + h : g * (c - h) / e;\n          },\n          toPixels: function (a) {\n            return this.translate(a);\n          },\n          toValue: function (a) {\n            return this.translate(a, !0);\n          }\n        }, n.xAxis.navigatorAxis.axis = n.xAxis, n.xAxis.navigatorAxis.toFixedRange = t.AdditionsClass.prototype.toFixedRange.bind(n.xAxis.navigatorAxis));\n        a.options.scrollbar.enabled && (a.scrollbar = n.scrollbar = new y(a.renderer, w(a.options.scrollbar, {\n          margin: n.navigatorEnabled ? 0 : 10,\n          vertical: a.inverted\n        }), a), m(n.scrollbar, \"changed\", function (a) {\n          var b = n.size,\n              c = b * this.to;\n          b *= this.from;\n          n.hasDragged = n.scrollbar.hasDragged;\n          n.render(0, 0, b, c);\n          this.shouldUpdateExtremes(a.DOMType) && setTimeout(function () {\n            n.onMouseUp(a);\n          });\n        }));\n        n.addBaseSeriesEvents();\n        n.addChartEvents();\n      };\n\n      f.prototype.getUnionExtremes = function (a) {\n        var c = this.chart.xAxis[0],\n            d = this.xAxis,\n            e = d.options,\n            f = c.options,\n            g;\n        a && null === c.dataMin || (g = {\n          dataMin: l(e && e.min, b(\"min\", f.min, c.dataMin, d.dataMin, d.min)),\n          dataMax: l(e && e.max, b(\"max\", f.max, c.dataMax, d.dataMax, d.max))\n        });\n        return g;\n      };\n\n      f.prototype.setBaseSeries = function (a, b) {\n        var c = this.chart,\n            d = this.baseSeries = [];\n        a = a || c.options && c.options.navigator.baseSeries || (c.series.length ? z(c.series, function (a) {\n          return !a.options.isInternal;\n        }).index : 0);\n        (c.series || []).forEach(function (b, c) {\n          b.options.isInternal || !b.options.showInNavigator && (c !== a && b.options.id !== a || !1 === b.options.showInNavigator) || d.push(b);\n        });\n        this.xAxis && !this.xAxis.navigatorAxis.fake && this.updateNavigatorSeries(!0, b);\n      };\n\n      f.prototype.updateNavigatorSeries = function (a, b) {\n        var c = this,\n            d = c.chart,\n            f = c.baseSeries,\n            h,\n            k,\n            m = c.navigatorOptions.series,\n            p,\n            r = {\n          enableMouseTracking: !1,\n          index: null,\n          linkedTo: null,\n          group: \"nav\",\n          padXAxis: !1,\n          xAxis: \"navigator-x-axis\",\n          yAxis: \"navigator-y-axis\",\n          showInLegend: !1,\n          stacking: void 0,\n          isInternal: !0,\n          states: {\n            inactive: {\n              opacity: 1\n            }\n          }\n        },\n            q = c.series = (c.series || []).filter(function (a) {\n          var b = a.baseSeries;\n          return 0 > f.indexOf(b) ? (b && (e(b, \"updatedData\", c.updatedDataHandler), delete b.navigatorSeries), a.chart && a.destroy(), !1) : !0;\n        });\n        f && f.length && f.forEach(function (a) {\n          var e = a.navigatorSeries,\n              x = v({\n            color: a.color,\n            visible: a.visible\n          }, u(m) ? n.navigator.series : m);\n          e && !1 === c.navigatorOptions.adaptToUpdatedData || (r.name = \"Navigator \" + f.length, h = a.options || {}, p = h.navigatorOptions || {}, x.dataLabels = g(x.dataLabels), k = w(h, r, x, p), k.pointRange = l(x.pointRange, p.pointRange, n.plotOptions[k.type || \"line\"].pointRange), x = p.data || x.data, c.hasNavigatorData = c.hasNavigatorData || !!x, k.data = x || h.data && h.data.slice(0), e && e.options ? e.update(k, b) : (a.navigatorSeries = d.initSeries(k), a.navigatorSeries.baseSeries = a, q.push(a.navigatorSeries)));\n        });\n        if (m.data && (!f || !f.length) || u(m)) c.hasNavigatorData = !1, m = g(m), m.forEach(function (a, b) {\n          r.name = \"Navigator \" + (q.length + 1);\n          k = w(n.navigator.series, {\n            color: d.series[b] && !d.series[b].options.isInternal && d.series[b].color || d.options.colors[b] || d.options.colors[0]\n          }, r, a);\n          k.data = a.data;\n          k.data && (c.hasNavigatorData = !0, q.push(d.initSeries(k)));\n        });\n        a && this.addBaseSeriesEvents();\n      };\n\n      f.prototype.addBaseSeriesEvents = function () {\n        var a = this,\n            b = a.baseSeries || [];\n        b[0] && b[0].xAxis && b[0].eventsToUnbind.push(m(b[0].xAxis, \"foundExtremes\", this.modifyBaseAxisExtremes));\n        b.forEach(function (b) {\n          b.eventsToUnbind.push(m(b, \"show\", function () {\n            this.navigatorSeries && this.navigatorSeries.setVisible(!0, !1);\n          }));\n          b.eventsToUnbind.push(m(b, \"hide\", function () {\n            this.navigatorSeries && this.navigatorSeries.setVisible(!1, !1);\n          }));\n          !1 !== this.navigatorOptions.adaptToUpdatedData && b.xAxis && b.eventsToUnbind.push(m(b, \"updatedData\", this.updatedDataHandler));\n          b.eventsToUnbind.push(m(b, \"remove\", function () {\n            this.navigatorSeries && (K(a.series, this.navigatorSeries), I(this.navigatorSeries.options) && this.navigatorSeries.remove(!1), delete this.navigatorSeries);\n          }));\n        }, this);\n      };\n\n      f.prototype.getBaseSeriesMin = function (a) {\n        return this.baseSeries.reduce(function (a, b) {\n          return Math.min(a, b.xData ? b.xData[0] : a);\n        }, a);\n      };\n\n      f.prototype.modifyNavigatorAxisExtremes = function () {\n        var a = this.xAxis,\n            b;\n        \"undefined\" !== typeof a.getExtremes && (!(b = this.getUnionExtremes(!0)) || b.dataMin === a.min && b.dataMax === a.max || (a.min = b.dataMin, a.max = b.dataMax));\n      };\n\n      f.prototype.modifyBaseAxisExtremes = function () {\n        var a = this.chart.navigator,\n            b = this.getExtremes(),\n            c = b.dataMin,\n            d = b.dataMax;\n        b = b.max - b.min;\n        var e = a.stickToMin,\n            f = a.stickToMax,\n            g = l(this.options.overscroll, 0),\n            h = a.series && a.series[0],\n            m = !!this.setExtremes;\n\n        if (!this.eventArgs || \"rangeSelectorButton\" !== this.eventArgs.trigger) {\n          if (e) {\n            var n = c;\n            var p = n + b;\n          }\n\n          f && (p = d + g, e || (n = Math.max(c, p - b, a.getBaseSeriesMin(h && h.xData ? h.xData[0] : -Number.MAX_VALUE))));\n          m && (e || f) && k(n) && (this.min = this.userMin = n, this.max = this.userMax = p);\n        }\n\n        a.stickToMin = a.stickToMax = null;\n      };\n\n      f.prototype.updatedDataHandler = function () {\n        var a = this.chart.navigator,\n            b = this.navigatorSeries;\n        a.stickToMax = a.reversedExtremes ? 0 === Math.round(a.zoomedMin) : Math.round(a.zoomedMax) >= Math.round(a.size);\n        a.stickToMin = a.shouldStickToMin(this, a);\n        b && !a.hasNavigatorData && (b.options.pointStart = this.xData[0], b.setData(this.options.data, !1, null, !1));\n      };\n\n      f.prototype.shouldStickToMin = function (a, b) {\n        b = b.getBaseSeriesMin(a.xData[0]);\n        var c = a.xAxis;\n        a = c.max;\n        var d = c.min;\n        c = c.options.range;\n        return k(a) && k(d) ? c && 0 < a - b ? a - b < c : d <= b : !1;\n      };\n\n      f.prototype.addChartEvents = function () {\n        this.eventsToUnbind || (this.eventsToUnbind = []);\n        this.eventsToUnbind.push(m(this.chart, \"redraw\", function () {\n          var a = this.navigator,\n              b = a && (a.baseSeries && a.baseSeries[0] && a.baseSeries[0].xAxis || this.xAxis[0]);\n          b && a.render(b.min, b.max);\n        }), m(this.chart, \"getMargins\", function () {\n          var a = this.navigator,\n              b = a.opposite ? \"plotTop\" : \"marginBottom\";\n          this.inverted && (b = a.opposite ? \"marginRight\" : \"plotLeft\");\n          this[b] = (this[b] || 0) + (a.navigatorEnabled || !this.inverted ? a.outlineHeight : 0) + a.navigatorOptions.margin;\n        }));\n      };\n\n      f.prototype.destroy = function () {\n        this.removeEvents();\n        this.xAxis && (K(this.chart.xAxis, this.xAxis), K(this.chart.axes, this.xAxis));\n        this.yAxis && (K(this.chart.yAxis, this.yAxis), K(this.chart.axes, this.yAxis));\n        (this.series || []).forEach(function (a) {\n          a.destroy && a.destroy();\n        });\n        \"series xAxis yAxis shades outline scrollbarTrack scrollbarRifles scrollbarGroup scrollbar navigatorGroup rendered\".split(\" \").forEach(function (a) {\n          this[a] && this[a].destroy && this[a].destroy();\n          this[a] = null;\n        }, this);\n        [this.handles].forEach(function (a) {\n          L(a);\n        }, this);\n      };\n\n      return f;\n    }();\n\n    F.Navigator || (F.Navigator = B, t.compose(d), m(h, \"beforeShowResetZoom\", function () {\n      var b = this.options,\n          c = b.navigator,\n          d = b.rangeSelector;\n      if ((c && c.enabled || d && d.enabled) && (!a && \"x\" === b.chart.zoomType || a && \"x\" === b.chart.pinchType)) return !1;\n    }), m(h, \"beforeRender\", function () {\n      var a = this.options;\n      if (a.navigator.enabled || a.scrollbar.enabled) this.scroller = this.navigator = new B(this);\n    }), m(h, \"afterSetChartSize\", function () {\n      var a = this.legend,\n          b = this.navigator;\n\n      if (b) {\n        var c = a && a.options;\n        var d = b.xAxis;\n        var e = b.yAxis;\n        var f = b.scrollbarHeight;\n        this.inverted ? (b.left = b.opposite ? this.chartWidth - f - b.height : this.spacing[3] + f, b.top = this.plotTop + f) : (b.left = l(d.left, this.plotLeft + f), b.top = b.navigatorOptions.top || this.chartHeight - b.height - f - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (c && \"bottom\" === c.verticalAlign && \"proximate\" !== c.layout && c.enabled && !c.floating ? a.legendHeight + l(c.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0));\n        d && e && (this.inverted ? d.options.left = e.options.left = b.left : d.options.top = e.options.top = b.top, d.setAxisSize(), e.setAxisSize());\n      }\n    }), m(h, \"update\", function (a) {\n      var b = a.options.navigator || {},\n          c = a.options.scrollbar || {};\n      this.navigator || this.scroller || !b.enabled && !c.enabled || (w(!0, this.options.navigator, b), w(!0, this.options.scrollbar, c), delete a.options.navigator, delete a.options.scrollbar);\n    }), m(h, \"afterUpdate\", function (a) {\n      this.navigator || this.scroller || !this.options.navigator.enabled && !this.options.scrollbar.enabled || (this.scroller = this.navigator = new B(this), l(a.redraw, !0) && this.redraw(a.animation));\n    }), m(h, \"afterAddSeries\", function () {\n      this.navigator && this.navigator.setBaseSeries(null, !1);\n    }), m(q, \"afterUpdate\", function () {\n      this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, !1);\n    }), h.prototype.callbacks.push(function (a) {\n      var b = a.navigator;\n      b && a.xAxis[0] && (a = a.xAxis[0].getExtremes(), b.render(a.min, a.max));\n    }));\n    F.Navigator = B;\n    return F.Navigator;\n  });\n  N(h, \"Extensions/RangeSelector.js\", [h[\"Core/Axis/Axis.js\"], h[\"Core/Chart/Chart.js\"], h[\"Core/Globals.js\"], h[\"Core/DefaultOptions.js\"], h[\"Core/Renderer/SVG/SVGElement.js\"], h[\"Core/Utilities.js\"]], function (d, h, A, F, t, G) {\n    function E(a) {\n      if (-1 !== a.indexOf(\"%L\")) return \"text\";\n      var b = \"aAdewbBmoyY\".split(\"\").some(function (b) {\n        return -1 !== a.indexOf(\"%\" + b);\n      }),\n          c = \"HkIlMS\".split(\"\").some(function (b) {\n        return -1 !== a.indexOf(\"%\" + b);\n      });\n      return b && c ? \"datetime-local\" : b ? \"date\" : c ? \"time\" : \"text\";\n    }\n\n    var y = F.defaultOptions,\n        q = G.addEvent,\n        p = G.createElement,\n        f = G.css,\n        c = G.defined,\n        a = G.destroyObjectProperties,\n        n = G.discardElement,\n        m = G.extend,\n        D = G.find,\n        C = G.fireEvent,\n        I = G.isNumber,\n        L = G.merge,\n        K = G.objectEach,\n        v = G.pad,\n        z = G.pick,\n        u = G.pInt,\n        k = G.splat;\n    m(y, {\n      rangeSelector: {\n        allButtonsEnabled: !1,\n        buttons: void 0,\n        buttonSpacing: 5,\n        dropdown: \"responsive\",\n        enabled: void 0,\n        verticalAlign: \"top\",\n        buttonTheme: {\n          width: 28,\n          height: 18,\n          padding: 2,\n          zIndex: 7\n        },\n        floating: !1,\n        x: 0,\n        y: 0,\n        height: void 0,\n        inputBoxBorderColor: \"none\",\n        inputBoxHeight: 17,\n        inputBoxWidth: void 0,\n        inputDateFormat: \"%b %e, %Y\",\n        inputDateParser: void 0,\n        inputEditDateFormat: \"%Y-%m-%d\",\n        inputEnabled: !0,\n        inputPosition: {\n          align: \"right\",\n          x: 0,\n          y: 0\n        },\n        inputSpacing: 5,\n        selected: void 0,\n        buttonPosition: {\n          align: \"left\",\n          x: 0,\n          y: 0\n        },\n        inputStyle: {\n          color: \"#335cad\",\n          cursor: \"pointer\"\n        },\n        labelStyle: {\n          color: \"#666666\"\n        }\n      }\n    });\n    m(y.lang, {\n      rangeSelectorZoom: \"Zoom\",\n      rangeSelectorFrom: \"\",\n      rangeSelectorTo: \"\\u2192\"\n    });\n\n    var w = function () {\n      function e(a) {\n        this.buttons = void 0;\n        this.buttonOptions = e.prototype.defaultButtons;\n        this.initialButtonGroupWidth = 0;\n        this.options = void 0;\n        this.chart = a;\n        this.init(a);\n      }\n\n      e.prototype.clickButton = function (a, e) {\n        var b = this.chart,\n            f = this.buttonOptions[a],\n            g = b.xAxis[0],\n            h = b.scroller && b.scroller.getUnionExtremes() || g || {},\n            l = h.dataMin,\n            m = h.dataMax,\n            n = g && Math.round(Math.min(g.max, z(m, g.max))),\n            p = f.type;\n        h = f._range;\n        var u,\n            B = f.dataGrouping;\n\n        if (null !== l && null !== m) {\n          b.fixedRange = h;\n          this.setSelected(a);\n          B && (this.forcedDataGrouping = !0, d.prototype.setDataGrouping.call(g || {\n            chart: this.chart\n          }, B, !1), this.frozenStates = f.preserveDataGrouping);\n          if (\"month\" === p || \"year\" === p) {\n            if (g) {\n              p = {\n                range: f,\n                max: n,\n                chart: b,\n                dataMin: l,\n                dataMax: m\n              };\n              var w = g.minFromRange.call(p);\n              I(p.newMax) && (n = p.newMax);\n            } else h = f;\n          } else if (h) w = Math.max(n - h, l), n = Math.min(w + h, m);else if (\"ytd\" === p) {\n            if (g) \"undefined\" === typeof m && (l = Number.MAX_VALUE, m = Number.MIN_VALUE, b.series.forEach(function (a) {\n              a = a.xData;\n              l = Math.min(a[0], l);\n              m = Math.max(a[a.length - 1], m);\n            }), e = !1), n = this.getYTDExtremes(m, l, b.time.useUTC), w = u = n.min, n = n.max;else {\n              this.deferredYTDClick = a;\n              return;\n            }\n          } else \"all\" === p && g && (b.navigator && b.navigator.baseSeries[0] && (b.navigator.baseSeries[0].xAxis.options.range = void 0), w = l, n = m);\n          c(w) && (w += f._offsetMin);\n          c(n) && (n += f._offsetMax);\n          this.dropdown && (this.dropdown.selectedIndex = a + 1);\n          if (g) g.setExtremes(w, n, z(e, !0), void 0, {\n            trigger: \"rangeSelectorButton\",\n            rangeSelectorButton: f\n          });else {\n            var t = k(b.options.xAxis)[0];\n            var v = t.range;\n            t.range = h;\n            var y = t.min;\n            t.min = u;\n            q(b, \"load\", function () {\n              t.range = v;\n              t.min = y;\n            });\n          }\n          C(this, \"afterBtnClick\");\n        }\n      };\n\n      e.prototype.setSelected = function (a) {\n        this.selected = this.options.selected = a;\n      };\n\n      e.prototype.init = function (a) {\n        var b = this,\n            c = a.options.rangeSelector,\n            e = c.buttons || b.defaultButtons.slice(),\n            d = c.selected,\n            f = function () {\n          var a = b.minInput,\n              c = b.maxInput;\n          a && a.blur && C(a, \"blur\");\n          c && c.blur && C(c, \"blur\");\n        };\n\n        b.chart = a;\n        b.options = c;\n        b.buttons = [];\n        b.buttonOptions = e;\n        this.eventsToUnbind = [];\n        this.eventsToUnbind.push(q(a.container, \"mousedown\", f));\n        this.eventsToUnbind.push(q(a, \"resize\", f));\n        e.forEach(b.computeButtonRange);\n        \"undefined\" !== typeof d && e[d] && this.clickButton(d, !1);\n        this.eventsToUnbind.push(q(a, \"load\", function () {\n          a.xAxis && a.xAxis[0] && q(a.xAxis[0], \"setExtremes\", function (c) {\n            this.max - this.min !== a.fixedRange && \"rangeSelectorButton\" !== c.trigger && \"updatedData\" !== c.trigger && b.forcedDataGrouping && !b.frozenStates && this.setDataGrouping(!1, !1);\n          });\n        }));\n      };\n\n      e.prototype.updateButtonStates = function () {\n        var a = this,\n            c = this.chart,\n            e = this.dropdown,\n            d = c.xAxis[0],\n            f = Math.round(d.max - d.min),\n            g = !d.hasVisibleSeries,\n            h = c.scroller && c.scroller.getUnionExtremes() || d,\n            k = h.dataMin,\n            l = h.dataMax;\n        c = a.getYTDExtremes(l, k, c.time.useUTC);\n        var m = c.min,\n            n = c.max,\n            p = a.selected,\n            q = I(p),\n            u = a.options.allButtonsEnabled,\n            w = a.buttons;\n        a.buttonOptions.forEach(function (b, c) {\n          var h = b._range,\n              r = b.type,\n              x = b.count || 1,\n              t = w[c],\n              B = 0,\n              v = b._offsetMax - b._offsetMin;\n          b = c === p;\n          var z = h > l - k,\n              y = h < d.minRange,\n              A = !1,\n              J = !1;\n          h = h === f;\n          (\"month\" === r || \"year\" === r) && f + 36E5 >= 864E5 * {\n            month: 28,\n            year: 365\n          }[r] * x - v && f - 36E5 <= 864E5 * {\n            month: 31,\n            year: 366\n          }[r] * x + v ? h = !0 : \"ytd\" === r ? (h = n - m + v === f, A = !b) : \"all\" === r && (h = d.max - d.min >= l - k, J = !b && q && h);\n          r = !u && (z || y || J || g);\n          x = b && h || h && !q && !A || b && a.frozenStates;\n          r ? B = 3 : x && (q = !0, B = 2);\n          t.state !== B && (t.setState(B), e && (e.options[c + 1].disabled = r, 2 === B && (e.selectedIndex = c + 1)), 0 === B && p === c && a.setSelected());\n        });\n      };\n\n      e.prototype.computeButtonRange = function (a) {\n        var b = a.type,\n            c = a.count || 1,\n            e = {\n          millisecond: 1,\n          second: 1E3,\n          minute: 6E4,\n          hour: 36E5,\n          day: 864E5,\n          week: 6048E5\n        };\n        if (e[b]) a._range = e[b] * c;else if (\"month\" === b || \"year\" === b) a._range = 864E5 * {\n          month: 30,\n          year: 365\n        }[b] * c;\n        a._offsetMin = z(a.offsetMin, 0);\n        a._offsetMax = z(a.offsetMax, 0);\n        a._range += a._offsetMax - a._offsetMin;\n      };\n\n      e.prototype.getInputValue = function (a) {\n        a = \"min\" === a ? this.minInput : this.maxInput;\n        var b = this.chart.options.rangeSelector,\n            c = this.chart.time;\n        return a ? (\"text\" === a.type && b.inputDateParser || this.defaultInputDateParser)(a.value, c.useUTC, c) : 0;\n      };\n\n      e.prototype.setInputValue = function (a, e) {\n        var b = this.options,\n            d = this.chart.time,\n            f = \"min\" === a ? this.minInput : this.maxInput;\n        a = \"min\" === a ? this.minDateBox : this.maxDateBox;\n\n        if (f) {\n          var g = f.getAttribute(\"data-hc-time\");\n          g = c(g) ? Number(g) : void 0;\n          c(e) && (c(g) && f.setAttribute(\"data-hc-time-previous\", g), f.setAttribute(\"data-hc-time\", e), g = e);\n          f.value = d.dateFormat(this.inputTypeFormats[f.type] || b.inputEditDateFormat, g);\n          a && a.attr({\n            text: d.dateFormat(b.inputDateFormat, g)\n          });\n        }\n      };\n\n      e.prototype.setInputExtremes = function (a, c, e) {\n        if (a = \"min\" === a ? this.minInput : this.maxInput) {\n          var b = this.inputTypeFormats[a.type],\n              d = this.chart.time;\n          b && (c = d.dateFormat(b, c), a.min !== c && (a.min = c), e = d.dateFormat(b, e), a.max !== e && (a.max = e));\n        }\n      };\n\n      e.prototype.showInput = function (a) {\n        var b = \"min\" === a ? this.minDateBox : this.maxDateBox;\n\n        if ((a = \"min\" === a ? this.minInput : this.maxInput) && b && this.inputGroup) {\n          var c = \"text\" === a.type,\n              e = this.inputGroup,\n              d = e.translateX;\n          e = e.translateY;\n          var g = this.options.inputBoxWidth;\n          f(a, {\n            width: c ? b.width + (g ? -2 : 20) + \"px\" : \"auto\",\n            height: c ? b.height - 2 + \"px\" : \"auto\",\n            border: \"2px solid silver\"\n          });\n          c && g ? f(a, {\n            left: d + b.x + \"px\",\n            top: e + \"px\"\n          }) : f(a, {\n            left: Math.min(Math.round(b.x + d - (a.offsetWidth - b.width) / 2), this.chart.chartWidth - a.offsetWidth) + \"px\",\n            top: e - (a.offsetHeight - b.height) / 2 + \"px\"\n          });\n        }\n      };\n\n      e.prototype.hideInput = function (a) {\n        (a = \"min\" === a ? this.minInput : this.maxInput) && f(a, {\n          top: \"-9999em\",\n          border: 0,\n          width: \"1px\",\n          height: \"1px\"\n        });\n      };\n\n      e.prototype.defaultInputDateParser = function (a, c, e) {\n        var b = a.split(\"/\").join(\"-\").split(\" \").join(\"T\");\n        -1 === b.indexOf(\"T\") && (b += \"T00:00\");\n        if (c) b += \"Z\";else {\n          var d;\n          if (d = A.isSafari) d = b, d = !(6 < d.length && (d.lastIndexOf(\"-\") === d.length - 6 || d.lastIndexOf(\"+\") === d.length - 6));\n          d && (d = new Date(b).getTimezoneOffset() / 60, b += 0 >= d ? \"+\" + v(-d) + \":00\" : \"-\" + v(d) + \":00\");\n        }\n        b = Date.parse(b);\n        I(b) || (a = a.split(\"-\"), b = Date.UTC(u(a[0]), u(a[1]) - 1, u(a[2])));\n        e && c && I(b) && (b += e.getTimezoneOffset(b));\n        return b;\n      };\n\n      e.prototype.drawInput = function (a) {\n        function b() {\n          var b = g.getInputValue(a),\n              e = c.xAxis[0],\n              d = c.scroller && c.scroller.xAxis ? c.scroller.xAxis : e,\n              f = d.dataMin;\n          d = d.dataMax;\n          var h = g.maxInput,\n              k = g.minInput;\n          b !== Number(u.getAttribute(\"data-hc-time-previous\")) && I(b) && (u.setAttribute(\"data-hc-time-previous\", b), n && h && I(f) ? b > Number(h.getAttribute(\"data-hc-time\")) ? b = void 0 : b < f && (b = f) : k && I(d) && (b < Number(k.getAttribute(\"data-hc-time\")) ? b = void 0 : b > d && (b = d)), \"undefined\" !== typeof b && e.setExtremes(n ? b : e.min, n ? e.max : b, void 0, void 0, {\n            trigger: \"rangeSelectorInput\"\n          }));\n        }\n\n        var c = this.chart,\n            e = this.div,\n            d = this.inputGroup,\n            g = this,\n            h = c.renderer.style || {},\n            k = c.renderer,\n            l = c.options.rangeSelector,\n            n = \"min\" === a,\n            q = y.lang[n ? \"rangeSelectorFrom\" : \"rangeSelectorTo\"] || \"\";\n        q = k.label(q, 0).addClass(\"highcharts-range-label\").attr({\n          padding: q ? 2 : 0,\n          height: q ? l.inputBoxHeight : 0\n        }).add(d);\n        k = k.label(\"\", 0).addClass(\"highcharts-range-input\").attr({\n          padding: 2,\n          width: l.inputBoxWidth,\n          height: l.inputBoxHeight,\n          \"text-align\": \"center\"\n        }).on(\"click\", function () {\n          g.showInput(a);\n          g[a + \"Input\"].focus();\n        });\n        c.styledMode || k.attr({\n          stroke: l.inputBoxBorderColor,\n          \"stroke-width\": 1\n        });\n        k.add(d);\n        var u = p(\"input\", {\n          name: a,\n          className: \"highcharts-range-selector\"\n        }, void 0, e);\n        u.setAttribute(\"type\", E(l.inputDateFormat || \"%b %e, %Y\"));\n        c.styledMode || (q.css(L(h, l.labelStyle)), k.css(L({\n          color: \"#333333\"\n        }, h, l.inputStyle)), f(u, m({\n          position: \"absolute\",\n          border: 0,\n          boxShadow: \"0 0 15px rgba(0,0,0,0.3)\",\n          width: \"1px\",\n          height: \"1px\",\n          padding: 0,\n          textAlign: \"center\",\n          fontSize: h.fontSize,\n          fontFamily: h.fontFamily,\n          top: \"-9999em\"\n        }, l.inputStyle)));\n\n        u.onfocus = function () {\n          g.showInput(a);\n        };\n\n        u.onblur = function () {\n          u === A.doc.activeElement && b();\n          g.hideInput(a);\n          g.setInputValue(a);\n          u.blur();\n        };\n\n        var w = !1;\n\n        u.onchange = function () {\n          w || (b(), g.hideInput(a), u.blur());\n        };\n\n        u.onkeypress = function (a) {\n          13 === a.keyCode && b();\n        };\n\n        u.onkeydown = function (a) {\n          w = !0;\n          38 !== a.keyCode && 40 !== a.keyCode || b();\n        };\n\n        u.onkeyup = function () {\n          w = !1;\n        };\n\n        return {\n          dateBox: k,\n          input: u,\n          label: q\n        };\n      };\n\n      e.prototype.getPosition = function () {\n        var a = this.chart,\n            c = a.options.rangeSelector;\n        a = \"top\" === c.verticalAlign ? a.plotTop - a.axisOffset[0] : 0;\n        return {\n          buttonTop: a + c.buttonPosition.y,\n          inputTop: a + c.inputPosition.y - 10\n        };\n      };\n\n      e.prototype.getYTDExtremes = function (a, c, e) {\n        var b = this.chart.time,\n            d = new b.Date(a),\n            f = b.get(\"FullYear\", d);\n        e = e ? b.Date.UTC(f, 0, 1) : +new b.Date(f, 0, 1);\n        c = Math.max(c, e);\n        d = d.getTime();\n        return {\n          max: Math.min(a || d, d),\n          min: c\n        };\n      };\n\n      e.prototype.render = function (a, e) {\n        var b = this.chart,\n            d = b.renderer,\n            f = b.container,\n            g = b.options,\n            h = g.rangeSelector,\n            k = z(g.chart.style && g.chart.style.zIndex, 0) + 1;\n        g = h.inputEnabled;\n\n        if (!1 !== h.enabled) {\n          this.rendered || (this.group = d.g(\"range-selector-group\").attr({\n            zIndex: 7\n          }).add(), this.div = p(\"div\", void 0, {\n            position: \"relative\",\n            height: 0,\n            zIndex: k\n          }), this.buttonOptions.length && this.renderButtons(), f.parentNode && f.parentNode.insertBefore(this.div, f), g && (this.inputGroup = d.g(\"input-group\").add(this.group), d = this.drawInput(\"min\"), this.minDateBox = d.dateBox, this.minLabel = d.label, this.minInput = d.input, d = this.drawInput(\"max\"), this.maxDateBox = d.dateBox, this.maxLabel = d.label, this.maxInput = d.input));\n\n          if (g && (this.setInputValue(\"min\", a), this.setInputValue(\"max\", e), a = b.scroller && b.scroller.getUnionExtremes() || b.xAxis[0] || {}, c(a.dataMin) && c(a.dataMax) && (b = b.xAxis[0].minRange || 0, this.setInputExtremes(\"min\", a.dataMin, Math.min(a.dataMax, this.getInputValue(\"max\")) - b), this.setInputExtremes(\"max\", Math.max(a.dataMin, this.getInputValue(\"min\")) + b, a.dataMax)), this.inputGroup)) {\n            var l = 0;\n            [this.minLabel, this.minDateBox, this.maxLabel, this.maxDateBox].forEach(function (a) {\n              if (a) {\n                var b = a.getBBox().width;\n                b && (a.attr({\n                  x: l\n                }), l += b + h.inputSpacing);\n              }\n            });\n          }\n\n          this.alignElements();\n          this.rendered = !0;\n        }\n      };\n\n      e.prototype.renderButtons = function () {\n        var a = this,\n            c = this.buttons,\n            d = this.options,\n            e = y.lang,\n            f = this.chart.renderer,\n            g = L(d.buttonTheme),\n            h = g && g.states,\n            k = g.width || 28;\n        delete g.width;\n        delete g.states;\n        this.buttonGroup = f.g(\"range-selector-buttons\").add(this.group);\n        var l = this.dropdown = p(\"select\", void 0, {\n          position: \"absolute\",\n          width: \"1px\",\n          height: \"1px\",\n          padding: 0,\n          border: 0,\n          top: \"-9999em\",\n          cursor: \"pointer\",\n          opacity: .0001\n        }, this.div);\n        q(l, \"touchstart\", function () {\n          l.style.fontSize = \"16px\";\n        });\n        [[A.isMS ? \"mouseover\" : \"mouseenter\"], [A.isMS ? \"mouseout\" : \"mouseleave\"], [\"change\", \"click\"]].forEach(function (b) {\n          var d = b[0],\n              e = b[1];\n          q(l, d, function () {\n            var b = c[a.currentButtonIndex()];\n            b && C(b.element, e || d);\n          });\n        });\n        this.zoomText = f.label(e && e.rangeSelectorZoom || \"\", 0).attr({\n          padding: d.buttonTheme.padding,\n          height: d.buttonTheme.height,\n          paddingLeft: 0,\n          paddingRight: 0\n        }).add(this.buttonGroup);\n        this.chart.styledMode || (this.zoomText.css(d.labelStyle), g[\"stroke-width\"] = z(g[\"stroke-width\"], 0));\n        p(\"option\", {\n          textContent: this.zoomText.textStr,\n          disabled: !0\n        }, void 0, l);\n        this.buttonOptions.forEach(function (b, d) {\n          p(\"option\", {\n            textContent: b.title || b.text\n          }, void 0, l);\n          c[d] = f.button(b.text, 0, 0, function (c) {\n            var e = b.events && b.events.click,\n                f;\n            e && (f = e.call(b, c));\n            !1 !== f && a.clickButton(d);\n            a.isActive = !0;\n          }, g, h && h.hover, h && h.select, h && h.disabled).attr({\n            \"text-align\": \"center\",\n            width: k\n          }).add(a.buttonGroup);\n          b.title && c[d].attr(\"title\", b.title);\n        });\n      };\n\n      e.prototype.alignElements = function () {\n        var a = this,\n            c = this.buttonGroup,\n            d = this.buttons,\n            e = this.chart,\n            f = this.group,\n            g = this.inputGroup,\n            h = this.options,\n            k = this.zoomText,\n            l = e.options,\n            m = l.exporting && !1 !== l.exporting.enabled && l.navigation && l.navigation.buttonOptions;\n        l = h.buttonPosition;\n\n        var n = h.inputPosition,\n            p = h.verticalAlign,\n            q = function (b, c) {\n          return m && a.titleCollision(e) && \"top\" === p && \"right\" === c.align && c.y - b.getBBox().height - 12 < (m.y || 0) + (m.height || 0) + e.spacing[0] ? -40 : 0;\n        },\n            u = e.plotLeft;\n\n        if (f && l && n) {\n          var w = l.x - e.spacing[3];\n\n          if (c) {\n            this.positionButtons();\n\n            if (!this.initialButtonGroupWidth) {\n              var t = 0;\n              k && (t += k.getBBox().width + 5);\n              d.forEach(function (a, b) {\n                t += a.width;\n                b !== d.length - 1 && (t += h.buttonSpacing);\n              });\n              this.initialButtonGroupWidth = t;\n            }\n\n            u -= e.spacing[3];\n            this.updateButtonStates();\n            k = q(c, l);\n            this.alignButtonGroup(k);\n            f.placed = c.placed = e.hasLoaded;\n          }\n\n          c = 0;\n          g && (c = q(g, n), \"left\" === n.align ? w = u : \"right\" === n.align && (w = -Math.max(e.axisOffset[1], -c)), g.align({\n            y: n.y,\n            width: g.getBBox().width,\n            align: n.align,\n            x: n.x + w - 2\n          }, !0, e.spacingBox), g.placed = e.hasLoaded);\n          this.handleCollision(c);\n          f.align({\n            verticalAlign: p\n          }, !0, e.spacingBox);\n          g = f.alignAttr.translateY;\n          c = f.getBBox().height + 20;\n          q = 0;\n          \"bottom\" === p && (q = (q = e.legend && e.legend.options) && \"bottom\" === q.verticalAlign && q.enabled && !q.floating ? e.legend.legendHeight + z(q.margin, 10) : 0, c = c + q - 20, q = g - c - (h.floating ? 0 : h.y) - (e.titleOffset ? e.titleOffset[2] : 0) - 10);\n          if (\"top\" === p) h.floating && (q = 0), e.titleOffset && e.titleOffset[0] && (q = e.titleOffset[0]), q += e.margin[0] - e.spacing[0] || 0;else if (\"middle\" === p) if (n.y === l.y) q = g;else if (n.y || l.y) q = 0 > n.y || 0 > l.y ? q - Math.min(n.y, l.y) : g - c;\n          f.translate(h.x, h.y + Math.floor(q));\n          l = this.minInput;\n          n = this.maxInput;\n          g = this.dropdown;\n          h.inputEnabled && l && n && (l.style.marginTop = f.translateY + \"px\", n.style.marginTop = f.translateY + \"px\");\n          g && (g.style.marginTop = f.translateY + \"px\");\n        }\n      };\n\n      e.prototype.alignButtonGroup = function (a, c) {\n        var b = this.chart,\n            e = this.buttonGroup,\n            d = this.options.buttonPosition,\n            f = b.plotLeft - b.spacing[3],\n            g = d.x - b.spacing[3];\n        \"right\" === d.align ? g += a - f : \"center\" === d.align && (g -= f / 2);\n        e && e.align({\n          y: d.y,\n          width: z(c, this.initialButtonGroupWidth),\n          align: d.align,\n          x: g\n        }, !0, b.spacingBox);\n      };\n\n      e.prototype.positionButtons = function () {\n        var a = this.buttons,\n            c = this.chart,\n            e = this.options,\n            d = this.zoomText,\n            f = c.hasLoaded ? \"animate\" : \"attr\",\n            g = e.buttonPosition,\n            h = c.plotLeft,\n            k = h;\n        d && \"hidden\" !== d.visibility && (d[f]({\n          x: z(h + g.x, h)\n        }), k += g.x + d.getBBox().width + 5);\n        this.buttonOptions.forEach(function (b, c) {\n          if (\"hidden\" !== a[c].visibility) a[c][f]({\n            x: k\n          }), k += a[c].width + e.buttonSpacing;else a[c][f]({\n            x: h\n          });\n        });\n      };\n\n      e.prototype.handleCollision = function (a) {\n        var b = this,\n            c = this.chart,\n            e = this.buttonGroup,\n            d = this.inputGroup,\n            f = this.options,\n            g = f.buttonPosition,\n            h = f.dropdown,\n            k = f.inputPosition;\n\n        f = function () {\n          var a = 0;\n          b.buttons.forEach(function (b) {\n            b = b.getBBox();\n            b.width > a && (a = b.width);\n          });\n          return a;\n        };\n\n        var l = function (b) {\n          if (d && e) {\n            var c = d.alignAttr.translateX + d.alignOptions.x - a + d.getBBox().x + 2,\n                f = d.alignOptions.width,\n                h = e.alignAttr.translateX + e.getBBox().x;\n            return h + b > c && c + f > h && g.y < k.y + d.getBBox().height;\n          }\n\n          return !1;\n        },\n            m = function () {\n          d && e && d.attr({\n            translateX: d.alignAttr.translateX + (c.axisOffset[1] >= -a ? 0 : -a),\n            translateY: d.alignAttr.translateY + e.getBBox().height + 10\n          });\n        };\n\n        if (e) {\n          if (\"always\" === h) {\n            this.collapseButtons(a);\n            l(f()) && m();\n            return;\n          }\n\n          \"never\" === h && this.expandButtons();\n        }\n\n        d && e ? k.align === g.align || l(this.initialButtonGroupWidth + 20) ? \"responsive\" === h ? (this.collapseButtons(a), l(f()) && m()) : m() : \"responsive\" === h && this.expandButtons() : e && \"responsive\" === h && (this.initialButtonGroupWidth > c.plotWidth ? this.collapseButtons(a) : this.expandButtons());\n      };\n\n      e.prototype.collapseButtons = function (a) {\n        var b = this.buttons,\n            c = this.buttonOptions,\n            e = this.chart,\n            d = this.dropdown,\n            f = this.options,\n            g = this.zoomText,\n            h = e.userOptions.rangeSelector && e.userOptions.rangeSelector.buttonTheme || {},\n            k = function (a) {\n          return {\n            text: a ? a + \" \\u25be\" : \"\\u25be\",\n            width: \"auto\",\n            paddingLeft: z(f.buttonTheme.paddingLeft, h.padding, 8),\n            paddingRight: z(f.buttonTheme.paddingRight, h.padding, 8)\n          };\n        };\n\n        g && g.hide();\n        var l = !1;\n        c.forEach(function (a, c) {\n          c = b[c];\n          2 !== c.state ? c.hide() : (c.show(), c.attr(k(a.text)), l = !0);\n        });\n        l || (d && (d.selectedIndex = 0), b[0].show(), b[0].attr(k(this.zoomText && this.zoomText.textStr)));\n        c = f.buttonPosition.align;\n        this.positionButtons();\n        \"right\" !== c && \"center\" !== c || this.alignButtonGroup(a, b[this.currentButtonIndex()].getBBox().width);\n        this.showDropdown();\n      };\n\n      e.prototype.expandButtons = function () {\n        var a = this.buttons,\n            c = this.buttonOptions,\n            e = this.options,\n            d = this.zoomText;\n        this.hideDropdown();\n        d && d.show();\n        c.forEach(function (b, c) {\n          c = a[c];\n          c.show();\n          c.attr({\n            text: b.text,\n            width: e.buttonTheme.width || 28,\n            paddingLeft: z(e.buttonTheme.paddingLeft, \"unset\"),\n            paddingRight: z(e.buttonTheme.paddingRight, \"unset\")\n          });\n          2 > c.state && c.setState(0);\n        });\n        this.positionButtons();\n      };\n\n      e.prototype.currentButtonIndex = function () {\n        var a = this.dropdown;\n        return a && 0 < a.selectedIndex ? a.selectedIndex - 1 : 0;\n      };\n\n      e.prototype.showDropdown = function () {\n        var a = this.buttonGroup,\n            c = this.buttons,\n            e = this.chart,\n            d = this.dropdown;\n\n        if (a && d) {\n          var g = a.translateX;\n          a = a.translateY;\n          c = c[this.currentButtonIndex()].getBBox();\n          f(d, {\n            left: e.plotLeft + g + \"px\",\n            top: a + .5 + \"px\",\n            width: c.width + \"px\",\n            height: c.height + \"px\"\n          });\n          this.hasVisibleDropdown = !0;\n        }\n      };\n\n      e.prototype.hideDropdown = function () {\n        var a = this.dropdown;\n        a && (f(a, {\n          top: \"-9999em\",\n          width: \"1px\",\n          height: \"1px\"\n        }), this.hasVisibleDropdown = !1);\n      };\n\n      e.prototype.getHeight = function () {\n        var a = this.options,\n            c = this.group,\n            e = a.y,\n            d = a.buttonPosition.y,\n            f = a.inputPosition.y;\n        if (a.height) return a.height;\n        this.alignElements();\n        a = c ? c.getBBox(!0).height + 13 + e : 0;\n        c = Math.min(f, d);\n        if (0 > f && 0 > d || 0 < f && 0 < d) a += Math.abs(c);\n        return a;\n      };\n\n      e.prototype.titleCollision = function (a) {\n        return !(a.options.title.text || a.options.subtitle.text);\n      };\n\n      e.prototype.update = function (a) {\n        var b = this.chart;\n        L(!0, b.options.rangeSelector, a);\n        this.destroy();\n        this.init(b);\n        this.render();\n      };\n\n      e.prototype.destroy = function () {\n        var b = this,\n            c = b.minInput,\n            d = b.maxInput;\n        b.eventsToUnbind && (b.eventsToUnbind.forEach(function (a) {\n          return a();\n        }), b.eventsToUnbind = void 0);\n        a(b.buttons);\n        c && (c.onfocus = c.onblur = c.onchange = null);\n        d && (d.onfocus = d.onblur = d.onchange = null);\n        K(b, function (a, c) {\n          a && \"chart\" !== c && (a instanceof t ? a.destroy() : a instanceof window.HTMLElement && n(a));\n          a !== e.prototype[c] && (b[c] = null);\n        }, this);\n      };\n\n      return e;\n    }();\n\n    w.prototype.defaultButtons = [{\n      type: \"month\",\n      count: 1,\n      text: \"1m\",\n      title: \"View 1 month\"\n    }, {\n      type: \"month\",\n      count: 3,\n      text: \"3m\",\n      title: \"View 3 months\"\n    }, {\n      type: \"month\",\n      count: 6,\n      text: \"6m\",\n      title: \"View 6 months\"\n    }, {\n      type: \"ytd\",\n      text: \"YTD\",\n      title: \"View year to date\"\n    }, {\n      type: \"year\",\n      count: 1,\n      text: \"1y\",\n      title: \"View 1 year\"\n    }, {\n      type: \"all\",\n      text: \"All\",\n      title: \"View all\"\n    }];\n    w.prototype.inputTypeFormats = {\n      \"datetime-local\": \"%Y-%m-%dT%H:%M:%S\",\n      date: \"%Y-%m-%d\",\n      time: \"%H:%M:%S\"\n    };\n\n    d.prototype.minFromRange = function () {\n      var a = this.range,\n          b = a.type,\n          c = this.max,\n          d = this.chart.time,\n          e = function (a, c) {\n        var e = \"year\" === b ? \"FullYear\" : \"Month\",\n            f = new d.Date(a),\n            g = d.get(e, f);\n        d.set(e, f, g + c);\n        g === d.get(e, f) && d.set(\"Date\", f, 0);\n        return f.getTime() - a;\n      };\n\n      if (I(a)) {\n        var f = c - a;\n        var h = a;\n      } else f = c + e(c, -a.count), this.chart && (this.chart.fixedRange = c - f);\n\n      var k = z(this.dataMin, Number.MIN_VALUE);\n      I(f) || (f = k);\n      f <= k && (f = k, \"undefined\" === typeof h && (h = e(f, a.count)), this.newMax = Math.min(f + h, this.dataMax));\n      I(c) || (f = void 0);\n      return f;\n    };\n\n    if (!A.RangeSelector) {\n      var l = [],\n          e = function (a) {\n        function b() {\n          e && (c = a.xAxis[0].getExtremes(), d = a.legend, g = e && e.options.verticalAlign, I(c.min) && e.render(c.min, c.max), d.display && \"top\" === g && g === d.options.verticalAlign && (f = L(a.spacingBox), f.y = \"vertical\" === d.options.layout ? a.plotTop : f.y + e.getHeight(), d.group.placed = !1, d.align(f)));\n        }\n\n        var c,\n            e = a.rangeSelector,\n            d,\n            f,\n            g;\n        e && (D(l, function (b) {\n          return b[0] === a;\n        }) || l.push([a, [q(a.xAxis[0], \"afterSetExtremes\", function (a) {\n          e && e.render(a.min, a.max);\n        }), q(a, \"redraw\", b)]]), b());\n      };\n\n      q(h, \"afterGetContainer\", function () {\n        this.options.rangeSelector && this.options.rangeSelector.enabled && (this.rangeSelector = new w(this));\n      });\n      q(h, \"beforeRender\", function () {\n        var a = this.axes,\n            b = this.rangeSelector;\n        b && (I(b.deferredYTDClick) && (b.clickButton(b.deferredYTDClick), delete b.deferredYTDClick), a.forEach(function (a) {\n          a.updateNames();\n          a.setScale();\n        }), this.getAxisMargins(), b.render(), a = b.options.verticalAlign, b.options.floating || (\"bottom\" === a ? this.extraBottomMargin = !0 : \"middle\" !== a && (this.extraTopMargin = !0)));\n      });\n      q(h, \"update\", function (a) {\n        var b = a.options.rangeSelector;\n        a = this.rangeSelector;\n        var d = this.extraBottomMargin,\n            f = this.extraTopMargin;\n        b && b.enabled && !c(a) && this.options.rangeSelector && (this.options.rangeSelector.enabled = !0, this.rangeSelector = a = new w(this));\n        this.extraTopMargin = this.extraBottomMargin = !1;\n        a && (e(this), b = b && b.verticalAlign || a.options && a.options.verticalAlign, a.options.floating || (\"bottom\" === b ? this.extraBottomMargin = !0 : \"middle\" !== b && (this.extraTopMargin = !0)), this.extraBottomMargin !== d || this.extraTopMargin !== f) && (this.isDirtyBox = !0);\n      });\n      q(h, \"render\", function () {\n        var a = this.rangeSelector;\n        a && !a.options.floating && (a.render(), a = a.options.verticalAlign, \"bottom\" === a ? this.extraBottomMargin = !0 : \"middle\" !== a && (this.extraTopMargin = !0));\n      });\n      q(h, \"getMargins\", function () {\n        var a = this.rangeSelector;\n        a && (a = a.getHeight(), this.extraTopMargin && (this.plotTop += a), this.extraBottomMargin && (this.marginBottom += a));\n      });\n      h.prototype.callbacks.push(e);\n      q(h, \"destroy\", function () {\n        for (var a = 0; a < l.length; a++) {\n          var b = l[a];\n\n          if (b[0] === this) {\n            b[1].forEach(function (a) {\n              return a();\n            });\n            l.splice(a, 1);\n            break;\n          }\n        }\n      });\n      A.RangeSelector = w;\n    }\n\n    return w;\n  });\n  N(h, \"Core/Chart/StockChart.js\", [h[\"Core/Animation/AnimationUtilities.js\"], h[\"Core/Axis/Axis.js\"], h[\"Core/Chart/Chart.js\"], h[\"Core/FormatUtilities.js\"], h[\"Core/DefaultOptions.js\"], h[\"Core/Series/Series.js\"], h[\"Core/Renderer/SVG/SVGRenderer.js\"], h[\"Core/Utilities.js\"]], function (d, h, A, F, t, G, H, y) {\n    function q(a, c) {\n      return \"xAxis\" === a ? {\n        minPadding: 0,\n        maxPadding: 0,\n        overscroll: 0,\n        ordinal: !0,\n        title: {\n          text: null\n        },\n        labels: {\n          overflow: \"justify\"\n        },\n        showLastLabel: !0\n      } : \"yAxis\" === a ? {\n        labels: {\n          y: -2\n        },\n        opposite: v(c.opposite, !0),\n        showLastLabel: !(!c.categories && \"category\" !== c.type),\n        title: {\n          text: null\n        }\n      } : {};\n    }\n\n    function p(c, d) {\n      if (\"xAxis\" === c) {\n        c = a();\n        var f = {\n          type: \"datetime\",\n          categories: void 0\n        };\n        v(d.navigator && d.navigator.enabled, c.navigator.enabled, !0) && (f.startOnTick = !1, f.endOnTick = !1);\n        return f;\n      }\n\n      return {};\n    }\n\n    var f = this && this.__extends || function () {\n      var a = function (c, d) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, c) {\n          a.__proto__ = c;\n        } || function (a, c) {\n          for (var d in c) c.hasOwnProperty(d) && (a[d] = c[d]);\n        };\n\n        return a(c, d);\n      };\n\n      return function (c, d) {\n        function f() {\n          this.constructor = c;\n        }\n\n        a(c, d);\n        c.prototype = null === d ? Object.create(d) : (f.prototype = d.prototype, new f());\n      };\n    }(),\n        c = F.format,\n        a = t.getOptions;\n\n    d = y.addEvent;\n    var n = y.clamp,\n        m = y.defined,\n        E = y.extend,\n        C = y.find,\n        I = y.isNumber,\n        L = y.isString,\n        K = y.merge,\n        v = y.pick,\n        z = y.splat;\n\n    y = function (c) {\n      function d() {\n        return null !== c && c.apply(this, arguments) || this;\n      }\n\n      f(d, c);\n\n      d.prototype.init = function (d, f) {\n        var e = a(),\n            g = d.xAxis,\n            b = d.yAxis,\n            h = v(d.navigator && d.navigator.enabled, e.navigator.enabled, !0);\n        d.xAxis = d.yAxis = void 0;\n        h = K({\n          chart: {\n            panning: {\n              enabled: !0,\n              type: \"x\"\n            },\n            pinchType: \"x\"\n          },\n          navigator: {\n            enabled: h\n          },\n          scrollbar: {\n            enabled: v(e.scrollbar && e.scrollbar.enabled, !0)\n          },\n          rangeSelector: {\n            enabled: v(e.rangeSelector.enabled, !0)\n          },\n          title: {\n            text: null\n          },\n          tooltip: {\n            split: v(e.tooltip.split, !0),\n            crosshairs: !0\n          },\n          legend: {\n            enabled: !1\n          }\n        }, d, {\n          isStock: !0\n        });\n        d.xAxis = g;\n        d.yAxis = b;\n        h.xAxis = z(d.xAxis || {}).map(function (a, b) {\n          return K(q(\"xAxis\", a), e.xAxis, e.xAxis && e.xAxis[b], a, p(\"xAxis\", d));\n        });\n        h.yAxis = z(d.yAxis || {}).map(function (a, b) {\n          return K(q(\"yAxis\", a), e.yAxis, e.yAxis && e.yAxis[b], a);\n        });\n        c.prototype.init.call(this, h, f);\n      };\n\n      d.prototype.createAxis = function (a, d) {\n        d.axis = K(q(a, d.axis), d.axis, p(a, this.userOptions));\n        return c.prototype.createAxis.call(this, a, d);\n      };\n\n      return d;\n    }(A);\n\n    (function (a) {\n      a.stockChart = function (c, d, f) {\n        return new a(c, d, f);\n      };\n    })(y || (y = {}));\n\n    d(G, \"setOptions\", function (a) {\n      var c;\n      this.chart.options.isStock && (this.is(\"column\") || this.is(\"columnrange\") ? c = {\n        borderWidth: 0,\n        shadow: !1\n      } : this.is(\"scatter\") || this.is(\"sma\") || (c = {\n        marker: {\n          enabled: !1,\n          radius: 2\n        }\n      }), c && (a.plotOptions[this.type] = K(a.plotOptions[this.type], c)));\n    });\n    d(h, \"autoLabelAlign\", function (a) {\n      var c = this.chart,\n          d = this.options;\n      c = c._labelPanes = c._labelPanes || {};\n      var f = this.options.labels;\n      this.chart.options.isStock && \"yAxis\" === this.coll && (d = d.top + \",\" + d.height, !c[d] && f.enabled && (15 === f.x && (f.x = 0), \"undefined\" === typeof f.align && (f.align = \"right\"), c[d] = this, a.align = \"right\", a.preventDefault()));\n    });\n    d(h, \"destroy\", function () {\n      var a = this.chart,\n          c = this.options && this.options.top + \",\" + this.options.height;\n      c && a._labelPanes && a._labelPanes[c] === this && delete a._labelPanes[c];\n    });\n    d(h, \"getPlotLinePath\", function (a) {\n      function c(a) {\n        var b = \"xAxis\" === a ? \"yAxis\" : \"xAxis\";\n        a = d.options[b];\n        return I(a) ? [e[b][a]] : L(a) ? [e.get(a)] : f.map(function (a) {\n          return a[b];\n        });\n      }\n\n      var d = this,\n          f = this.isLinked && !this.series ? this.linkedParent.series : this.series,\n          e = d.chart,\n          g = e.renderer,\n          b = d.left,\n          h = d.top,\n          p,\n          q,\n          u,\n          t,\n          z = [],\n          y = [],\n          A = a.translatedValue,\n          E = a.value,\n          D = a.force;\n\n      if (e.options.isStock && !1 !== a.acrossPanes && \"xAxis\" === d.coll || \"yAxis\" === d.coll) {\n        a.preventDefault();\n        y = c(d.coll);\n        var F = d.isXAxis ? e.yAxis : e.xAxis;\n        F.forEach(function (a) {\n          if (m(a.options.id) ? -1 === a.options.id.indexOf(\"navigator\") : 1) {\n            var b = a.isXAxis ? \"yAxis\" : \"xAxis\";\n            b = m(a.options[b]) ? e[b][a.options[b]] : e[b][0];\n            d === b && y.push(a);\n          }\n        });\n        var G = y.length ? [] : [d.isXAxis ? e.yAxis[0] : e.xAxis[0]];\n        y.forEach(function (a) {\n          -1 !== G.indexOf(a) || C(G, function (b) {\n            return b.pos === a.pos && b.len === a.len;\n          }) || G.push(a);\n        });\n        var H = v(A, d.translate(E, null, null, a.old));\n        I(H) && (d.horiz ? G.forEach(function (a) {\n          var c;\n          q = a.pos;\n          t = q + a.len;\n          p = u = Math.round(H + d.transB);\n          \"pass\" !== D && (p < b || p > b + d.width) && (D ? p = u = n(p, b, b + d.width) : c = !0);\n          c || z.push([\"M\", p, q], [\"L\", u, t]);\n        }) : G.forEach(function (a) {\n          var b;\n          p = a.pos;\n          u = p + a.len;\n          q = t = Math.round(h + d.height - H);\n          \"pass\" !== D && (q < h || q > h + d.height) && (D ? q = t = n(q, h, h + d.height) : b = !0);\n          b || z.push([\"M\", p, q], [\"L\", u, t]);\n        }));\n        a.path = 0 < z.length ? g.crispPolyLine(z, a.lineWidth || 1) : null;\n      }\n    });\n\n    H.prototype.crispPolyLine = function (a, c) {\n      for (var d = 0; d < a.length; d += 2) {\n        var f = a[d],\n            e = a[d + 1];\n        f[1] === e[1] && (f[1] = e[1] = Math.round(f[1]) - c % 2 / 2);\n        f[2] === e[2] && (f[2] = e[2] = Math.round(f[2]) + c % 2 / 2);\n      }\n\n      return a;\n    };\n\n    d(h, \"afterHideCrosshair\", function () {\n      this.crossLabel && (this.crossLabel = this.crossLabel.hide());\n    });\n    d(h, \"afterDrawCrosshair\", function (a) {\n      var d, f;\n\n      if (this.crosshair && this.crosshair.label && this.crosshair.label.enabled && this.cross && I(this.min) && I(this.max)) {\n        var h = this.chart,\n            e = this.logarithmic,\n            g = this.crosshair.label,\n            b = this.horiz,\n            m = this.opposite,\n            n = this.left,\n            p = this.top,\n            q = this.crossLabel,\n            u = g.format,\n            t = \"\",\n            z = \"inside\" === this.options.tickPosition,\n            y = !1 !== this.crosshair.snap,\n            A = 0,\n            C = a.e || this.cross && this.cross.e;\n        a = a.point;\n        var D = this.min,\n            F = this.max;\n        e && (D = e.lin2log(D), F = e.lin2log(F));\n        e = b ? \"center\" : m ? \"right\" === this.labelAlign ? \"right\" : \"left\" : \"left\" === this.labelAlign ? \"left\" : \"center\";\n        q || (q = this.crossLabel = h.renderer.label(\"\", 0, void 0, g.shape || \"callout\").addClass(\"highcharts-crosshair-label highcharts-color-\" + (a ? a.series.colorIndex : this.series[0] && this.series[0].colorIndex)).attr({\n          align: g.align || e,\n          padding: v(g.padding, 8),\n          r: v(g.borderRadius, 3),\n          zIndex: 2\n        }).add(this.labelGroup), h.styledMode || q.attr({\n          fill: g.backgroundColor || a && a.series && a.series.color || \"#666666\",\n          stroke: g.borderColor || \"\",\n          \"stroke-width\": g.borderWidth || 0\n        }).css(E({\n          color: \"#ffffff\",\n          fontWeight: \"normal\",\n          fontSize: \"11px\",\n          textAlign: \"center\"\n        }, g.style || {})));\n        b ? (e = y ? (a.plotX || 0) + n : C.chartX, p += m ? 0 : this.height) : (e = m ? this.width + n : 0, p = y ? (a.plotY || 0) + p : C.chartY);\n        u || g.formatter || (this.dateTime && (t = \"%b %d, %Y\"), u = \"{value\" + (t ? \":\" + t : \"\") + \"}\");\n        t = y ? this.isXAxis ? a.x : a.y : this.toValue(b ? C.chartX : C.chartY);\n        y = a ? a.series.isPointInside(a) : I(t) && t > D && t < F;\n        C = \"\";\n        u ? C = c(u, {\n          value: t\n        }, h) : g.formatter && I(t) && (C = g.formatter.call(this, t));\n        q.attr({\n          text: C,\n          x: e,\n          y: p,\n          visibility: y ? \"visible\" : \"hidden\"\n        });\n        g = q.getBBox();\n        if (I(q.y)) if (b) {\n          if (z && !m || !z && m) p = q.y - g.height;\n        } else p = q.y - g.height / 2;\n        b ? (d = n - g.x, f = n + this.width - g.x) : (d = \"left\" === this.labelAlign ? n : 0, f = \"right\" === this.labelAlign ? n + this.width : h.chartWidth);\n        q.translateX < d && (A = d - q.translateX);\n        q.translateX + g.width >= f && (A = -(q.translateX + g.width - f));\n        q.attr({\n          x: e + A,\n          y: p,\n          anchorX: b ? e : this.opposite ? 0 : h.chartWidth,\n          anchorY: b ? this.opposite ? h.chartHeight : 0 : p + g.height / 2\n        });\n      }\n    });\n\n    G.prototype.forceCropping = function () {\n      var a = this.chart,\n          c = this.options.dataGrouping;\n      return !1 !== this.allowDG && c && v(c.enabled, a.options.isStock);\n    };\n\n    d(A, \"update\", function (a) {\n      a = a.options;\n      \"scrollbar\" in a && this.navigator && (K(!0, this.options.scrollbar, a.scrollbar), this.navigator.update({}, !1), delete a.scrollbar);\n    });\n    return y;\n  });\n  N(h, \"masters/modules/stock.src.js\", [h[\"Core/Globals.js\"], h[\"Core/Axis/OrdinalAxis.js\"], h[\"Series/DataModifyComposition.js\"], h[\"Core/Scrollbar.js\"], h[\"Core/Chart/StockChart.js\"]], function (d, h, A, F, t) {\n    d.Scrollbar = F;\n    d.StockChart = d.stockChart = t.stockChart;\n    F.compose(d.Axis);\n    h.compose(d.Axis, d.Series, d.Chart);\n    A.compose(d.Series, d.Axis, d.Point);\n  });\n  N(h, \"masters/highstock.src.js\", [h[\"masters/highcharts.src.js\"]], function (d) {\n    d.product = \"Highstock\";\n    return d;\n  });\n  h[\"masters/highstock.src.js\"]._modules = h;\n  return h[\"masters/highstock.src.js\"];\n}); //# sourceMappingURL=highstock.js.map","map":null,"metadata":{},"sourceType":"script"}